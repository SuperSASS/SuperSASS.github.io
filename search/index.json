[{"content":"题目链接 P4863 JerryC Loves Driving\n题目分析 对于一层求和，其实就是一层for，那么两层求和就是两层for，也就是二维的。\n而对于求和O(n)的优化计算方法，最基本的就是转换为等差数列O(1)计算。\n我们将两层求和的每一项列表观察（看是否有等差数列），得出下表：\n\r求和表\r\n图片来自于「Insouciant21」的题解。\n观察发现，对于每一列，是类似呈等差数列的形式的，\n对于第$i$列，是由$i$个$0 \\sim n$的等差数列组成。\n 如第四列：为$4$个$0,1,2,\\cdots,n$的等差数列组成。\n 因此我们就可以O(1)计算出每一列的和，那么就只用按列循环依次求和，O(n)的时间内求出结果。\n 想到求解方法后，我们来确定求和计算范围。\n 以下以$A=2, B=7$来举例。\n \r求和表范围1\r\n对于题上给出的两个界：上界$A$和下届$B$，\n按照题中所给公式，最初始的范围，则对应图中红色框选内容。\n由于0部分不影响，所以也可以看成蓝色矩形部分。\n但如果直接这样进行计算，会发现会有很多要考虑的地方，或说运用等差数列时有很多边界的处理。\n 如图中所给例子：\n对于$2$这一列，则上方的$1$并不完全属于$n$个等差数列中，要排除。 对于$3$这一列，则下方的$-2$并不完全属于$n$个等差数列中，要排除。\n 于是我们可以想到对于求$f(A \\sim B)$这一范围，可以转化为求$f(B)-f(A-1)$这两范围的差。\n如图所示：\n\r求和表范围2\r\n则可以只用考虑下界的不符合。\n 这是一个很重要的方法：\n将两个不确定的界的函数($f(x \\sim y)$)，转化为两个有一个确定的界的函数之差（$f(C \\sim x)-f(C \\sim y)$）。（如定积分中经常运用）\n 解题方法 $O(n)$方法 对于每一列$i$：\n其和（的绝对值）为：$i$个$1,2,3,\\cdots,n$的等差数列的和，加上剩余非等差数列的部分。\n每一列均为$n - 0 + 1$即$n + 1$项。\n等差数列部分：\n首项——$a_1 = 0$；\n末项——$a_n = (n + 1) / i - 1$；【原因是：首先项数有$n+1$项（包括0行），整除$i$，则得到等差数列的项数，那么末项$a_n = a_1 + (n-1)*d$，即为项数$-1$。 项数——$n = (a_n - a_1) / 1 + 1$（公差为1），即为$a_n + 1$。\n非等差数列部分：\n每一项均为$a_n + 1$；\n前面已经计算了$cnt * i$项，所以剩余部分的项数为$n + 1 - (cnt * i)$。\n$O(\\sqrt{n})$方法 首先根据上述的规律可以发现：\n 每一个数重复次数是按列递增的。  第$1$列是$1,2,3,\\cdots,n$，每个数出现$1$次；第$2$列是$1,1,2,2,3,3,\\cdots,n,n$，每个数出现$2$次。\n  奇数行和偶数行的符号是一样的。  基于以上两点，我们发现： 如果存在间隔的几列（使符号相同，能合并处理），满足他们有的数字为一样的（比如都只有$1,2,3$，只是出现次数不同）。\n 如求$f(33)$中\n 例一：\n第$9$列为$0,0,\\cdots,0;-1,-1,\\cdots,-1;-2,-2,\\cdots,-2;-3,-3,-3,-3,-3,-3,-3$（$9$个$0$，$9$个$-1$，$9$个$-2$，$7$个$-3$）\n第$11$列为$0,0,\\cdots,0;-1,-1,\\cdots,-1;-2,-2,\\cdots,-2;-3$（$11$个$0$，$11$个$-1$，$11$个$-2$，$1$个$-3$）\n为下图中蓝色两列。\n  例二： 第$12$列为$0,0,\\cdots,0;1,1,\\cdots,1;2,2,\\cdots,2$（$12$个$0$，$12$个$1$，$10$个$2$）\n第$14$列为$0,0,\\cdots,0;1,1,\\cdots,1;2,2,2,2,2,2$（$14$个$0$，$14$个$1$，$6$个$2$）\n第$16$列为$0,0,\\cdots,0;1,1,\\cdots,1;2,2$（$16$个$0$，$16$个$1$，$2$个$2$） 为下图中橙色三列。\n \r举例求和表\r\n 那么这几列的等差数列，是可以合并为一个更大的等差数列一起求和的。\n 上例一中：\n第$9$列中的有$9$个$-1$、$9$个$-2$；\n第$11$列中的有$11$个$-1$、$11$个$-2$；\n于是这两列便可合并为$20$个$-1$，$20$个$-2$一起用高斯求和（等差数列求和）。 但对于最后的一项数（如上例一中的$-3$），因为出现次数不一致，不能很好的直接合并，需要单独处理计算，\n所以我们只能合并倒数第二项用高斯求和，然后对剩下的最后一项单独处理。\n 这样就可以在计算的过程中合并几列同时计算，达到减少操作降低复杂度的效果。\n【不过至于是否为O($\\sqrt{n})$的复杂度我就没证了_(:з」∠)_……\n 那么重点就是：\n  怎么分奇偶，找到哪几列出现数字相同。\n 先算出这一列能出现的最大数，然后再用$n$除以这个数，得到只能出现到这个数的最大列。\n 比如求$f(33)$，处理第$9$列时，\n第$9$列能出现最大的数是$33/9$为$3$，但只能出现到$3$的最大列为$33/3$为第$11$列（可以配合上面给出的图来理解）。\n    怎么处理计算不能合并的最后一项。\n 首先最后一项这个数我们知道是好多（为$n/i$），所以关键是求他有多少个。\n由第一点发现可知，对于下一个间隔列，前面的项出现次数均多了$2$次，\n或者说最后一项出现次数依次减$2$。\n所以其实对于最后一项的出现次数，也是个等差数列。\n找到等差数列的几个参数求和，得到有多少个。\n 首项：对应最后一列$i$，总项数为$n+1$个，前面项每个数均出现了$i$次，一共有$N$个数（计算方法就是等差数列求项数）。 末项：对应第一列，计算方法同首项。 项数：就是合并了几项。   比如求$f(33)$，处理第$12$列时，最大列到$16$列\n 首项——第$16$列中：前面的项（$0$和$1$）均出现了$16$次，所以这一列最后一项（$2$）出现次数为$2$次。 末项——第$12$列中：前面的项均出现了$12$次，所以这一列最后一项出现次数为$10$次。 项数——合并了$12$、$14$、$16$列，项数为$3$. 则可求得最后一项$2$一共出现了$(2+10)*3/2=18$次。      怎么处理计算合并后的等差数列。\n 方法就同$O(n)$方法中求等差数列了， 只是在最后一项（an）和乘的次数（由乘i变成了乘cnt）变了一点。 对于合并后的出现次数，也是个高斯求和。\n 比如求$f(33)$，处理第$9$列时，最大列到$11$列\n第$9$列每一项出现次数为$9$次，\n第$11$列每一项出现次数为$11$次，\n所以一共出现$9+11 = 20$次，\n    个人代码 #include \u0026lt;bits/stdc++.h\u0026gt;#define ALL(NAME_i, BEGIN, TO) \\ int NAME_i = BEGIN; \\ NAME_i \u0026lt;= TO; \\ NAME_i++ #define SGN (nega ? -1 : 1) typedef long long LL; using namespace std; LL solve(int n) { LL ans = 0; bool nega = 1; for (ALL(i, 1, n)) { LL a1 = 0,\t//首项 \tan = (n + 1) / i - 1,\t//末项 \tcntSeq = an + 1;\t//项数 \tans += i * ((a1 + an) * cntSeq / 2) * SGN;\t//先求等差数列的和 \tans += (n + 1 - (cntSeq * i)) * (an + 1) * SGN; //再计算剩下的部分 \tnega = !nega;\t//变符号 \t} return ans; } LL solve_Odev(const int \u0026amp;n, bool odd) { LL ans = 0; int maxColumn; bool nega = odd ? 1 : 0; for (int i = odd ? 1 : 2; i \u0026lt;= n; i = maxColumn + 2) //注意赋值语句为maxColumn + 2，也就是合并处理完几列后，直接跳到处理完的列后面。 \t{ //1. 怎么分奇偶，找到哪几列出现数字相同。 \tLL maxNum = n / i;\t//当前列能出现的最大数（或最后一项） \tmaxColumn = n / maxNum;\t//只能出现到这个数的最大列 \tif (odd \u0026amp;\u0026amp; !(maxColumn \u0026amp; 1)) //本来处理奇数列，但算出来最大列为偶数情况 \tmaxColumn--; if (!odd \u0026amp;\u0026amp; (maxColumn \u0026amp; 1)) //本来处理偶数列，但算出来最大列为奇数情况 \tmaxColumn--; /*对应于上图中，当n = 33, i = 12时： maxNum = 2 maxColumn = 16\t【对应为 合并12~16列。 */ //2. 怎么处理计算不能合并的最后一项。 \tint minCnt = (n + 1) - maxColumn * maxNum,\t//首项——这几列中，最后一项出现最少的次数（为最后一列，用maxColumn） \tmaxCnt = (n + 1) - i * maxNum,\t//末项——这几列中，最后一项出现最多的次数（最当前列，用i） \tcntColumn = ((maxColumn - i) \u0026gt;\u0026gt; 1) + 1; //项数——合并了几列 \t/* 注意的点： 1. 总项数为n+1个，因为0也算！ 2. 不为maxNum - 1，因为0也算！【前面项的项数为((maxNum-1) - 0) / 1 + 1，即maxNum */ int cntNum = ((maxCnt + minCnt) * cntColumn) \u0026gt;\u0026gt; 1; //求得关键——最后一项有多少个（高斯求和） \tans += maxNum * cntNum * SGN; /* 对应于上图中，当n = 33, i = 12, maxColumn = 16时： minCnt = 2\t【对应为 最后一列有2项 maxCnt = 10\t【对应为 第一列有10项 cntColumn = 3\t【对应为 合并了3列 cntNum = 18\t【对应为 最后一项由18个 */ //3. 怎么处理计算合并后的等差数列。 \tLL a1 = 0,\t//首项 \tan = maxNum - 1, //末项 \tcntSeq = an + 1; //项数 \t/* 以上跟O(n)方法的几乎一样。 区别在于当这一列完全为等差数列时（不存在不为等差数列的部分）： O(n)方法计算等差数列和，会包括最后一项； O(sqrt(n))方法计算等差数列和，不会包括最后一项。 */ int cnt = ((i + maxColumn) * cntColumn) \u0026gt;\u0026gt; 1; //合并后出现次数（高斯求和） \tans += cnt * (((a1 + an) * cntSeq) \u0026gt;\u0026gt; 1) * SGN; //（高斯求和） \t} return ans; } LL solve_block(const int \u0026amp;n) { LL ans = 0; ans += solve_Odev(n, 0) + solve_Odev(n, 1); return ans; } /* LL slove_original(int A, int B) //最原始的做法，但考虑的会更复杂所以未完成为错误的 //错误点为为考虑开始部分为非等差数列 { LL ans = 0; bool nega = 1; for (ALL(i, 1, B)) { int seqBgeinIndex = A + max(i - A, 0), cnt = (B - seqBgeinIndex + 1) / i, seqEndIndex = seqBgeinIndex + cnt * i - 1; LL a1 = max(A / i, 1), an = a1 + cnt - 1; ans += i * ((a1 + an) * cnt / 2) * SGN; ans += (B - seqEndIndex) * (an + 1) * SGN; nega = !nega; } return ans; } */ int main() { int A, B; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;A, \u0026amp;B); //printf(\u0026#34;%lld\\n\u0026#34;, solve(B) - solve(A - 1)); \tprintf(\u0026#34;%lld\u0026#34;, solve_block(B) - solve_block(A - 1)); } ","date":"2021-01-25T00:00:00Z","image":"https://blog.supersassw.com/p/prac-2020-1-25/Yande-199983_hu24344327ed1750f50cc0e0aab802591d_7554577_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/prac-2020-1-25/","title":"日常练习——2021/1/25……"},{"content":"数组课后练习题 判断题 第一、二、十八题（重要） 第一题\r 在对全部数组元素赋初值时，不可以不指定一维数组的长度。 \r\r知识点：\n 一位数组赋初值 【书 P121】  \r\r个人做错了这道题！\n\r\r答案与分析\r 错误 \r\r也就是说可以不指定数组长度……\n分析 如果提供了全部初始值数组，也可以不指定长度，编译提供会自动帮你指定。\n如：\nint a[] = {3,1,2,5,6,-2}; //编译系统会帮你指定为a[6] \r\r第二题\r 在对全部二维数组元素赋初值时，可以不指定二维数组的行数。 \r\r知识点：\n 二位数组赋初值 【书 P125】  \r\r个人做错了这道题！\n\r\r答案与分析\r 正确 \r\r分析 同一维数组， 如果提供了全部初始值数组，也可以不指定第一维长度，编译提供会自动帮你计算出长度并指定。\n但注意！\n不能省略第二维的长度。\n\r\r正确例子：\nint a[][3] = {1,2,3, 4,5,6, 7}; //编译系统会帮你指定为a[3][3] \n\r\r错误例子：\nint a[3][] = {1,2,3, 4,5,6, 7}; //编译系统无法确定长度 \n\r\r\r\r\r练习——第十八题\r 在给全部数组元素赋初值时，可以不指定二维数组中的常量表达式，例如int a[][] = {1,2,3,4,5,6}。 \r\r 作为之前二维数组的练习题。 \r\r个人做错了这道题！\n\r\r答案\r 错误 \r\r\r\r\r 第十题  定义一个一维字符数组有$50$个元素，用该一维字符数组表示一个字符串数组最多允许有$50$个字符 \r 知识点：\n 字符数组的容量 【书 P128】  \r 答案与分析\r 错误 \r\r分析 字符数组char []，容量比定义的长度要少一个。\n因为字符数组还要存一个末尾的/0，\n所以题上定义了$50$个元素（char a[50]），但实际上只能存$49$个字符。\n同理：如果一个字符串长度是$n$，\n则它占用的空间是$n+1$个。\n例子见考前总结中最后的第7点。\n\r\r\r  第十一、十三题 第十一题\r C++中各种数据类型的变量在定义后会被自动初始化为0。 \r\r知识点：\n 一维数组的初始值 【书 P121】  \r\r答案与分析\r 错误 \r\r分析 一般方式定义的数据类型，如int a，double b[10]，都是不会被赋初值的。\n 这也就是为什么我们不赋初值就使用它会报错的原因，因为里面有以前的脏数据 \r\r但如果加上static这个修饰词，定义为静态变量，就会被赋初值为0了。\n如：\nstatic int a; //a = 0 static int b[5]; //b1~b5 = 0 \r\r第十三题\r 静态（static）数组被定义时，数组的所有元素自动获取初始值0。 \r\r知识点：\n 静态一维数组 【书 P121】  \r\r答案与分析\r 正确 \r\r分析 同十一题，静态数组，里面所有元素自动赋初值为0。\n\r\r\r 第十七题  在C++中数组是具有一定顺序关系的若干相同类型变量的集合体。 \r 知识点：\n 数组的概念 【书 P120】  \r 答案与分析\r 正确 \r\r分析 纯概念题，记住！\n\r  第二十题（重要） 程序段：\nchar s1[10]; s1 = \u0026#34;program\u0026#34;; 是合法的使用。\n\r 个人做错了这道题！\n为一道很容易错的操作题。\n\r 知识点：\n 一维字符数组的定义 【书 P127】  \r 答案与分析\r 错误 \r\r分析 请仔细阅读书上P127中「1.一维字符数组的定义」！\n里面有很多没有讲到的点，但很容易错。\n\r 由第二十题衍生的练习题  作为第二十题相关的练习题。 \r 这些都是根据书上P127中「1.一维字符数组的定义」里面的内容所出题。\n故没有写分析，请仔细阅读书上事例来自行分析。\n第二十一题\r程序段：\nchar s1[10] = {\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;}; cout \u0026lt;\u0026lt; s1; 是合法的使用。\n\r\r个人做错了这道题！\n与二十二题很容易混淆！\n\r\r答案\r 正确 \r\r\r\r第二十二题\r程序段：\nchar sa[] = {\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;}; cout \u0026lt;\u0026lt; sa; 是合法的使用。\n\r\r个人做错了这道题！\n与二十一题很容易混淆！\n\r\r答案\r 错误 \r\r仔细看看与二十一题的区别在什么地方，\n很小的区别就造成了答案的不一样。\n\r\r第五十四题\r有如下的字符串数组定义语句：\nchar str1[] = {\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;}; char str2[] = {\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;\\0\u0026#39;}; char str3[] = \u0026#34;program\u0026#34;; 下列说法正确的是（）。\n A、str1中的数据可以作为一个整体（字符串）参加运算。\nB、str2和str3中的数据只能作为一个整体（字符串）参加运算。\nC、str2和str3中的数据既可以以元素为单位参加运算，也可以作为一个整体（字符串）参加运算。\nD、str1、str2和str3中的数据既可以以元素为单位参加运算，也可以作为一个整体（字符串）参加运算。\n所谓作为一个整体，即是如以下操作：\nstr1 = \u0026#34;abcd\u0026#34;; cout \u0026lt;\u0026lt; str1; 而以元素参加运算，即是如以下操作：\nstr1[2] = \u0026#34;a\u0026#34;; cout \u0026lt;\u0026lt; str1[3]; 如果只能以元素操作，则不能cout \u0026lt;\u0026lt; str1这样作为整体操作。\n\r\r\r\r个人做错了这道题！\n\r\r知识点：\n 二维数组的使用方法 【书 P125】  \r\r答案\r C、str2和str3中的数据既可以以元素为单位参加运算，也可以作为一个整体（字符串）参加运算。 \r\r\r\r\r选择题 第三十、三十一题 第三十题\r在下面的一维数组定义中，（）有语法错误。\n A. int a[] = {1,2,3};\nB. int a[];\nC. int a[] = {0};\nD. int a[5];\n\r\r知识点：\n 一维数组的初始化 【书 P121】  \r\r个人做错了这道题！\n为一道很容易错的操作题。\n\r\r答案与分析\r B. int a[]; \r\r分析  A、对于确定初始值的数组，可以不指定长度，是正确的。（见上面第一题） B、这种定义方式是不存在的，要么赋初值，要么指定长度。 C、很容易错选的选项，这种方式其实就代表定义个长度为1的数组，然后a[0]=0。是正确的。 D、基本的定义方式，是正确的。  注意还有一种定义类型int a[...] = {0}，代表定义个...长度的数组，其中全部赋初值为0。\n\r\r第三十一题\r在下面的二维数组定义中，（）有语法错误。\n A. int x[10][10];\nB. int x[][10] = {{1,3} ,5 ,7};\nC. int x[][];\nD. int x[10][10] = {0};\n\r\r知识点：\n 二维数组的初始化 【书 P125】  \r\r答案与分析\r C. int x[][]; \r\r分析   A、基本的二维数组定义方式，没赋初值，是正确的。\n  B、这里有赋初值，所以可以不用指定行数，是正确的。\n 最终数组状态为：\nx[0][0] = 1; x[0][1] = 3; x[1][0] = 5; x[2][0] = 7;    C、错因跟上一样。\n  D、这里就是第三十题说得，定义一个确定长度的二维数组，然后全部赋初值为0，是正确的。\n  \r\r\r第三十五题 定义一个一维数组，正确的语句是（）。\n A. int a(10);\nB. int n = 10; int a[n]\nC. int n; cin\u0026gt;\u0026gt;n; int a[n]\nD. const int n = 10; int a[n]\n\r 知识点：\n 一维数组的定义 【书 P120】  \r 答案与分析\r D. const int n = 10; int a[n] \r\r分析 首先A选项，不知道他在干嘛，直接排除。\n对于B、C、D选项，涉及到一维数组的定义这个知识点。\nB和C中的n均是变量，故错误。\nD中的n为常量（const），故正确。\n书上原话  在定义数组时，数组的大小必须是常量，而不能是变量或者变量表达式。 \r\r\r  第三十六题 以下哪种说法错误？（）。\n A. 数组中的元素在某些方面彼此相关。\nB. 数组中的所有元素具有相同的下标。\nC. 数组中的所有元素具有相同的数据类型。\nD. 数组中的所有元素具有相同的名字。\n\r 答案与分析\r B. 数组中的所有元素具有相同的下标。 \r\r分析 纯概念题，记住！\nB是错的很容易看出来，\n主要是A、C、D是对的要记住。\n\r  第五十二题 若有定义语句int a[3][6]，\n按在内存中的存放顺序，a数组的第$10$个元素是（）。\n 我出成了填空题！……\n请想出正确答案！……\n\r 知识点：\n 二维数组的使用方法 【书 P125】  \r 答案与分析\r a[1][3] \r\r分析 二维数组的存放方式，也是按着顺序存放的。\n并且先是按行顺序存放，一行存完了再换下一列。\n也就是按照a[0][0],a[0][1],a[0][2]\u0026hellip;a[0][5],a[1][0],a[1][1],\u0026hellip;,a[2][5]的顺序存放，\n所以第$10$个，就是$10 = 2 * 3 + 4$，也就是第$2$行第$4$列，为a[1][3]。\n\r  第五十九题 以下关于二维数组的说法中，错误的是（）。\n A. 若在定义二维数组的同时给其赋初值，则二维数组的列数可以省略。\nB. 二维数组的每一行相当于一个一维数组，因此二维数组可以看成是由一维数组构成的数组。\nC. 给二位数组赋值时，可以将所有元素写在一个{}内。\nD. 引用二维数组时，必须包含数组名、行下标和列下标。\n\r 知识点：\n 二维数组的各种概念 【书 P125】  \r 答案与分析\r A. 若在定义二维数组的同时给其赋初值，则二维数组的列数可以省略。 \r\r分析 纯概念题，记住！\n\r 未写入的题  第十二题——数组[]里能放的东西，只有常量和常量表达式 第十四题——数组不是C++基本数据类型 第十六题——数组再内存中是连续存在的（包括二维数组） 第十九题 （个人做错） ——字符串处理函数（strcpy、strcmp等）的头文件（\u0026lt;string.h或cstring或\u0026lt;iostream\u0026gt;），是不含string类的（头文件为\u0026lt;string\u0026gt;）。 第三十四题：  字符数组（char []）只能用字符串函数来处理（strcpy、strcmp）\n字符串（string）只能用运算符号（+、==）来处理。\n两者有各自对应的运算方式。\n   ","date":"2021-01-09T00:00:00Z","image":"https://blog.supersassw.com/p/prac-array/Yande-314214_hua49f15ef087bdbbd47ec4ec6c539acdb_2635208_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/prac-array/","title":"习题——数组……"},{"content":"指针课后习题 判断题 第一题  从内存单元中存取数据的方法有直接访问方式和间接访问方式。 \r 知识点：\n 内存单元的数据存取方式 【书 P186】  \r 答案与分析\r 正确 \r\r分析  直接访问方式：通过变量名存取变量内容。  如a = 2、cout \u0026lt;\u0026lt; a。\n  间接访问方式：通过 地址（即指针） 操作。  如*a = 5、cout \u0026lt;\u0026lt; *a。\n   \r  第二题  能够直接赋值给指针变量的整数是$0$和$1$。 \r 知识点：\n 指针赋值 【书 P187】  \r 答案与分析\r 错误 \r\r分析 整数中，只有$0$才可以赋值指针，代表空地址（NULL）。\n书上原话 “地址”，可以是变量的地址、数组名、函数名等，也可以是数值$0$（或NULL）。\n没有任何对象会被分配到地址0（或NULL），因此数值$0$（或NULL）是可以直接赋给指针变量的唯一整数。\n\r\r\r  第四题  “变量的指针”含义是指该变量的地址。 \r 个人做错了这道题！\n为一道很新颖的概念题。\n\r 答案与分析\r 正确 \r\r分析 纯概念题，记住！\n\r  第九题 在操作一个一维数组时，可能会用到两个指针变量指向该数组，\n这两个指针变量之间可以进行关系运算，其关系运算的结果表明了这两个指针变量所指向的数组元素的先后关系。\n\r 个人做错了这道题！\n为一道很新颖的概念题。\n【个人甚至都不知道这种方法……\n\r 知识点：\n 指向一维数组的指针的关系运算 【书 P190】  \r 答案与分析\r 正确 \r\r分析 当有两个指针指向同一个数组时，\n可以对这两个指针进行比较（\u0026lt;、\u0026gt;），以反应这两个指针的位置关系。\n例子\r假设：\n存在数组int a[10]，\n存在两个指针int *p1,*p2。\n这两个指针均指向数组a中某个位置（如p1=\u0026amp;a[4]，p2=\u0026amp;a[8]）\n 若p1 \u0026lt; p2，则代表p1所指向的数组元素，在p2所指向的数组元素前面。 若p1 = p2，则代表p1、p2指向数组中同一个元素。 若p1 \u0026gt; p2，则代表p1所指向的数组元素，在p2所指向的数组元素后面。  具体可以看书上，有图示来解释。\n\r\r\r  第十题 对于已经定义好的相同类型的两个指针变量，可以进行加法运算、减法运算和赋值运算。\n\r 个人做错了这道题！\n为一道很新颖的概念题。\n【个人甚至都不知道这种方法……\n\r 知识点：\n 指针间的运算 【书上没找到对应知识点】  \r 答案与分析\r 错误 \r\r分析 指针间存在三种运算。\n 假设两指针int *a,*b。\n 赋值运算（a = b）\n代表最基本的赋值。 关系运算（a \u0026lt; b）\n代表a和b位置关系。【一般用于数组中，代表谁指向前面谁指向后面】 减法运算（a - b） 代表a到b之间的距离。【一般用于数组中，如a = \u0026amp;arr[5]，b =\u0026amp; arr[7]，则a-b为$2$】   上述题错在：没有加法运算。\n\r  第十九题 使用动态储存分配时，用运算符new获取的内存空间，不必须用delete进行释放。\n\r 个人做错了这道题！\n为一道很新颖的概念题。\n\r 知识点：\n 动态存储分配 【书 P201】  \r 答案与分析\r 错误 \r\r分析 纯概念题，记住！\n书上原话 用new获取的内存空间，必须用delete运算进行释放，并且对同一个内存空间只能执行一次delete。\n\r\r【虽然个人感觉确实不用的，因为程序结束会自动帮你释放xd……\n 注意只能delete一次 \r\r\r  第二十二题 设int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12}, (*p)[5];，\n则使用p = a语句是不合法的。\n\r 个人做错了这道题！\n\r 知识点：\n 数组指针变量 【书 P196】  \r 答案与分析\r 错误 \r\r分析  个人暂时也不知道原因，正在询问老师【…… \r\r感觉是题目错了……\n\r  选择题 第三十三、三十四、三十七、三十八题 因为这几道题考点相同，故放在一起形成对照。【区别仅在++的位置】\n第三十三题\r设有如下程序段，输出的值为（）\nint x = 8, *p = \u0026amp;x; cout \u0026lt;\u0026lt; *p++ \u0026lt;\u0026lt; endl;  A. $8$\nB. $9$\nC. $8$的地址\nD. $9$的地址\n\r\r答案与分析\r A. 8 \r\r分析 这里面先是运算*p，得到值$8$，\n然后就变成了cout \u0026lt;\u0026lt; 8++ \u0026lt;\u0026lt; endl;，这个时候就是先返回结果再运算。\n也就是先输出$8$，然后再*p = *p + 1变成$9$。\n\r\r第三十四题\r设有如下程序段，输出的值为（）\nint x = 8, *p = \u0026amp;x; cout \u0026lt;\u0026lt; ++*p \u0026lt;\u0026lt; endl;  A. $8$\nB. $9$\nC. $8$的地址\nD. $9$的地址\n\r\r答案与分析\r B. 9 \r\r分析 注意这里面还是先运算*p，得到值$8$，\n然后就变成了cout \u0026lt;\u0026lt; ++8 \u0026lt;\u0026lt; endl;，这个时候就变成了先运算再返回结果。\n也就是先*p = *p + 1变成$9$，然后再输出$9$。\n总之前两道题，都是先运算*p。\n\r\r第三十七题\r设有定义语句：\nint a[10]={0,1,2,3,4,5,6,7,8,9},*p = a; 则数值不为$3$的表达式为（）。\n A. a[3]\nB. p[3]\nC. p += 2, *(p++)\nD. p += 2, *(++p)\n\r\r个人做错了这道题！\n为一道很容易错的操作题。\n\r\r答案与分析\r D. p += 2, *(++p) \r\r分析 首先A、B选项，直接能看出a[3]和p[3]均为数组第四个元素，即为$3$。\n所以讨论C、D选项。\n注意这里的指针，变成了指向数组的指针。\n所以是可以进行加法操作的，代表指向位置的移动。\n刚开始均有一个p += 2，也就是指向了第三项a[2]为$2$。\n然后这里打了括号，所以肯定先是运算括号里的东西。\n那么p++和++p的区别，也就在于是先返回值还是先加一。\n 对于++p，先运算，也就指向了a[3]，再返回值。那么还是$3$。 对于p++，先返回值，也就是a[2]，那么a[2]的值就为$2$了。  故选择C。\n\r\r练习——第三十八题\r设int x[] = {1,2,3,4,5,6}, *p = x;\n则数值为$3$的表达式是（）。\n A. p += 2, *++p\nB. p += 2, *p++\nC. p += 3, *p\nD. p += 2, ++*p\n\r\r 作为之前三道题的汇总练习题。 \r\r答案与分析\r B. p += 2, *p++ \r\r分析 没打括号的时候，*p最先运算。\nA中，*与p被++隔开了，所以只能先运算++p。\n 如果换成p += 2, *(p++)，也是正确答案。\n不过其运算过程与B完全不一样，运算后的结果更不一样！ \r\r\r\r\r 第三十九、四十、四十九、五十题 因为这几道题考点相同，故放在一起形成对照。\n第三十九题\r设有定义语句：int a[5], *p = a;，\n则下列描述错误的是（）。\n A. 表达式p = p + 1是合法的\nB. 表达式a = a + 1是合法的\nC. 表达式p - a是合法的\nD. 表达式a + 1是合法的\n\r\r答案与分析\r B. 表达式a = a + 1是合法的 \r\r分析 需要注意到：数组名其实也是一个指针，代表这个数组的起始位置，相当于\u0026amp;a[0]。\n但其是常量指针，故不可以执行赋值语句。\n也就是a + 1是对的，代表\u0026amp;a[0] + 1，\na = a + 1是错的，没法把\u0026amp;a[0] + 1赋值给\u0026amp;a[0]。\n\r\r第四十题\r有下面语句int a[10] = {10,9,8,7,6,5,4,3,2,1}, *p = a，\n则数值为$2$的表达式是（）。\n A. a[9]\nB. *p[8]\nC. *(a+8)\nD. p+8\n\r\r个人做错了这道题！\n【虽然是我没认真看题错的_(:з」∠)_……\n\r\r答案与分析\r C. *(a+8) \r\r分析  A、a[9]，代表的是数组第十个元素，也就是$1$。 B、p[8]的时候，已经代表的是第九个元素的值了，所以不能再加*。\n也就是说如果选项是p[8]就是对的，*p[8]存在语法错误。 C、*(a+8)，也就相当于a[8]，故为$2$，正确。 D、p+8，代表的是第九个元素的地址，不是里面的值。\n也就是说如果选项是*(p+8)就是对的。  \r\r第四十九题\r若有定义int a[10], *p = a;，\n对数组元素错误的使用的语句是（）。\n A. *(a+1)\nB. *(p++)\nC. p[1]\nD. *(a++)\n\r\r答案与分析\r D. *(a++) \r\r分析 跟前两道题一样，关键是多了++这个自增运算符。\n对于B，p是个指针变量，是可以执行自增（或说赋值）的语句的。 而对于D，p是个指针常量，是不能执行自增（或说赋值）的语句的。\n\r\r练习——第五十题\r若有定义int a[] = {0,1,2,3,4,5,6,7,8,9}, *p = a, i;，\n对数组元素正确的使用的语句是（）。\n A. a[p]\nB. p[a]\nC. p+12\nD. a[p-a]\n\r\r 作为之前三道题的汇总练习题。 \r\r答案与分析\r D. a[p-a] \r\r分析 注意[]里面，只能为具体的数值\n也就是说A、a[p]和B、p[a]均错误，\n因为[]里是地址，而不是数值。\n A改为a[*p]，则正确，代表a[0]，\nB改为p[*a]，则正确，代表p[0]（即a[0]）。\n 但如果数组元素换位int a[]={-1,0,1,2,3,4,5,6,7,8}，\n那么即便改为a[*p]也不正确，因为其代表a[-1]，对数组元素使用错误。\n\r\rC是很明显的数组越界。\nD中，前面的题（第十题）介绍过，指针间存在减法运算。\n那么这道题中p-a的运算结果为$0$（因为指向同一位置a[0]，之间不存在距离），\n然后a[0]是正确使用。\n\r\r\r 第四十三题 设char str[] = \u0026quot;hello\u0026quot;, *p = str;，\n则*(p+5)的值是（）。\n A. 随机值\nB. 字母o\nC. 字符串结束标志\\0\nD. 字母o内存的地址\n\r 答案与分析\r C. 字符串结束标志\\0 \r\r分析 *(p+5)，也就是从字符串开头往后数$5$位。\n会发现，最后只能往后数$4$位到o，\n别忘了在字符数组char []中，最末尾还会有一个看不见的\\0这个东西，\n所以存在*(p+5)，代表的就是\\0。\n\r  第四十六题 设有定义语句int *p[4];，\n则标识符p是（）。\n A. 一个指向整型变量的指针变量\nB. 一个指向整型的指针数组名\nC. 一个指针，它指向一个含有四个整型元素的一维数组\nD. 一个非法的定义语句\n\r 个人做错了这道题！\n【虽然是我没认真看题错的_(:з」∠)_……\n\r 答案与分析\r B. 一个指向整型的指针数组名 \r\r分析 就注意一下这种定义方式，\n其类型就是一个指向整型的指针数组名。\n\r  第五十一题 若有定义：int a[] = {1,2,3,4,5,6,7,8,9,10}, *p = a;，\n则数值为$7$的表达式为（）。\n A. *(p+7)\nB. p[*(a+6)]\nC. p+6\nD. a[*(p+5)]\n\r 个人做错了这道题！\n\r 答案与分析\r D. a[*(p+5)] \r\r分析 首先很容易判断出A，其数值为$8$，\nC，其没有加*，故代表的是a[6]的地址。只有加了*，即*(p+6)才数值为$7$。\n而B、D，关键要先把[]内部的给运算出来，\nD中，*(p+5)的值为$6$,而a[6]的值为$7$，\n所以D的最终值为$7$，符合题意。\n\r  第五十四题 若有定义：int a[3][4]，\n能正确表示数组a中元素地址的是（）。\n A. *(a[1]+4)\nB. *(*(a+3)+1)\nC. *(a[1]+2)*\nD. *(*(a+1)+1)\n\r 个人做错了这道题！\n为一道很混淆的操作题。\n\r 答案与分析\r D. *(*(a+1)+1) \r\r分析  个人暂时也不知道原因，正在询问老师【…… \r\r觉得C好像也是对的……\n\r  没写入的题  以下题均为比较新的概念题，但个人没有写入，还是推荐去看一下记一下。 \r  第六题——常量是否能赋给指针 第七题——数组名代表数组首地址 第四十五题——int *point = new int(4)，这段代码的执行顺序  ","date":"2021-01-08T00:00:00Z","image":"https://blog.supersassw.com/p/prac-point/Yande-308381_hubfc4b78b5f13c939fbd8620a241a68e1_9631758_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/prac-point/","title":"习题——指针……"},{"content":"以下为个人对教材中每章课后练习所出现的名字解释题进行的总结。\n教材为：心理学导论（第三版）——人民教育出版社 （黄希庭 郑涌 著）\n 由于老师跳过了第二章，并且教学进度被缩短的原因，对第二章以及第五章后部分名字解释未整理。 \r  带“心理学大辞典”的定义表示该定义是从「心理学大辞典」中查阅得来。 \r  斜体表示该名词未在课后练习中出现，但个人总结出来了，仅供参考。 \r 第一章 绪论 第一节 心理学的性质  心理学：心理学是一门研究心理现象的事实、机制、规律、和本性的实证科学。  一、个体心理现象概览 从个体心理的动态—稳态维度区分：\n 心理倾向：心理活动在特定时间里的指向状态。 心理过程：心理活动在一定时间内发生、发展的过程。  认知过程：个体获取知识和运用知识的心智活动。（人以感知、记忆、思维等形式反映客观事物的性质和联系的过程——心理学大辞典） 情绪过程：产生心理现象的历程。（人对客观事物的某种态度的体验——心理学大辞典） 意志过程：力图达到有目的、有计划地改造世界的心理过程。（人有意识地克服各种困难以达到一定目的的过程——心理学大辞典）   心理特征：一个人心里活动中经常表现出来的稳定特点。  三、心理学的科学性  可复制性：一项科学研究的结果是能够按照原创者所提供的研究方法精确加以重复验证的。 可证伪性：在表述一个科学理论时，必须遵循从该理论所推导出各种预测有可能被证伪。 系统性：心理学的科学知识是通过系统的实证研究而获得的。  第二节 心理学的方法 一、心理学研究的基本原则  可公开检验原则：科学发展是可以由任何人重验、批评、否定或继续发展的。 主客观资料科学整合原则：对人的心理研究中必须考虑把所有收集到的客观资料与主观资料科学地整合起来。 人文关怀原则：心理学研究者在科学研究中应遵守心理学家的职业道德。 操作性定义：以可观察、可测量的操作给一个概念下定义。  二、心理学研究的基本变量  刺激变量（S）：能够引起机体反应的刺激特征。 机体变量（O）：个体自身特征。 反应变量（R）：刺激引起在行为上发生变化的反应种类和特征。  三、心理学研究的基本方法  实验法：在控制的条件下系统地操纵某种变量的变化，来研究该变量的变化对其他变量产生的影响。（心理学大辞典 P1131）  自变量：研究者选定并在试验中操纵、掌握，以影响被试行为的因素。 因变量：被试的反应，即研究者想要预测的行为。 控制变量：除了自变量会对因变量影响之外，所有其他因素都应保持恒定或加以控制。 无关变量：与实验目的无关的变量。 实验组：专门接受实验处理的一组被试。（心理学大辞典 P1135） 控制组\u0026lt;对照组\u0026gt;：不受实验处理的被试组。（心理学大辞典 P700）   准实验法：在实验研究的设计上或情景控制上不具备实验法的一个或两个基本条件的研究方法。 问卷法：用问卷提问题的方式，要求被调查者就某个或某些问题问答自己的想法。  相关系数：用来度量两个或几个变量之间相互联系的性质和程度的指标。   演绎法：从理论或假设出发得出结论来验证其对心理现象或行为变化的预测和解释力的论证方法。 质性研究法：对特定的心理现象、行为、团体互动进行深入系统的观察、资料收集、分析理解，从而对所研究的心理现象或行为特征及其发展脉络提供具体、系统的描述。  归纳法：由繁到简、由特殊情形推论出普遍规则的过程。    第三节 心理学的历史  构造主义 机能主义 行为主义 格式塔心理学 精神分析 人本主义心理学  第四节 当代心理学的特点  生物学取向：着重从生物、生理、遗传基因的角度研究心理与行为。 行为取向：着重研究个体的行为是怎样受到环境和经验影响的。 认知取向：主张用信息加工观点来研究人类心理过程和结构。 社会文化取向：着重研究社会文化怎样影响个体的心理与行为。 心理动力学取向：着重研究个体心理与行为的动力因素。   第三章 心里的生物基础 第一节 神经系统与神经元  神经系统：由巨量神经细胞形成的神经组织与结构的总称。  一、中枢神经系统的结构和机能  中枢神经系统：是人体神经系统的主要部分，包括脑和脊髓\n功能：传递、储存和加工信息，产生各种心理活动，支配与控制人的全部行为。  二、周围神经系统的结构和机能  周围神经系统：从中枢神经系统发出，导向人体各部分，可分为躯体神经系统和自主神经系统\n功能：与身体各部分的联络工作，起传入和传出信息的作用。  三、神经元的结构和机能  神经元：是神经系统结构和功能的基本单位。 全或无定律：当刺激强度未达到某一阈值限时，神经冲动不会发生；而当刺激强度达到该值时，神经冲动发生并能瞬时达到最大强度，此后刺激强度即使再继续加强或减弱，已诱发的冲动强度也不再发生变化。 突触：相邻神经元其间的空隙。（神经元之间或神经元与效应器细胞之间传递信息的结构——心理学大辞典 P1264）  第三节 脑机制的研究方法 三、脑电图及事件相关电位  脑电图：在头皮表面记录到的自发节律性电活动。 事件相关电位：通过平均叠加技术从头颅表面记录大脑诱发电位，来反映大脑高级心理活动过程中大脑的神经电生理改变。  五、脑成像技术  功能性磁共振成像：功能更强的磁共振成像（磁共振成像：运用磁场原理来产生体内活动的图像），甚至可以使大脑的活动可视化。  专栏3-2\n 裂脑：切断大脑两半球之间的连结以研究人与动物的一种技术。（心理学大辞典 P758）  第四节 内分泌系统  内分泌系统：机体内对行为起重要调节作用的一个系统，由全身不同部位的多种内分泌腺体和组织细胞组成。 激素：内分泌腺所分泌的物质。  第五节 遗传对行为的影响  遗传：亲子之间以及子代个体之间性状存在的相似性，表明性状可以从亲代传递给子代。 基因型：个体的整个遗传禀赋。 表现型：在特定的环境中具有一定基因型的个体遗传得以实现的程度。 选择性繁殖：对动物特性遗传的一种研究方法。 双生子研究：一种研究方法，用于探讨遗传和环境因素对个体心理和行为发展的影响或作用。（心理学大辞典 P1175）   第四章 心理的环境基础 第一节 环境的内容 一、什么是环境  环境：与有机体发生联系的外部世界。 自然环境：环绕人们周围的各种自然因素的总和。 社会环境：人类生存及活动范围内的社会物质、精神条件的总和。 物理环境：除包括自然环境诸因素外，还包括人为的物理环境因素。 心理环境：人与人，人与物相互作用时所形成的环境。 情景：指一定场合下能被个体感知到的那一部分环境。  三、心理学家关于环境的理论  地理环境：显示的环境。 行为环境：个人意想中的环境。 生态系统理论：心理学发展环境理论，认为环境是由微系统、中系统、外系统、大系统四个由近及远的子系统组成的一个有层次序列的系统。（心理学大辞典 P1112）  第二节 自然环境 一、空气质量  空气污染综合征：受到长期的空气污染导致的症状，出现头疼、疲劳、失眠、消沉等症状。  二、噪声  噪声：一种非周期性的、无组织的、不定型的听觉刺激。  三、社会密度与拥挤  社会密度：一个给定的空间里所拥有的人数。 拥挤：一种感到空间不够大的主观感受。  第三节 社会环境 一、文化传统  文化：有广义、狭义之分。  狭义的文化：观念形态的文化，仅限于意识形态。 广义的文化：人类社会的全部遗产，囊括社会生活的全部领域。   亚文化：在社会的某一群体中形成一种既包括民族的一些主文化特征，也包括某些独特的文化特征的生活方式的这种群体文化。  第四节 社会影响  社会影响：运用个人或团体的社会力量在特定的方向上改变他人的观念和行为的过程。  一、从众与服从  从众：个人的观念和行为由于群体直接或隐含的引导或压力而与多数人保持一致的倾向。 服从：个体在他人的直接命令下而做出某种行为的倾向。  专栏4-3\n 角色\u0026lt;社会角色\u0026gt;：期望与个人的、训练个人的并鼓励他在一定社会情况中去完成某种权利、义务和责任的任何行为模式。   第五章 毕生心理发展  毕生发展：人类个体从受精卵开始，逐渐发育、成熟直至死亡，整个生命全程的与年龄有关的那些变化过程。  第一节 心理发展的基本观点 一、遗传与环境的交互作用  反应的交互作用：面对环境刺激，不同遗传基因的个体会以不同的方式来对其做出反应。 唤起的交互作用：个体的行为特征会招致人们对其的不同反应。 超前的交互作用：个体主动选择和创造他们所喜欢的环境，这些环境反过来又进一步作用于个体。  二、发展的连续性与变化性  发展的连续性：个体特征不因年龄增长而发生改变。 转折点：个体在发展过程中在几种途径中做出选择，从而导致个体生活环境的根本性变化。  三、发展中的个别差异  年龄特征：人类生理心理发展在各年龄阶段中大多数个体所表现出来的共同特征。 个别差异：受遗传基因与环境的不同影响，不同个体之间在身心特征上各不相同的现象。  四、心理发展的研究设计  横断研究：在同一时间内或较短时间内对某一个年龄或某几个年龄层次的个体或个体群组的发展水平进行观测与研究，并加以比较的一种研究设计。 纵向研究：对某一特定个体或某一组特定的个体随着其年龄的增长在其发展的不同阶段系统地进行反复观测，从而取得连续性的发展资料。  第二节 孕期与婴儿期 二、婴儿期的发展  依恋：婴儿依附于养育者的一种社会情绪性联系。  第三节 幼儿期与儿童期 一、认知发展  图式：个体灌注经验的心理模具。 同化：个体用现有的图式去理解事物。 顺应：使图式适应新经历的特殊性。 感觉运动阶段：0~2岁，指婴儿只能通过“这里”与“现在”来理解这个世界，只有那些能感觉和接触到的东西才是真实的。 前运算阶段：2~7岁，这一阶段儿童依靠的更多是感觉而不是逻辑。同时还表现为，总是从自己的观点看世界，不能从别人的观点直觉事务，称为自我中心主义。 具体运算阶段：7~11岁，儿童能依据具体事例进行推理思考，不会只依据表面现象，而是更有逻辑地进行思考，有了守恒的观念。 形式运算阶段：11岁以上，儿童能运用抽象的、符合形式逻辑的推理方式去思考问题。  ","date":"2021-01-08T00:00:00Z","image":"https://blog.supersassw.com/p/intro-psychology-ne/67450790_p0_hu64a059195139e470f4d36bc000798f35_624654_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/intro-psychology-ne/","title":"心理学导论——名词解释……"},{"content":"文章目录  发现锚点在个人简介(About)页面不生效，待修正…… \r 在左侧侧边栏增加了显示文章目录（Table Of Content）的功能……\n测试 这是h3…… 这是另一个h3…… h4以下默认是不会显示的qwqqq…… 很短的内容……\n没了！……\n另外的h3【1】…… 另外的h3【2】…… 另外的h3【3】…… 另外的h3【4】…… 另外的h3【5】…… 这里分隔一下……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n另外的h3【6】…… 另外的h3【7】…… 另外的h3【8】…… 另外的很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长h3【⑨】…… 长内容！……\n长内容！……\n长内容！……\n长内容！……\n长内容！……\n长内容！……\n超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级长内容！……\n长内容！……\n长内容！……\n长内容！……\n长内容！……\n长内容！……\n长内容！……\n测试h2……  参考文章或主题  hugo主题——Eureka  js借鉴于这个主题，然后个人加以修改实现的……\n  js实现滚动条自动滚动（scrollTop）  主要是依此了解了scrollTop的用法……\n  如何用js自己实现Animate运动函数  有关滚动动画的实现js来源处（极其感谢wuwuwu……\n   ","date":"2021-01-07T00:00:00Z","image":"https://blog.supersassw.com/p/test-toc/66488487_p0_hu927bcdeee8a2673c7ad35386c9152871_481055_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/test-toc/","title":"Table Of Content测试……"},{"content":"扩展Shortcode  以下Shortcode均来自Hugo的Hugo Book主题…… \r 一、columns 分栏显示内容……\n使用方法 {{\u0026lt; columns \u0026gt;}} Content_1 (With Markdown) \u0026lt;---\u0026gt; Content_2 {{\u0026lt; /columns \u0026gt;}} 使用例 左侧栏 OI的发生，到底需要如何做到，不OI的发生，又会如何产生。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 塞涅卡在不经意间这样说过，真正的人生，只有在经过艰难卓绝的斗争之后才能实现。这启发了我， OI因何而发生?我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 既然如此， 了解清楚OI到底是一种怎么样的存在，是解决一切问题的关键。 既然如何， 现在，解决OI的问题，是非常非常重要的。 所以， 问题的关键究竟为何? 经过上述讨论就我个人来说，OI对我的意义，不能不说非常重大。 所谓OI，关键是OI需要如何写。 一般来讲，我们都必须务必慎重的考虑考虑。 OI的发生，到底需要如何做到，不OI的发生，又会如何产生。 既然如何， 那么， 既然如何， 我们不得不面对一个非常尴尬的事实，那就是， 歌德曾经说过，没有人事先了解自己到底有多大的力量，直到他试过以后才知道。我希望诸位也能好好地体会这句话。中间栏 俾斯麦曾经说过，对于不屈不挠的人来说，没有失败这回事。带着这句话，我们还要更加慎重的审视这个问题： 要想清楚，OI，到底是一种怎么样的存在。 每个人都不得不面对这些问题。 在面对这种问题时， 培根曾经说过，要知道对好事的称颂过于夸大，也会招来人们的反感轻蔑和嫉妒。我希望诸位也能好好地体会这句话。 生活中，若OI出现了，我们就不得不考虑它出现了的事实。 就我个人来说，OI对我的意义，不能不说非常重大。 既然如何， 塞涅卡在不经意间这样说过，生命如同寓言，其价值不在与长短，而在与内容。我希望诸位也能好好地体会这句话。右侧栏 所谓OI，关键是OI需要如何写。 所谓OI，关键是OI需要如何写。 那么， 既然如何， OI，到底应该如何实现。 带着这些问题，我们来审视一下OI。 我们不得不面对一个非常尴尬的事实，那就是， 所谓OI，关键是OI需要如何写。偷偷摸摸栏？…… 测试……  中间的文本尽量不要太长，不然会占用很大竖直空间…… \r 二、details 内容折叠栏……\n使用的为HTML的details标签……\n使用方法 {{\u0026lt; details \u0026#34;Title\u0026#34; [open] \u0026gt;}} content {{\u0026lt; /details \u0026gt;}}  open为可选项，加入open代表默认打开……  另一种方法：\n{{\u0026lt; details title=\u0026#34;Title\u0026#34; open=true \u0026gt;}} content {{\u0026lt; /details \u0026gt;}} \n\r 使用例 源码 {{\u0026lt; details \u0026#34;折叠内容……\u0026#34; \u0026gt;}} 这里面是折叠内容…… {{\u0026lt; /details \u0026gt;}} 效果 折叠内容……\r这里面是折叠内容……\r\r 嵌套测试 不要点开看！……\r不要看！…… 都说了不要点开啦qwqqq快关上！！……\n都说了不要点开啦qwqqq快关上！！……\n都说了不要点开啦qwqqq快关上！！……\n都说了不要点开啦qwqqq快关上！！……\n都说了不要点开啦qwqqq快关上！！……\n真的不要看啦【【…… 再这么看人家超害羞的(*/ω＼*)……\n 诶诶还不关上嘛！……\n真拿你没办法，那就给你看看我多年的代码实力吧！【x……\n#inculde(iosteam) using namespace qwq; int mian() { int a,b; cin\u0026lt;\u0026lt;a+b; cout\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; }  诶诶不喜欢嘛？……\n那那来看看世界第一可爱的童田明治吧！……\n\r\r\rがぶがぶ……\r11歳の、5歳です！……\r\r\r\r\r  内嵌的时候请不要使用\u0026gt; {{\u0026lt; details \u0026gt;}}（引用加上details），否则会造成错误与样式混乱，暂时还未修复…… \r  样式更改参考自借助HTML5 details,summary无JS实现各种交互效果…… \r 三、tabs 分标签显示……\n使用方法 {{\u0026lt; tabs \u0026#34;uniqueID\u0026#34; \u0026gt;}} {{\u0026lt; tabs/tab \u0026#34;1\u0026#34; \u0026gt;}} Content_1 {{\u0026lt; /tabs/tab \u0026gt;}} {{\u0026lt; tabs/tab \u0026#34;2\u0026#34; \u0026gt;}} Content_2 {{\u0026lt; /tabs/tab \u0026gt;}} {{\u0026lt; tabs/tab \u0026#34;3\u0026#34; \u0026gt;}} Content_3 {{\u0026lt; /tabs/tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} uniqueID为一个独一无二的ID……\n使用例 源码 {{\u0026lt; tabs \u0026#34;1\u0026#34; \u0026gt;}}{{\u0026lt; tabs/tab \u0026#34;第一标签页\u0026#34; \u0026gt;}}## 天才麻将少女 打麻将真开心啊…… {{\u0026lt; /tabs/tab \u0026gt;}}{{\u0026lt; tabs/tab \u0026#34;第二标签页\u0026#34; \u0026gt;}}## 兽娘动物园 是会每天没事干不务正业的Friends呢【指自己…… {{\u0026lt; /tabs/tab \u0026gt;}}{{\u0026lt; tabs/tab \u0026#34;第三标签页\u0026#34; \u0026gt;}}## 魔法少女小圆 身体好轻，怀着这么幸福的感觉战斗还是第一次，已经没什么好怕的了，因为我不再是孤单一人了！…… {{\u0026lt; /tabs/tab \u0026gt;}}{{\u0026lt; /tabs \u0026gt;}}效果 第一标签页\r天才麻将少女 打麻将真开心啊……第二标签页\r兽娘动物园 是会每天没事干不务正业的Friends呢【指自己……第三标签页\r魔法少女小圆 身体好轻，怀着这么幸福的感觉战斗还是第一次，已经没什么好怕的了，因为我不再是孤单一人了！……\r ","date":"2021-01-07T00:00:00Z","image":"https://blog.supersassw.com/p/test-shortcode-extend/Yande-312231_hub297abc0e6f09948596897695fbb9840_1998731_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/test-shortcode-extend/","title":"移植Shortcode测试……"},{"content":"定积分  $\\int_0^{\\frac{\\pi}{2}} f(\\sin x)\\mathrm{d}x = \\int_0^{\\frac{\\pi}{2}} f(\\cos x) \\mathrm{d}x$ $\\int_0^\\pi xf(\\sin x)\\mathrm{d}x = \\frac{\\pi}{2}\\int_0^\\pi f(\\sin x) \\mathrm{d}x$  e.g.\n$\\int_0^\\pi \\frac{x\\sin x}{1+cos^2x} \\mathrm{d}x = \\frac{\\pi}{2}\\int_0^\\pi \\frac{\\sin x}{2-sin^2x} \\mathrm{d}x$\n  Walls公式：\n$I_n=\\int_0^\\frac{\\pi}{2}\\sin^nx\\mathrm{d}x\\=\\begin{cases}\\frac{n-1}{n}\\cdot\\frac{n-3}{n-2}\\cdot\\ \\cdots\\ \\cdot \\frac{3}{4}\\cdot\\frac{1}{2}\\cdot\\frac{\\pi}{2}\\quad (\\text{n is even}) \\\\frac{n-1}{n}\\cdot\\frac{n-3}{n-2}\\cdot\\ \\cdots\\ \\cdot \\frac{4}{5}\\cdot\\frac{2}{3}\\quad (\\text{n is odd, n\u0026gt;1})\\end{cases}$  LaTex显示好像有误，待修复 \r  ","date":"2021-01-04T00:00:00Z","image":"https://blog.supersassw.com/p/am-formula/76524292_p0_hu496f4562aacbed9d40936841282eb41a_2147862_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/am-formula/","title":"考前公式速记……"},{"content":"数组 一、什么是数组 1、与数学的联系——数列 关于数组，你可以就把他当作数学上的“数列”，用来存一系列的数。\n数学上的一个数列$a_i$：\n当$i=1$时，代表的是这个数列的第一个数$a_1$，当$i=3$时，代表的是这个数列的第三个数$a_3$……\n同时，这个数列可以叫数列$a_i$，也可以叫$b_i、{nico}_i$……\n可以用$i$来表示第几项（$a_i$），也可以用$j$来表示第几项（$a_j$）……\n\r 2、与数学的不同  数学上的数列是从第一项开始的，也就是$a_1$代表的就是$a$这个数列的第一项。\n然而编程里的数组，却是从第零项开始的，也就是a[1]代表的是a这个数组里第二项，a[0]才是第一项。 数学上的数列，我们不需要提前告诉这个数列中会有多少项。\n然而编程里的数组，我们需要提前告诉他这个数组里会有多少项，也就是int a[100]的100的意思，代表可能会存100项。  3、编程中的数组 那么类比到我们编程里：\n 这个$a_i$的$a$，就是程序里的这个数组的名字，专业名称叫“变量名”。 这个$a_i$的$i$，就是程序里的这个数组的第几项，专业名称叫“下标”。  比如arr[5]代表的就是arr这个数组里的第6项。\n二、数组的声明 申明部分，也就是定义。如：\nint arr[100];  int——代表的是这个数组的类型：即这个数组存的是一系列int类型的数。\narr——代表的是这个数组的变量名，之后用这个数组就是arr[2]、arr[i]之类的形式。\n[100]——代表的是这个数组的大小，也就是可能会存多少项。\n 对于数组大小的声明，必须为常量或者常量表达式。\n正确的例子：\nint a[10];\t//字面常量（常数） int b[5 * 5];\t//字面常量的表达式  const int len = 10; int c[len];\t//符号常量 int d[len * 2];\t//符号常量的表达式 \n\r\r错误的例子：\nint len = 10; int a[len];\t//len为变量，错误 int a[len + 5];\t//len+5为变量相关的表达式，错误 \n\r\r\r 三、数组的运用 1、对一个数组某个具体元素的运用   最简单的运用，我们直接把一个常数100存到arr数组里的第三项里：\na[2] = 100;   要把一个变量val存到arr数组里的第一项里：\na[0] = val;   要输出数组arr中的第二项：\ncout \u0026lt;\u0026lt; a[1];   2、对一个数组多个元素的运用 很多时候我们不止运用其中的某一个具体的数。\n比如我们要向这个数组读入10个数，然后输出这10个数，这就涉及了多个元素的操作。\n我们再类比数列，假如我们要对数列$a_i$的第一项到第十项求和：\n用的是不是$\\sum_{i=1}^{10}a_i$这个公式，\n用个$i$来代表第几项，然后$i=1\\sim10$，把$a_i$累加起来。\n类比到编程，同样用个i来代表第几项，然后i=0~9，把arr[i]累加起来存到sum里。\n 仍要注意到第一项是从0开始，所以是0~9！ \r\n  对数组前十项求和  for (i=0; i\u0026lt;=9; i++) sum = sum + arr[i];  其中这里的涉及到从头到尾加起来的操作，\n我们把对一个数组从头到尾进行某些操作叫做“遍历”。\n以后会提到的概念注意一下。\n\r 那么类推一下，要向数组里读入$10$个数\n 读入十个数到数组前十项  for (i=0; i\u0026lt;=9; i++) cin \u0026gt;\u0026gt; arr[i];  然后再输出\n 输出数组中前十项  for (i=0; i\u0026lt;=9; i++) cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  总代码：\nint i, arr[100], sum = 0; cout \u0026lt;\u0026lt; \u0026#34;请输入十个数：\u0026#34;; for (i = 0; i \u0026lt;= 9; i++) cin \u0026gt;\u0026gt; arr[i]; for (i = 0; i \u0026lt;= 9; i++) sum = sum + arr[i]; cout \u0026lt;\u0026lt; \u0026#34;你刚才输入的十个数为：\u0026#34; \u0026lt;\u0026lt; endl; for (i = 0; i \u0026lt;= 9; i++) cout \u0026lt;\u0026lt; \u0026#34;arr[\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;] = \u0026#34; \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;总和为：\u0026#34; \u0026lt;\u0026lt; sum; 效果为： \r上述代码效果\r\n 如果为先输入一个数n，然后读入n个数，只需要改下循环条件即可。\n 读入n个数到数组  int n; cin \u0026gt;\u0026gt; n; for (i = 0; i \u0026lt;= n-1; i++)\t//注意读n个数是(i=0;i\u0026lt;=n-1)，就像之前读10个数是(i=0;i\u0026lt;=9) //也可以写成 for (int i = 0; i \u0026lt; n; i++)，不过最好选择一种格式以后就这样写，不然可能会晕 \tcin \u0026gt;\u0026gt; arr[i];  其余输出什么的同理。\n3、对多个数组的运用 很多时候我们可能要从a数组拿出一些数放到b数组里，这个时候下标可能就会很疑惑。\n比如我们可能会把arr数组里十个数放到b数组对应位置里。\n这个时候数学表示就是$b_i=arr_i(i=1\\sim10)$\n  把arr数组十个数放到b数组里  for (i=0; i\u0026lt;=9; i++) b[i] = arr[i];  但不一定每次都是刚好把arr的第i项放到b的第i项，也可能是比如：\n从arr的第五项开始，取5项（即a[4] ~ a[8]，放到b的第十项后面（即(b[9] ~ b[13])。\n要记住数组的下标不只是用i来表示，也可以用其他变量来表示。\n因此我们可以定义两个变量j和k，来分别表示两个数组arr和b的下标。\n刚开始令j = 4，k = 9\n开始取第一项放进b时，也就是b[9] = arr[4]，这个时候就是b[k] = arr[j]。\n然后取第二项放进b时，也就是b[10] = arr[5]，\n因此我们就可以在放完一项后，让k = k + 1和j = j + 1，\n这个时候的b[k] = arr[j]，是不是就代表b[10] = arr[5]了。\n 从arr的第五项开始，取5项，放到b的第十项后面。  j = 4, k = 9;\t//分别代表arr数组和b数组的下标 for (i=1; i\u0026lt;=5; i++)\t//做5次循环，代表取5项 { b[k] = arr[j]; k++; j++; }  这里是比较难但很重要的点，如果分析也看不懂，可以手动模拟一下：\n自己按照程序一行一行执行，在本子上画两行表格，一行代表arr数组，一行代表b数组；j=4时就用个箭头指向arr[4]，j++则移动箭头指向arr[5]……\n如果理解了，那数组差不多也都理解了。\n四、例题讲解 选择“实验8”的第1题。\n1、题目要求 \r实验8第一题\r\n2、数组的定义分析 因为要输入的是实数（小数），所以要用double或float类型。\n然后有15个数，但注意到要把计算后的平均值存到a数组最后的a[15]里，即实际上为16个数，长度为16。\n 故定义数组：\ndouble a[16];  3、数组刚开始的原样读入、原样输出和求平均值 如果认真看了之前的“数组的运用”，这里应该问题不大。\n多的点就是要每行五个输出，并且域宽为10。\n 代码：\ndouble sum = 0;\t//求和变量注意清零  //读入部分 for (i = 0; i \u0026lt;= 14; i++)\t//i=0~14，读入十五个数 { cin \u0026gt;\u0026gt; a[i];\t//读入a[i] \tsum = sum + a[i];\t//顺便对a[i]的所有项求和，方便后面求平均值 } //求平均值部分 a[15] = sum / 15;\t//求的总和除以个数，也就算的是平均值，放到题上要求的a[15]里  //输出部分 for (i = 0; i \u0026lt;= 14; i++) { if ((i+1) % 5 == 0) cout \u0026lt;\u0026lt; endl; //这里用如果(i+1)%5==0则换行，也就是i=5,10,15,...的时候换行，达成了每五个换行的效果 \t//这个可以记下来，如果是每7个换行，就写 if (i%7 == 0) cout\u0026lt;\u0026lt;endl; \tcout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; a[i];\t//输出a[i]，setw为设置域宽 }  4、调整a数组，以满足题目条件形式输出 因为我们要调整a数组里的数，最终输出a数组。\n所以可以先把a数组里的所有数存到b数组里，然后再“遍历”b数组，判断某一个数b[i]跟平均值的关系，如果大于则放到a数组前面，小于则放到后面。\n首先先来写怎么把a数组里的所有数存到b数组里，前面已经写过了这里直接写代码。\n 代码：\nfor (i = 0; i \u0026lt;= 14; i++)\t//把a数组放到b数组里 { b[i] = a[i]; }  接下来就是难点了，判断出关系后，怎么样才能把b[i]放到a数组前面或者后面。\n之前说过的，下标不一定只能用i，也可以定义新变量来表示下标。\n 于是我们可以定义两个变量begin和end，分别代表a数组前面和后面的下标。\n刚开始begin = 0, end = 14，分别代表最开始的前面的下标和后面的下标。\n\rway_1\r\n【注意a[15]为平均值】\n  然后遍历b数组，假如第一个数b[i]（$i=1$）为$3$，小于平均值a[15]则该放到后面，也就是a[end]。\n先让a[end]=b[i]，\n\rway_2\r\n  然后再让end = end - 1，\n\rway_3\r\n  这样，当再次找到下个小于平均值的数时，则会放到当前的最后面处；\n找到下个大于平均值的数时，则会放到当前的最前面处。\n如图： \rway_4\r\n   代码：  cout \u0026lt;\u0026lt; \u0026#34;调整后的数据为:\u0026#34; \u0026lt;\u0026lt; endl; for (i = 0; i \u0026lt;= 14; i++)\t//把a数组放到b数组里 \t{ b[i] = a[i]; } int begin = 0, end = 14; for (i = 0; i \u0026lt;= 14; i++)\t//遍历b数组，跟平均数比较，放回a数组 \t{ if (b[i] \u0026lt; a[15])\t//跟平均数比较 \t{ a[end] = b[i]; end--; } else { a[begin] = b[i]; begin++; } } for (i = 0; i \u0026lt;= 14; i++)\t//输出a数组  { if (i % 5 == 0) cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; a[i]; }  5、总代码 #include \u0026lt;iomanip\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; int main() { int i; double a[16], b[16]; double sum = 0.0; cout \u0026lt;\u0026lt; \u0026#34;请输入15个实型数：\u0026#34; \u0026lt;\u0026lt; endl; for (i = 0; i \u0026lt; 15; i++) //读入 \t{ cin \u0026gt;\u0026gt; a[i]; sum = sum + a[i]; } a[15] = sum / 15;\t//求平均值 \tfor (i = 0; i \u0026lt; 15; i++) //原样输出 \t{ if (i % 5 == 0 \u0026amp;\u0026amp; i != 0) //【这里加了个i!=0的条件，防止最开始就换行 \t{ cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; a[i]; } cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;调整后的数据为:\u0026#34; \u0026lt;\u0026lt; endl; for (i = 0; i \u0026lt; 15; i++) //把a数组放到b数组里 \t{ b[i] = a[i]; } int begin = 0, end = 14; for (i = 0; i \u0026lt; 15; i++) //遍历b数组，跟平均数比较，放回a数组 \t{ if (b[i] \u0026lt; a[15]) { a[end] = b[i]; end--; } else { a[begin] = b[i]; begin++; } } for (i = 0; i \u0026lt; 16; i++) //输出a数组【注意这里是遍历输出整个a数组，即a[15]这个存的平均值也要输出，所以变成了(i = 0; i \u0026lt;16; i++) \t{ if (i % 5 == 0 \u0026amp;\u0026amp; i != 0) cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; a[i]; } }  这里只讲的老师的第一种方法，更好理解一些。对于第二种方法可以自行尝试，跟这个大致相同，不懂也可以自己在草稿纸上模拟一下。  五、其他提示   数组的范围可以开大，但不能开小。\n意思就是尽管最多可能只有10个整数，你可以定义为int a[100]，但不可以int a[9]。\n推荐是比最多个数开稍微大一点，这样又可以偷懒想要开几个，又可以防止越界错误【本来只定义了15个，你访问了a[20]】。\n  因为编程里数组第一项是从a[0]开始的，比较反人类x……\n所以如果想按照数学习惯，完全可以从a[1]开始存数。\n 比如读入15个数，原来可能写成\nfor (i = 0; i \u0026lt;= 14; i++) cin \u0026gt;\u0026gt; a[i]; 这样就是存在a[0]~a[14]里。\n你也可以写成符合我们习惯的\nfor (i = 1; i \u0026lt;= 15; i++) cin \u0026gt;\u0026gt; a[i]; 这样就是存在a[1]~a[15]里。\n 不过选择好一种自己喜欢的就这么写，不要一会从$0\\sim14$一会又$1\\sim15$，不然会很混乱。\n  没了。\n  有关排序的算法可能是常考点，各位可以自己去背一下。\n  以上。\n","date":"2020-12-26T00:00:00Z","image":"https://blog.supersassw.com/p/cpp-array/72693520_p0_hu5438825b9b6d1014226d20d231e650c2_940838_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/cpp-array/","title":"数组……"},{"content":"一、注意的点 1、用作为“累加、累乘”的变量的注意事项 例子——累加、累乘的变量\r sum1 = sum1 + a;——作为累加求和。 sum2 = sum2 * a;——作为累乘求和。  \r   是否定义时赋初值？\n int sum1 = 0;——累加变量赋初值为0。 int sum2 = 1;——累乘变量赋初值为1。    在循环里反复使用，要注意可能要将累加变量清零，累乘变量赋一。\n例题\r题目：\n统计3组数据的和，其中每组数据会有n个数。\n\r\r部分代码：\nint sum = 0;\t//赋初值为0  for (int i = 1; i \u0026lt;= 3; i++)\t//循环3组数据 { cout \u0026lt;\u0026lt; \u0026#34;请输入第\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;组数据有多少个数：\u0026#34;; cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; \u0026#34;请输入n个数：\u0026#34;; for (int j = 1; j \u0026lt;= n; j++)\t//读入并统计这组数据里n个数的和  { cin \u0026gt;\u0026gt; a; sum = sum + a; } cout \u0026lt;\u0026lt; \u0026#34;这组数据和为：\u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; sum = 0;\t//关键语句：这里即要注意每读完一组数据要清零！否则会带着上次计算的结果算下一组 } 输出：\n 加了sum = 0;这句清零语句：\n 未加sum = 0;这句清零语句：\n  \r   2、有关函数的讲解和注意事项 函数的三个要点：\n 我要给他什么东西？（给几个东西、这些东西是什么类型） 我想要这个函数干嘛、完成什么事？ 他要给我返回个什么东西？（只能返回一个值，否则不叫函数）  \r 一般要求写函数，都是基于这三点分析：\n 根据1和3两点来确定怎么声明函数。 根据2这点来确定怎么实现函数。  例题一\r题目：要求写一个函数，用来返回两个整数的最大值。\n\r\r分析与实现\r分析如下：\n 我应该给这个函数两个int类型的数据。 这个函数应该找到这两个数谁最大。 这个函数应该返回给我这两个数的最大值，也是int类型的数据。   故声明部分为：\nint max(int, int); 实现部分为：\nint max(int num1, int num2) { if (num1 \u0026gt; num2) return num1; else return num2; } 使用部分为：\nint main() { int max(int, int); cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; \u0026#34;两个数的最大值为：\u0026#34; \u0026lt;\u0026lt; max(a,b); } \r\r例题二\r题目：要求写一个函数，用来确认某个数是否在某个数组a[10]里（为double类型数组）。\n\r\r分析与实现\r分析如下：\n 我应该给这个函数一个我要找的数，这个数为double类型；还要给我要找的数组，这个为数组的double*指针类型。 这个函数判断这个数是否存在于a这个数组。 这个函数应该返回给我这个数是否存在于a数组，是个bool类型的数据。   故声明部分为：\nbool if_inside(double, double*); 实现部分为：\nbool if_inside(double num, double* arr) { for (int i = 0; i \u0026lt;= 9; i++) { if (arr[i] == num)\t//如果与数组中某个数相等，代表找到，返回true  return true; } return false;\t//遍历完数组都没找到，代表真的没有，返回false } 使用部分为：\nint main() { bool if_inside(double, double*); cin \u0026gt;\u0026gt; n; if ( if_inside(n) )\t//判断n是否在a数组内  cout \u0026lt;\u0026lt; \u0026#34;n这个数在a数组内\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;n这个数不在a数组内\u0026#34;; } \r\r\r函数的注意事项   如果把函数实现写在int main()之前，便不用在main里声明函数了。【见书P86 第二个黑色方框】\n  函数一旦return后，便不会再执行之后的语句。\n  不同函数（包括main这个“主函数”）里面的变量不能互相调用。\n 即假如main()里有个int a，则不能在子函数fx()中用a = 1这样。\n如果main()里有个int a，子函数fx()里也有个int a：则main里只能用main里的a，fx里只能用fx里的a。\n 这个其实就是局部变量的原因，函数里的变量为局部变量，只能在这个函数里用。\n  \r 二、需要记住的模板 1、生成随机数   必须写上的代码（提供随机种子）\n直接写在int main()后面的第一句话就好。\nint main() { srand(time(NULL)); ... }   使用方法\n 要取得$(a,b)$的随机整数，使用( rand() % (b-a+1) ) + a + 1; 要取得$[a,b)$的随机整数，使用( rand() % (b-a) ) + a; 要取得$[a,b]$的随机整数，使用( rand() % (b-a+1) ) + a; 要取得$(a,b]$的随机整数，使用( rand() % (b-a) ) + a + 1;  例子——随机生成1到100内的整数（含1和100）\r代码：\nint num = rand() % (100 - 1 + 1) + 1; 或者直接写成：\nint num = rand() % 100 + 1; \r   记忆方法：\n想象$rand()$是能返回完全任意的数。\n当你对这个任意的数$\\mod 100$（对100取余数）后，那么余数范围只能是$0\\sim99$。\n再加个$1$，范围变成了$1 \\sim 100$。\n\r 2、最大公约数（GCD）和最小公倍数（LCM）的计算  这个比较重要，也很难背。 \r 直接背代码。\n老师给的版本 最大公约数（GCD）\rint GCD(int a, int b) //求a和b的最大公约数 { int c, r; if (a \u0026gt; b) //保证a是两数中较小的数  { c = a; a = b; b = c; } r = b % a; while (r != 0)\t//这个过程背住orz……  { b = a; a = r; r = b % a; } return a;\t//最后的a值为求得的结果 } 最小公倍数（LCM）\rint LCM(int a, int b)\t//求a和b的最小公倍数 { return (a * b) / GCD(a, b); } \r这里用函数的形式来写，以后求解可可以直接用这个函数。如：\ncin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;和\u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt;\u0026#34;的最大公约数为：\u0026#34; \u0026lt;\u0026lt; GCD(n,m) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;和\u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt;\u0026#34;的最小公约数为：\u0026#34; \u0026lt;\u0026lt; LCM(n,m); 不用函数的话，就把那里面的东西直接写到main()里就行。\n更好记的版本  利用递归思想求最大公约数，可以极大简化代码。 \r 可以尝试理解下这个代码，能很好的锻炼递归思想。\nint GCD(int a, int b) { return b ? GCD(b, b % a) : a;\t//意思是如果b不为0，则a=b,b=b%a辗转相除；否则就返回a }  或者采用这个递推的思想，极其好记！\nint GCD(int a, int b) { while (b ^= a ^= b ^= a %= b); return a; } 【但原理就不要求掌握了，其中的^=是位运算……\n3、判断某数是否为质数 直接背代码。\n 代码里有几个要注意的点。 \r bool if_Prime(int num) { if (num == 1) return false; //！特别注意！：当num=1的时候很可能之后会判断失误，故需要“打补丁”：当num=1的时候直接返回false  bool flag = true;\t//刚开始假设是素数  for (int i = 2; i \u0026lt;= num-1; i++)\t//！注意！：这里是(2~num-1)，而不是(2~num)，很容易在这里写错  if (num % i == 0) //找到能被(2~num-1)之中的数除尽，证明不是素数，设置flag并退出循环  { flag = false; break; } return flag;\t//如果循环完都没有被除尽，证明是素数，会返回true；否则会返回flase } 这里用函数的形式来写，以后判断就可以直接用这个函数。如：\ncin \u0026gt;\u0026gt; n; if ( if_Prime(n) ) cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;是素数\u0026#34;; else cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;不是素数\u0026#34;; 4、对数组的排序 就两种排序方法：\n 冒泡排序 选择排序  两种方法仅存在写法上的区别，建议自己选择一种自己背得到的记住。\n而且写法的差别并不大，仅是for循环范围的区别。\n 很可能会考到写法【个人感觉【…… \r 【模板见老师的PPT，如果没记的话可以问我……\n5、二分查找（折半查找） 有可能要考，考的话会专门指出“请用二分查找来找出\u0026hellip;”。\n不然的话就可以用“从头到尾遍历数组”来找。\n【模板见老师的PPT，如果没记的话可以问我……\n 使用二分查找，需要先让数组有序，如果是无序的数组先要排序。 \r 三、常用头文件及函数  #include \u0026lt;...\u0026gt;   #include\u0026lt;iostream\u0026gt;\n最基本的库。\ncin、cout等基本指令都需要这个库，写程序直接写上即可。\n记忆方法\r io ————\u0026gt; input\u0026amp;output 输入输出 stream ————\u0026gt; stream n.流  即“输入输出流”。\r\n  #include\u0026lt;ctime\u0026gt;\n使用随机生成时要用到的库。\n即生成种子时用的time()需要这个库。 记忆方法\r c ————\u0026gt; 值c++ time ————\u0026gt; time n.时间  即用来管时间的库。（随机函数需要用时间来作为种子，这样才能保证随机生成不重复）\r\n  #include\u0026lt;iomanip\u0026gt;\n控制输出格式要用到的库。\nsetw(...)、fixed()、precision(...)（基本为这三个）需要用到这个库。 记忆方法\r io ————\u0026gt; input\u0026amp;output manip ————\u0026gt; manipulator n.操控器 的前五个字母  即“输入输出控制器”。\r\n  #include\u0026lt;string\u0026gt;\n使用c++的字符串要用到的库。\n对字符串大致使用不了解的看书P132-134。（会点很基础的输入输出就行，不用太了解）\n  【库这些东西多写了没坏处，可以写之前就把这些库都写上，之后复制粘贴就行xd……\n四、常见非编译问题和错误弹窗解释 1、未赋初值类 弹窗显示如图：\n\r错误类型1\r\n 中文意思：“val”（橙色圈出）这个变量没被初始化（赋初值）就在使用。 出现原因：一般出现在累加变量未赋初值为0，就在用sum=sum+a。 解决方法：找到变量名为引号里的变量，在使用其前赋相应初值。  错例\r红色划线为对val的使用处，橙色划线为val的定义处。\n很明显看到val在使用前未被赋初值。\n故在使用前赋个初值（这里为累加变量，所以赋初值为0），即：val = 0。\n\r 2、数组越界类 弹窗显示如图：\n\r错误类型2\r\n 中文意思：变量“a”周围的栈被破坏。【理解不到没关系看下面_(:з」∠)_…… 出现原因：出现在对数组元素的访问中，访问的下标超过数组最大个数。 解决方法：找到变量名为引号里的数组的声明部分，将其空间开大点。  错例\r橙色划线定义个数组空间为$10$，即只能用a[0]~a[9]。\n但在红色划线里，却用了a[10]，明显超出了最大范围，即越界了，所以会出现此错。\n故在定义部分int a[10]，把它空间开大点变成int a[11]即可。\n\r  这也是数组中很常见的误区和错误需要注意！ \r 3、死循环类 这类错误不会报错，但会感觉程序怪怪的……\n比如：\n 一直黑屏，没有任何反应。\n（如果不确定是不是电脑卡了的原因，可在int main()最开始加一句cout\u0026lt;\u0026lt;\u0026quot;test\u0026quot;来判断：如果输出了test，则证明不是程序卡了。） 明明只想读入几个数，却发现一直在读入。 明明只想输出几个数，却发现一直在输出。  这几类便是说明你的程序陷入了“死循环”。\n 如下程序：\n\r错误3-例\r\n本意是只读入五个数，输出这五个数的和。\n运行时：\n\r错误3-运行界面\r 发现一直在读入。\n  出现原因：  循环变量没有改变。  如忘了i++、i--、i=i+2等。\n  循环条件不可能中止。  如for (i = 1; i \u0026gt;= 0; i++)，$i\\geq 0$会一直成立。\n  循环里不小心改变了循环变量。  如：\nfor (i = 1; i \u0026lt;=10; i++) { ... i = 0; } 每次循环i又会变为0，则会一直循环造成死循环。\n     还可能有其他各种原因，反正问题都出在循环里，仔细检查下自己写的循环部分。\n五、其他杂类   有关i++和++i的区别，不懂看书P45。\n  有关条件运算符... ? ... : ...的用法（不一定会用，但是要看得懂），不懂看书P45。\n  强制类型转换(int)4.8、(double)1是否还记得？不记得看书P50。\n  对const（符号常量）这个东西是否还记得？\n 如const double PI = 3.1415926\n 不记得看书P31。\n  确定是否掌握setw、precision等控制输出格式的用法，不会看书P34-P35。\n  对字符数组char a[100]，了解这是什么即可（c里面的字符串），不必掌握。\n  字符串最后会有个看不见的\\000这个空字符：\n 如字符串\u0026quot;MinatoAqua\u0026quot;\n 长度为$10$。 存储时存放$11$个字符串。     一定注意{}的匹配！ 特别牢记你的这个if或for要管哪几句话，就把哪几句话打上{}\n  强烈建议把程序写的规范一点\n 一句话（用;结尾的）就是一行 {和}单独占一行 {之后的语句空两格（或者按“Tab”这个键） }之后（包含这一行）的语句往前删两个空格（用的“Tab”的删一次就可以） 具体样式就是以上我写的那种样子。  \r 这样不只是好看，更能让你的整体思路保持清晰，不然很容易犯{}不匹配的问题！\n  要知道你每写一句话是在干嘛，这句话我写出来是什么目的。【有点抽象，不过确实很需要知道自己的目的，怎么实现这个目的，等熟练后这个自然也就会很清楚了orz……\n   以上，\n祝武运昌隆！……\n","date":"2020-12-26T00:00:00Z","image":"https://blog.supersassw.com/p/cpp-summary/58541644_p0_hu0c218c74dadec57d38928125b7e7f710_1153603_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/cpp-summary/","title":"考点总结……"},{"content":"Timeline…… 时间线标签的移植测试……\n测试 总历程……\n2020-12-24 19:00提出构想……\n\r这个时间线好好看啊，我也要实现！……\n 这里面还能套娃哦x…… \r\r\r\r2020-12-25这里想要测试下所以这里的标题要非常非常非常的长这样才能测试是否全平台适配……\n\r到了明天【？……\n 感觉实现了……  这里面用Markdown写！……\n然后这里也要非常非常非常非常非常非非常非常非常非常非常非常常非常非常非常非常非常非常的长……\n\r\r2020-12-25 233:33:33\n\rtime其实内容随意（没有检测直接原样输出），填个不是时间的也可以……\n最后一个测试了！……\n 来个公式：  $$[{2{x^T}(t)x(t - \\tau ) = {x^T}(t){Q^{ - \\frac{1}{2}}}x(t - \\tau ) \\le \\frac{1}{\\alpha }{x^T}(t)Px(t) + \\alpha {x^T}(t - \\tau )x(t - \\tau )}]$$ 我也不知道这是啥_(:з」∠)_……\n  来个代码：  freopen(\u0026#34;ans.out\u0026#34;,\u0026#34;r\u0026#34;,stdin); printf(\u0026#34;qwq\u0026#34;);    \r\r2020-12-24 20:28正式实现并适配……\n\r实现了！……\n也不知道会不会出问题，反正能跑就行.jpg……\n改后的样式配上这个主题感觉还是很好看的√……\n不过markdown里看着好乱啊也没办法的'_\u0026gt;'……\n好累orz……\n\r\r 实现方法 又又又又又是Shortcode！……\n换行输入模式……\n{ {\u0026lt; timeline theme=\u0026#34;...\u0026#34; \u0026gt;} } { {\u0026lt; timeline/node time=\u0026#34;...\u0026#34; title=\u0026#34;...\u0026#34;\u0026gt;} } 内容...... { {\u0026lt; /timeline/node \u0026gt;} } { {\u0026lt; timeline/node time=\u0026#34;...\u0026#34; title=\u0026#34;...\u0026#34; url=\u0026#34;...\u0026#34;\u0026gt;} } 内容...... { {\u0026lt; /timeline/node \u0026gt;} } { {\u0026lt; /timeline \u0026gt;} }  外层：\nname（可选项）：为这条时间线的标题……\n 内层：\ntime（必填项）：节点时间……\ntitle（可选项）：节点名称……\nurl（可选项）：节点链接（外部链接要加https://）……\nnew（可选项）：如果填了url，将new设为1可以在新窗口打开标签……\n   想法还是来自于：\n小康博客 —— Hexo博客之butterfly主题优雅魔改系列（持续更新）\n\r 个人在其基础上修改了CSS以适配此主题……\n并以Shortcode的形式完成对Hugo的移植……\n","date":"2020-12-24T00:00:00Z","image":"https://blog.supersassw.com/p/test-timeline/pixiv61107110_huba53cd19c95d0fe8cd12b027cea0c3df_3255125_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/test-timeline/","title":"Timeline测试……"},{"content":" 发现note嵌套中还是会出现格式混乱的问题，待修复…… \r 错误例子\r{{\u0026lt; note info \u0026gt;}} 1. 测试 {{\u0026lt; snote error \u0026#34;这里有问题……\u0026#34; \u0026gt;}} {{\u0026lt; /note \u0026gt;}} \r  Note测试…… 对Hexo中Volantis主题的note移植测试……\n NoteBlock 是 Blockquote 的增强版，在左边显示图标，并且可以自定颜色。\n 长Note 适用于需要换行输入的note……\n 很长很长的note！……\n还可以换行！……\n因为内容是Markdown格式……\n里面干什么都可以_(:з」∠)_……\n这句话是一句很长的话我用来测试他能否在不同移动端上也能正常显示我希望他真的能正常显示不然我又要去改scss了呜呜呜x但是现在这个长度还不够我还要再加长点嗯现在应该够了让我们看看效果吧！……\n为了能使长note内嵌，暂时将goldmark里的unsafe调为了true（能内嵌HTML），日后再改进……\n\r\r\r 使用方法：\n\u0026lt; note guide(theme) blue(color) \u0026gt; (content) \u0026lt; /note \u0026gt;  注意：\n如果要在引用内容（\u0026gt;）中使用，\n则只能在开头写一个\u0026gt;，其内容和结束部分都不要打\u0026gt;……\n\r  短Note 适用于很短的一句话的note……\n  不带颜色的……\n  成功（success）…… \r 使用方法：\n\u0026lt; snote success \u0026#34;...\u0026#34; \u0026gt;    带颜色的……\n  背景是SuperSASS蓝（blue）的链接图示（link）…… \r 使用方法：\n\u0026lt; snote link \u0026#34;...\u0026#34; blue \u0026gt;     图标问题已修复…… \r  测试：  Test——up…… \r  Test——paperclip in yellow…… \r\n 参数 图标  带颜色的：quote, info, warning, done/success, error/danger 不带颜色的：radiation, bug, idea, link, paperclip, todo, message, guide, download, up, undo  颜色  clear, light, gray, red, yellow, green, cyan, blue   想法来自于：\n小康博客 —— Hexo博客之butterfly主题优雅魔改系列（持续更新）\n\r 使用了其CSS后，用基于Hugo的Shortcode实现，并更改部分CSS使得匹配该主题……\n更多note也可以参见该页面……\n同时滚动条样式也参考了这位dalao然后自己改的【感恩……\n","date":"2020-12-23T00:00:00Z","image":"https://blog.supersassw.com/p/test-note/Yande-713907_hu78325a06b1473fc65240ca2cf12d1105_794019_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/test-note/","title":"NoteBlock测试……"},{"content":"测试 啥都没有……\n源码 /* 并查集算法 用father数组记录每个节点的父节点，数据结构类似于树 关键操作：合并、查询 详细介绍: https://zhuanlan.zhihu.com/p/93647900 */ //P3958 奶酪: https://www.luogu.com.cn/problem/P3958 #include \u0026lt;bits/stdc++.h\u0026gt;#define N 1005 using namespace std; inline int quickRead() { int f = 1, num = 0; char t = getchar(); while (t \u0026lt; \u0026#39;0\u0026#39; || t \u0026gt; \u0026#39;9\u0026#39;) f = t == \u0026#39;-\u0026#39; ? -1 : 1, t = getchar(); while (t \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; t \u0026lt;= \u0026#39;9\u0026#39;) num = num * 10 + t - \u0026#39;0\u0026#39;, t = getchar(); return f * num; } struct typeUnionFind { int num, father[N], rank[N]; //这里rank作用是记录节点深度（真实为深度-1），采用了按秩合并的优化  /* 按秩合并指将深度小的合并到深度大的树上，这样可以减少查询次数。 这里按秩合并与路径压缩一起使用时，rank可能会因路径压缩操作而变得不准确。 因此这里rank只是相对的判断标准，并不一定绝对会将深度小的合并到深度大的 */ void init(int n) { num = n; for (int i = 1; i \u0026lt;= num; i++) father[i] = i; } inline int find(int node) { return father[node] == node ? node : (father[node] = find(father[node])); //这里使用了路径压缩优化  } inline void merge(int node1, int node2) { int father1 = find(node1), father2 = find(node2); if (rank[father1] \u0026lt; rank[father2]) father[father1] = father2; else if (rank[father1] \u0026gt; rank[father2]) father[father2] = father1; else if (father1 != father2) father[father1] = father2, rank[father2]++; //如果深度一样且父节点不一样（不为一棵树），合并后新树深度会加一  } } UnionFind; struct typeHole { long long x, y, z; } hole[N]; bool ifIntersect(typeHole hole1, typeHole hole2, long long r) { return (hole1.x - hole2.x) * (hole1.x - hole2.x) + (hole1.y - hole2.y) * (hole1.y - hole2.y) + (hole1.z - hole2.z) * (hole1.z - hole2.z) \u0026lt;= 4 * r * r; } int main() { long long T, n, h, r; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;T); while (T--) { scanf(\u0026#34;%d%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;h, \u0026amp;r); UnionFind.init(n); UnionFind.father[1001] = 1001, UnionFind.father[1002] = 1002; //这里用特殊的两个节点，1001代表底，1002代表顶。如果father[1001]==father[1002]则证明连通。  for (int i = 1; i \u0026lt;= UnionFind.num; i++) { scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;hole[i].x, \u0026amp;hole[i].y, \u0026amp;hole[i].z); if (hole[i].z \u0026lt;= r) UnionFind.merge(1001, i); if (hole[i].z \u0026gt;= h - r) UnionFind.merge(1002, i); } for (int i = 1; i \u0026lt;= UnionFind.num; i++) for (int j = 1; j \u0026lt;= UnionFind.num \u0026amp;\u0026amp; i != j; j++) if (ifIntersect(hole[i], hole[j], r)) UnionFind.merge(i, j); if (UnionFind.find(1001) == UnionFind.find(1002)) printf(\u0026#34;Yes\\n\u0026#34;); else printf(\u0026#34;No\\n\u0026#34;); } } /* WA 1st: 没考虑到只有一个洞以及贯穿的情况…… 修改: 1. merge(i,1001) ---\u0026gt; mergr(1001,i) 实际上完全没必要，因为无论前并后还是后并前，最终都是父节点合并…… 2. if (hole.z\u0026lt;=r) ... else if (hole.z\u0026gt;=h-r) ...; ---\u0026gt; if ...; if ...; 当时想着要么是底部相交要么是顶部相交，导致用了个else if，没考虑到直接贯穿的情况…… WA 2nd: long long！！！！…… */ ","date":"2020-12-20T00:00:00Z","image":"https://blog.supersassw.com/p/union-find/60855211_p0_hu2f29f1f8fc777ac15405156777510011_1339015_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/union-find/","title":"并查集……"},{"content":"简介 是一种用来维护 区间信息 的数据结构。\n可以实现的操作：\n 单点、区间修改 区间查询（区间求和、最大值、最小值） 等等  描述 线段树会将一个非点区间（即长度大于$1$）利用递归的思想，二分为两个子区间来进行操作。\n这样就会将一个线段划分转化成一个树形结构。\n其中：紫色的a[]是原数组，红色的d[]是线段树：存储的区间的和，黄色范围代表管辖区间。\n每个节点会存储并维护其所管辖的区间的当前信息。（如上图存的就是区间的和）\n可根据题目要求，确定自己所需存储维护的信息。\n实现方法 提前的宏定义 #define NOW_Node node[index]\t//代表当前节点 #define NOW_LSon node[index].sonL\t//代表当前节点左儿子下标 #define NOW_RSon node[index].sonR\t//代表当前节点右儿子下标 0x00 建树 基本认识 根据上图可发现几个要点：\n 每一个节点i的左儿子下标是2i，右儿子下标是2i+1。 记：i管辖的区间为$[s,t]$。\n令：$mid=\\frac{s+t}{2}$。\n则左儿子2i管辖区间为$[s,mid]$，右儿子2i+1管辖区间为$[mid+1,t]$。  实现方法 之前已经介绍了递归的思想，那么只需要确定递归边界。\n由上图很容易看出，递归边界就是当长度为$1$的点。\n记：当前点为node[index]，代表区间为$[l,r]$。原数组为arr[]\n当$l=r$的时候，说明到达递归边界，这个时候的值直接为对应区间的值。\n也就是node[index] = arr[r]\n因为二分的操作使得递归的深度不会大于$log(n)$，故完全可以采用递归的方式简化代码，不用担心递归的栈溢出等缺点。\n储存方法 方法1、 struct typeNode { int val, L, R, mid, len;\t//val代表储存的值，L、R分别代表区间左、右端点，mid代表区间中点，len代表区间长度 }node[4*N]; 直接用左儿子下标为2i，右儿子下标为2i+1转递。\n函数为build(int index, int l, int r)，建左儿子用则为build(2*i, l, r)。\n 空间范围：反正直接把长度设置为$4n$。\n因为该线段树深度为$\\lceil log(n) \\rceil$，又因为为完全二叉树，总节点个数为$2^{\\lceil log(n) \\rceil +1}-1$。但建树的时候最后一层不一定从左往右建，也可能很右边会有一个，所以要预留出所有的最后一层的节点位置，即开$4N$。\n具体分析见关于线段树的数组到底是开2N还是4N。  方法2、 struct typeNode { int val, L, R, mid, len, sonL, sonR;\t//多了个sonL和sonR，代表左儿子的index和右儿子的index }node[2*N]; build()的时候需要多一个计数器变量cnt，记录总过有多少节点。\n函数为build(int \u0026amp;index, int l, int r)。其中传引用会在伪代码中解释。\n这里多存了个左儿子和右儿子的下标，使得可以保证从按顺序建，不会出现空间浪费，于是可以开$2N$。\n相较于方法2空间消耗会少一点。\n以下采用“方法2”的方式来储存。\n伪代码 struct typeSegment{ int cnt = 0;\t//记录node节点的数量，便可实现按顺序建树  struct typeNode{ int val, L, R, len, mid, sonL = 0, sonR = 0; } node[N * 2]; void build(int \u0026amp;index, int L, int R) //对区间[L,R]建立节点，下标为index \t{ index = ++cnt; /*引用index的原因： 这里因为引用index，在递归时会直接把seg[index].son_赋值为某儿子的index。 */ NOW_Node.L = L, NOW_Node.R = R, NOW_Node.mid = (L + R) \u0026gt;\u0026gt; 1, NOW_Node.len = R - L + 1;//节点基本信息  if (L == R) NOW_Node.val = arr[R]; //为递归边界，直接为对应区间的值 \telse { build(NOW_LSon, L, NOW_Node.mid); //划分建立左区间，注意这里传的index是sed[index].lson \tbuild(NOW_RSon, NOW_Node.mid + 1, R); //划分建立右区间 \tNOW_Node.val = node[NOW_LSon].val + node[NOW_RSon].val; //计算该区间信息 \t} } }Segment;\t//直接用个总结构体，便于模板化。//其实就是个个人癖好orz…… 0x01 区间查询 对区间进行值的条件查询，如对区间$[L,R]$求总和，求区间最值等操作。\n实现方法 将要查询的区间，拆成几个在其范围里的节点的区间进行求解计算。（类似于分块思想）\n 如果当前区间完全在查询区间的范围里，则直接返回这个区间的值。 如果不是，则分别查询左右区间计算最终值。  如果查询区间的左端点小于等于当前区间中点，则查询范围会存在于左儿子区间里，要查询左儿子。 如果查询区间的右端点大于当前区间中点，则查询范围会存在于右儿子区间里，要查询右儿子。  注意：这里为大于！因为中点是算在左区间里的！…… \r    【直接给代码吧ヾ(•ω•`)o……\n伪代码 int query(int index, const int \u0026amp;q_L, const int \u0026amp;q_R) { if (q_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; q_R\u0026lt;= NOW_Node.R) return NOW_Node.val; //当前区间直接在查询区间里，直接返回值 \t//【我查了，一句返回了，有什么好说的…… \t//↓ 不完全包含于查询区间里，就要查询两子区间的值计算 \tint tmpAns = 0; if (q_L \u0026lt;= NOW_Node.mid) tmpAns += query(NOW_LSon, q_L, q_R); //如果要查询区间左端点，比当前区间的中点还大，证明左儿子区间完全不在 \tif (q_R \u0026gt; NOW_Node.mid) tmpAns += query(NOW_RSon, q_L, q_R);\t//为\u0026gt;，不是\u0026gt;= \treturn tmpAns; } 0x02 区间修改 对区间进行值的修改，如区间$[L,R]$加上或乘上一个数。\n(最初)实现方法 跟查询的方法一样，找到对应区间后直接修改值。\n但注意，如果不是长度为1的区间，值的修改要乘上对应修改区间的长度。\n 比如对$[1,2]$这个区间加上$2$。\n$[1,1]$和$[2,2]$这两个子区间会加$2$。\n但$[1,2]$则个大的区间应该加的就是$4$。\n同理，$[1,4]$这个大区间就该加$8$了。\n 缺点分析 【诶我说停停，先别着急写啊，不要啪的一下就写起来了很快啊……\n如果碰上这样的情况：\n  对区间$[1,10000]$加上$10000$次$233$。 查询区间$[23333,23333]$的值。   怎么样，有没有觉得自己被耍了！\n所以如果当老实人，他让我们修改区间，我们就老老实实修改区间，可是要吃大亏的。【指TLE……\n改进方法 所以他耍我们，我们也耍一下他xd。\n不是让我们对区间修改吗，我们就先偷下懒：不老老实实地全部修改完，只做个记号在那。\n等到他让我们真正查询这个区间的时候，我们也才真正的去修改，并返回查询值。【并且注意lazy清零！……\n这便是lazy懒标记的由来。\n但我们该怎么偷懒呢？\n 如果当前区间完全在修改区间的范围里，我们便可以按分析的那样，先把修改的值加到lazy里。等之后有需要再去真正地修改，即“下放lazy”。 如果不是，这里就需要注意，我们再直接加到lazy标记的话，有些明明不该修改的区间就会被修改。所以这里的懒就偷不得，就要真正的修改当前节点的值，并尝试修改子节点。（但如果儿子可以偷懒，就让儿子去偷懒）  如果修改区间的左端点大于当前区间中点，则不会修改左儿子区间。 如果修改区间的右端点小于等于当前区间中点，则不会修改右儿子区间。    伪代码  区间修改：  struct typeNode{ int ..., lazy;\t//这里多定义个lazy，用来存偷懒没修改的值 } void modify(int index, const int \u0026amp;m_L, const int \u0026amp;m_R, const int \u0026amp;m_val) { if (m_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; NOW_Node.R \u0026lt;= m_R) NOW_Node.lazy += m_val;\t//当前区间完全在范围里，直接偷懒 \telse { NOW_Node.val += (min(m_R, NOW_Node.R) - max(m_L, NOW_Node.L) + 1) * m_val;\t/* 这里是修改所包含区间的值 如要修改[4,9]，当前节点区间是(1,6)\t//这里为了区分用的小括号，实际上包含端点 则只会修改[4,6)，也就是val += (6 - 4 + 1) * 2 */ if (m_L \u0026lt;= NOW_Node.mid) modify(NOW_LSon, m_L, m_R, m_val); if (m_R \u0026gt; NOW_Node.mid) modify(NOW_RSon, m_L, m_R, m_val); } }  有lazy的区间查询：  struct typeNode{ ... void pushdown(typeSegment *Segment)\t//下放也不用太彻底，能摸一层是一层xd…… \t{ val += len * lazy;\tif (sonL) Segment.modify(sonL, L, mid, lazy); //存在子节点才下放【不然我这种结构就会无限下放_(:з」∠)_…… \tif (sonR) Segment.modify(sonR, mid + 1, R, lazy); lazy = 0;\t//！lazy注意清零！ \t} } int query(int index, const int \u0026amp;q_L, const int \u0026amp;q_R) { if (NOW_Node.lazy) NOW_Node.pushdown(*this);\t//注意查询的时候，只要有懒标记就必下放【别人都来查岗了你还摸鱼.jpg……  if (q_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; NOW_Node.R \u0026lt;= q_R)\t//以下跟普通的查询操作一样 \treturn NOW_Node.val; int tmpAns = 0; if (q_L \u0026lt;= NOW_Node.mid) tmpAns += query(NOW_LSon, q_L, q_R); if (q_R \u0026gt; NOW_Node.mid) tmpAns += query(NOW_RSon, q_L, q_R); return tmpAns; } Tip: 我这里的偷懒是直接连本身都先不修改，而在下放的时候才修改；其他人有些可能会先修改自身。算是个小优化，注意区分一下……\n最终代码 洛谷P3372 【模板】线段树 1\n#include \u0026lt;bits/stdc++.h\u0026gt; #define N 100000  #define NOW_Node node[index]\t//代表当前节点 #define NOW_LSon node[index].sonL //代表当前节点左儿子下标 #define NOW_RSon node[index].sonR //代表当前节点右儿子下标 using namespace std; long long arr[N + 5]; struct typeSegment { int cnt = 0; //记录node节点的数量，便可实现按顺序建树  struct typeNode { long long val; int L, R, len, mid, sonL = 0, sonR = 0, lazy = 0; void pushdown(typeSegment \u0026amp;Segment) //下放也不用太彻底，左右儿子仍加到lazy里。【能摸一层是一层xd…… \t{ val += len * lazy; if (sonL) Segment.modify(sonL, L, mid, lazy); //存在子节点才下放【不然我这种结构就会无限下放 \tif (sonR) Segment.modify(sonR, mid + 1, R, lazy); lazy = 0; //lazy注意清零。 \t} } node[N * 2]; void build(int \u0026amp;index, int L, int R) //对区间[l,r]建立节点，下标为index \t{ index = ++cnt; //引用原因： \t//这里因为引用index的原因，在递归时会直接把seg[index].lson赋值为左儿子的index。 \tNOW_Node.L = L, NOW_Node.R = R, NOW_Node.mid = (L + R) \u0026gt;\u0026gt; 1, NOW_Node.len = R - L + 1; //节点基本信息 \tif (L == R) NOW_Node.val = arr[R]; //为递归边界，直接为对应区间的值 \telse { build(NOW_LSon, L, NOW_Node.mid); //划分建立左区间，注意这里传的index是sed[index].lson \tbuild(NOW_RSon, NOW_Node.mid + 1, R); //划分建立右区间 \tNOW_Node.val = node[NOW_LSon].val + node[NOW_RSon].val; //计算该区间信息 \t} } void modify(int index, const int \u0026amp;m_L, const int \u0026amp;m_R, const int \u0026amp;m_val) { if (m_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; NOW_Node.R \u0026lt;= m_R) NOW_Node.lazy += m_val; //当前区间完全在范围里，直接偷懒。 \telse { NOW_Node.val += (min(m_R, NOW_Node.R) - max(m_L, NOW_Node.L) + 1) * m_val; /* 这里是修改所包含区间的值 如要修改[4,9]，当前节点区间是(1,6)\t//这里为了区分用的小括号，实际上包含端点 则只会修改[4,6)，也就是val += (6 - 4 + 1) * 2 */ if (m_L \u0026lt;= NOW_Node.mid) modify(NOW_LSon, m_L, m_R, m_val); if (m_R \u0026gt; NOW_Node.mid) modify(NOW_RSon, m_L, m_R, m_val); } } long long query(int index, const int \u0026amp;q_L, const int \u0026amp;q_R) { if (NOW_Node.lazy) //注意查询的时候，只要有懒标记就必下放【别人都来查岗了你还摸鱼.jpg…… \tNOW_Node.pushdown(*this); if (q_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; NOW_Node.R \u0026lt;= q_R) return NOW_Node.val; //当前区间直接在查询区间里，直接返回值//【我查了，一句返回了，有什么好说的……  //↓ 不完全包含于查询区间里，就要查询两子区间的值计算 \tlong long tmpAns = 0; if (q_L \u0026lt;= NOW_Node.mid) tmpAns += query(NOW_LSon, q_L, q_R); //如果要查询区间左端点，比当前区间的中点还大，证明左儿子区间完全不在 \tif (q_R \u0026gt; NOW_Node.mid) tmpAns += query(NOW_RSon, q_L, q_R); return tmpAns; } } Segment; //直接用个大的结构体，便于模板化。 int main() { int n, m, tmp, w, l, r, i; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;arr[i]); Segment.build(tmp, 1, n); //Segment.test(1); \twhile (m--) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;w); if (w == 1) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;i); Segment.modify(1, l, r, i); } else { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); printf(\u0026#34;%lld\\n\u0026#34;, Segment.query(1, l, r)); } } } ","date":"2020-12-20T00:00:00Z","image":"https://blog.supersassw.com/p/segment-tree/67957130_p0_hu2c7318d0e2072da042ef7a1c5115b73e_4170699_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/segment-tree/","title":"线段树……"},{"content":"音乐播放器 采用的APlayer的外链播放器……\n默认会显示在文章顶部……\n如需用吸底模式，请在第一个参数输入-fixed: 1……\n当然要放我最喜欢的怪力熊的歌啦！……\n【虽然网易云上没有原曲qwq……不过这两首也超好听的！……\n","date":"2020-12-19T00:00:00Z","image":"https://blog.supersassw.com/p/test-player/84038692_p0_hu3b9cb195d3b981b9da74048e9a17f8de_395719_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/test-player/","title":"音乐播放器测试……"},{"content":"Shortcode Hugo的Shortcode的测试……\n新增了Bilibili的链接……\n 不知道是什么的原文x：\n Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\n 详解 使用方法类似于Hexo当中的标签插件（Tag Plugins）\n有两种Shortcode的使用方法……\n  内嵌Shortcode\n{{\u0026lt; type content \u0026gt;}}   Shortcode块\n{{\u0026lt; type \u0026gt;}} content {{\u0026lt; \\type \u0026gt;}}    对于内容的解析也有两种方法：\n  内容解析为HTML\n{{\u0026lt; ... \u0026gt;}}   内容解析为Markdown\n{{% ... %}} 一般这个不常用，个人自写的所有Shotrcode都是基于\u0026lt;\u0026gt;来处理的……\n   功能测试 YouTube Privacy Enhanced Shortcode \r\r需要科学上网才能查看……\n Bilibili Simple Shortcode \r   使用方法：\n{{\u0026lt; bilibili BV1754y1R7Nd \u0026gt;}}   默认为BV号。\n 可选参数：  av = \u0026quot;...\u0026quot;：使用av号。\n使用例：{{\u0026lt; bilibli av=\u0026quot;10492\u0026quot; \u0026gt;}} hq = *：画质。0为低画质，1为高画质。（默认值为1） p = *：视频选集。（默认值为1）    ","date":"2020-12-18T00:00:00Z","image":"https://blog.supersassw.com/p/test-shortcode/78356827_p0_huc21610886fa327c8e802235e20e8c4e7_690415_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/test-shortcode/","title":"Shortcode测试……"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用  思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n 图片 \rPhoto by Florian Klauer on Unsplash\r \rPhoto by Luca Bravo on Unsplash\r\n\rPhoto by Helena Hertz on Unsplash\r \rPhoto by Hudai Gayiran on Unsplash\r\n![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-12-18T00:00:00Z","image":"https://blog.supersassw.com/p/test-chinese/Yande-331204_hu78842091091c5acfc10d1d28fbf3f867_2198432_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/test-chinese/","title":"页面测试……"},{"content":" 以下为之前的笔记直接放过来的，部分样式会有错误（如KaTeX没有渲染等）…… \r 邻项比较排序 定义 本来的排序型贪心，我们需要任意两个项都满足决策条件。\n但我们发现，如果数列每对相邻两项都满足决策条件，根据不等式的传递性，那么也就可以推出任意两项满足决策条件。\n于是我们分析决策条件时，就不用分析任意两项，可以就分析邻项然后推出决策条件。\n【主要用于如果决策条件复合了其他数据（比如：结果计算为$\\sum_{i=1}^na_i$，复合之前的数列），这样分析可以减少分析难度】\n  典型例题：\nP1080 国王游戏\n 可以见到这题便有一个「排在该大臣前面的所有人的左手上的数的乘积」这句话，\n如果我们分析任意两项的话，还要考虑两者中间的数据。\n所以我们可以指通过分析相邻两项，然后通过传递性，推及任意两项都满足。\n 【其实用任意两项分析也完全可以，而且分析也不难_(:з」∠)_……\n  那么实现的关键就是找到最终的决策方案（序列满足的条件），然后根据这个决策sort就行了_(:з」∠)_……\n【但是会有注意点后面会讲到……\n题目解决方法 引例  以下以此例题为例具体讲解：\nSWJTU OJ——10.31 A 排队\n 题目与国王游戏类似，用邻项交换排序的思想来找决策条件。\n1、找出每种状态的ans，选邻项代入  题目描述：\n也就是说，请重新给班尼特排队，要求是最大化$\\min_{i=1}^n{-h_i+\\sum_{j=1}^i v_j}$。\n 那么每种状态的ans$=\\min_{i=1}^nw_i$。\n既然要求$\\min_{i=1}^n{w_i}$，所以我们就比较邻项的$w_i,w_j$，比较其两项的$\\min(w_i,w_j)$，选择最大ans的状态。\n 为什么我们这样排序，能使ans$=\\min_{i=1}^nw_i$取得最小？  就相当于把比较时候的最小值看成短板，每次比较一次选最高的那个，就会把短板提上去一点，这样最后得到的就是最高的短板，也就是最大的$\\min$……\n   2、假设相邻位置，写出两种状态的ans 我们首先要把每个位置的收益表达式写出来：\n 题目描述：治疗第$i$个班尼特的收益$w_i$等于前面治疗的所有班尼特的$v$之和减去$h_i$。 $$ w_i=\\sum_{j=1}^iv_j-h_i $$\n 那么我们假设两个相邻位置$i,j$。其中$i$在$j$前，即$i=j-1$。【必须先假设一个在另一个前后，否则不可能$i$在$j$前满足，$j$在$i$前也满足】\n记：两者之前的$\\sum v$为$sum$。【将一些求$w$要用到的比如$\\sum$记为其他符号表示，可以简化式子】\n然后分别讨论$i$在$j$前和$j$在$i$前的情况：\n  原本状态：$i$在$j$前\n $$ \\begin{matrix} h \u0026amp; v \\\n\\vdots \u0026amp; \\vdots(sum) \\\nh_i \u0026amp; v_i \\\nh_j \u0026amp; v_j \\\n\\vdots \u0026amp; \\vdots \\\n\\end{matrix} $$\n 对$i$的收益：$w_{i1}=sum+v_i-h_i$\n对$j$的收益：$w_{j1}=sum+v_i+v_j-h_j$\n此状态的ans=$\\min(w_{i1},w_{j1})$\n  如果交换：$j$在$i$前\n $ \\begin{matrix} h \u0026amp; v \\\n\\vdots \u0026amp; \\vdots(sum) \\\nh_j \u0026amp; v_j \\\nh_i \u0026amp; v_i \\\n\\vdots \u0026amp; \\vdots \\\n\\end{matrix} $\n 对$i$的收益：$w_{i2}=sum+v_j+v_i-h_i$，\n对$j$的收益：$w_{j2}=sum+v_j-h_j$\n此状态的ans=$\\min(w_{i2},w_{j2})$\n  3、根据题意写出排序条件并化简，得到最终决策方案  题目描述：芭芭拉想让治疗每个班尼特收益的最小值最大。\n 题意要求使最小收益最大化，\n则最初排序条件为：$\\min(w_{i1},w_{j1})\\ge\\min(w_{j2},w_{i2})$\n【或者说**交换条件**为：$\\text{if} \\quad (\\min(w_{i1},w_{j1})\u0026lt;\\min(w_{j2},w_{i2})) \\quad \\text{swap}(i,j)$】\n *其他例子：国王游戏中，是使最大收益最小化。则排序条件为：$\\max(w_{i1},w_{j1})\\le\\max(w_{i2},w_{j2})$*\n 然后对这个决策条件化简，使得能直接表达出来。\n【所谓不能直接表达的，便是条件中含有如$\\sum$之类的运算。而我们不可能用循环专门去求，只能通过化简把他消掉】\n 化简方法：\n下列所提到的化简方法参考含max、min的不等式。\n  利用“完全展开法则”，观察是否含有恒成立或恒不成立。\n【或者直接观察题目中$w_{i1},w_{j1},w_{j2},w_{i2}$间的关系，找出恒成立或恒不成立，然后利用“**消元法则**”】\n  利用排序规则下特殊的“相同无关原则”，结合“取反性、结合性”等性质，化简并得到最终的最简决策\n   则本题中：\n展开为$\\text{if} \\quad ((w_{i1}\u0026lt;w_{i2} \u0026amp; w_{i1}\u0026lt;w_{j2}) | (w_{j1}\u0026lt;w_{i2} \u0026amp; w_{j1}\u0026lt;w_{j2})) \\quad \\text{swap}$。\n 发现$w_{i1}\u0026lt;w_{i2}$恒成立：  $\\sout{sum+v_i-h_i} \\quad?\\quad \\sout{sum}+v_j\\sout{+v_i-h_i}$\n$\\implies 0\u0026lt;v_j$\n  发现$w_{j1}\u0026lt;w_{j2}$恒不成立：  $\\sout{sum}+v_i\\sout{+v_j-h_j} \\quad?\\quad \\sout{sum+v_j-h_j}$\n$\\implies v_i\u0026gt;0$\n   故原式可简化为：\n$\\text{if} \\quad (w_{i1}\u0026lt;w_{j2}) \\quad \\text{swap}$\n$\\implies \\text{if} \\quad (v_i-h_i \u0026lt; v_j-h_j) \\quad \\text{swap}$\n这便是化简后的**决策条件**。\n 注意的点：\n不一定要化到最简，只要能在代码里直接表达就行。\n 本题中原始条件经过部分化简：\n运行结果：\n而完全化简后为：\n运行结果：\n可见差异并不大，所以说只要能化简到能表达的地步就可以。\n当然如果能化到最简更好，肯定还是比带min的条件快的。\n \r 4、自定义结构体，重载\u0026lt;运算符，使用sort，遍历寻答案 这一步就不多说了，重载的时候按自己分析到的最终最简决策重载就行。\n但重点是：\n这样排序出来后只是最优状态，\n至于最终答案ans要从头到尾遍历寻找，即不一定是第一个为最终答案。\n可能后面计算结果不是递增或递减，则最终答案不是第一个。【具体题目具体分析】\n\r  标程代码 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N = 100010; struct Data { int h, v; bool operator\u0026lt;(const Data \u0026amp;t) { return v - h \u0026gt; t.v - t.h; } //以推出的最终最简决策重载\u0026lt;运算符 } d[N]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;d[i].h, \u0026amp;d[i].v); sort(d + 1, d + n + 1); //就一个sort  int tmp = 0, res = 1e9; for (int i = 1; i \u0026lt;= n; ++i) { tmp += d[i].v; res = min(res, tmp - d[i].h); //从头到尾遍历，res记录最终答案 \t} printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } 使用注意事项 注意之前我们定义中存在一个推论：\n 如果数列每对相邻两项都满足决策条件，根据不等式的传递性，那么也就可以推出任意两项满足决策条件。\n 所以假如我们所推的某个决策条件，不满足不等式的传递性，那么用这个方法就会造成错误。\n而这种必须要满足不等性的传递性，有个专门术语叫做“严格弱序”。\n先前知识——严格弱序   $X \\not\u0026lt; X$（比较条件非自反性）\n意思是：$X$与$X$本身，不满足比较条件。  反例：比较条件是$a_i \\ge a_j$。\n那么$X(a_i) \\ge X(a_i)$满足比较条件，为$X \u0026lt; X$，故不是严格弱序。   若$X \u0026lt; Y$，则$Y \\not\u0026lt; X$（比较条件非对称性）\n意思是：$X$和$Y$比较若满足比较条件，则$Y$和$X$比较不会满足条件。  反例：比较条件是$a_i \\ge a_j$。\n那么若$a_i=a_j$，$X(a_i) \\ge Y(a_j)$满足条件，\n但$Y(a_j) \\ge X(a_i)$也满足条件，故不是严格弱序。   若$X \u0026lt; Y,Y \u0026lt; Z$，则$X \u0026lt; Z$（比较条件不等传递性）\n意思是：$X$和$Y$满足比较条件，$Y$和$Z$满足比较条件，则$X$和$Y$满足比较条件。   反例：比较条件是$\\min(a_i,b_j) \\le \\min(a_j,b_i)$。\n那么对于下组数据：\n    $a$ $b$     $i$ $2$ $1$   $j$ $1$ $1$   $k$ $1$ $2$    $X(\\min(a_i,b_j)=1)\u0026lt;Y(\\min(a_j,b_i)=1)$\n$Y(\\min(a_j,b_k)=1)\u0026lt;Z(\\min(a_k,b_j)=1)$\n但$X(\\min(a_i,b_k)=2) \\not\u0026lt; Z(\\min(a_k,b_i)=1)$，故不是严格弱序。 【再次提示这里的$\u0026lt;$并不代表小于，而是代表符合比较条件的意思。】\n   若$X=Y,Y=Z$，则$X=Z$（比较条件相等传递性）\n意思同上。\n在“ouuan”dalao的讲解种写的是$x\\not\u0026lt;y,y\\not\u0026lt;x,y\\not\u0026lt;z,z\\not\u0026lt;y$（不可比性的传递性）。我改成这样更好理解。\n不过注意判断相等的方法是$x\\not\u0026lt;y,y\\not\u0026lt;x$这么判断的。  反例见下引例的「错误分析」      这里的$X$、$Y$、$Z$代表的是取某下标$i$、$j$后的决策条件的一侧元素。并不一定是某一具体数据。 这里的$\u0026lt;$并不代表小于的意思，而是代表满足比较条件，那么$\\not\u0026lt;$则代表不满足比较条件。  引例  P2123 皇后游戏\n 按照之前的方法尝试解决   找出每种状态的ans，选邻项代入\n 题目描述：\n她想请你来重新安排一下队伍的顺序，使得获得奖金最多的大臣，所获奖金数目尽可能的少。\n 可知每种状态的ans$=\\max_{i=1}^nw_i$。\n那么比较邻项$i,j$，就是$max(w_i,w_j)$。\n  假设相邻位置，写出两种状态的ans\n首先先写收益表达式：\n$$ w_i=\\max(w_{i-1},\\sum_{j=1}^ia_j)+b_i $$ 【第一位的收益可以合并到这个表达式里，令$w_0=0$就可以了。】\n假设相邻位置$i,j$。其中$i$在$j$前，即$i=j-1$。\n记：之前的$\\sum a$为$sum$，前一项的$c_{i-1}$为$pre_w$。\n会发现，由于$a,b\u0026gt;0$，整个收益表达式中又没出现会使收益变少的运算，故收益单增。\n即在后面的大臣的收益一定大于在前面的。\n$i$在$j$前时，则$w_j$一定大于$w_i$，所以$\\max(w_i,w_j)=w_j$，可以拆开一层$\\max$。\n  原本状态：$i$在$j$前\n $ \\begin{matrix} a \u0026amp; b \u0026amp; c \\\n\\vdots(sum) \u0026amp; \\vdots \u0026amp; \\vdots(pre_w) \\\na_i \u0026amp; b_i \u0026amp; w_{i1} \\\na_j \u0026amp; b_j \u0026amp; w_{j1} \\\n\\vdots \u0026amp; \\vdots \u0026amp; \\vdots \\\n\\end{matrix} $\n $w_{i1}=\\max(pre_w,sum+a_i)+b_i$\n$w_{j1}=\\max(w_{i1},sum+a_i+a_j)+b_j$\n此状态的ans=$\\max(w_{i1},w_{j1})=w_{j1}$\n  如果交换：$j$在$i$前\n $ \\begin{matrix} a \u0026amp; b \u0026amp; c \\\n\\vdots(sum) \u0026amp; \\vdots \u0026amp; \\vdots(pre_w) \\\na_j \u0026amp; b_j \u0026amp; w_{j2} \\\na_i \u0026amp; b_i \u0026amp; w_{i2} \\\n\\vdots \u0026amp; \\vdots \u0026amp; \\vdots \\\n\\end{matrix} $\n $w_{i2}=\\max(w_{j2},sum+a_j+a_i)+b_i$\n$w_{j2}=\\max(pre_w,sum+a_j)+b_j$\n此状态的ans=$\\max(w_{i2},w_{j2})=w_{i2}$\n    根据题意写出排序条件并化简，得到最终决策方案\n题意要求使最大收益最小化，\n则排序条件：$\\max(w_{i1},w_{j1}) \\le \\max(w_{i2},w_{j2})$\n开始化简：\n$\\max(w_{i1},w_{j1}) \\le \\max(w_{i2},w_{j2})$\n$\\implies w_{j1} \\le w_{j2}$\n$\\implies \\max(\\sout{pre_w+b_i+b_j},\\underline{sum+a_i}+b_i+\\underline{b_j},\\underline{sum+a_i}+a_j+\\underline{b_j}) \\le \\max(\\sout{pre_w+b_j+b_i},\\underline{sum+a_j}+b_j+\\underline{b_i},\\underline{sum+a_j}+a_i+\\underline{b_i})$\n【删除线的部分代表根据相同无关原则可以消去；下划线的部分代表根据结合性可以提出来】\n$\\implies \\max(b_i,a_j)+sum+a_i+b_j \\le \\max(b_j,a+i)+sum+a_j+b_i$\n$\\implies \\max(b_i,a_j)-a_j-b_i \\le \\max(b_j,a_i)-a_i-b_j$\n$\\implies \\max(-a_j,-b_i) \\le \\max(-a_i,-b_j)$\n$\\implies -\\min(a_j,b_i) \\le -\\min(a_i,b_j)$\n$\\implies \\min(a_j,b_i) \u0026gt; \\min(a_i,b_j)$\n最终的决策条件：$\\min(a_j,b_i) \u0026gt; \\min(a_i,b_j)$\n  那就开写呗……\n  然后交上去会WA，80分。\n证明我们这种方法有思路缺陷。\n错误分析 这里便不满足严格弱序的相等传递性这个性质。\n 当取$i,j$时，若$\\min(a_i,b_j)=\\min(a_j,b_i)$，\n当取$j,k$时，若$\\min(a_j,b_k)=\\min(a_k,b_j)$，\n则需要满足：取$i,k$时，$\\min(a_i,b_k)=\\min(a_k,b_i)$\n 反例：\n    $a$ $b$     $i$ $3$ $5$   $j$ $1$ $1$   $k$ $7$ $2$    虽然$\\min(a_i,b_j)=\\min(a_j,b_i)$和$\\min(a_j,b_k)=\\min(a_k,b_j)$都满足，\n但却不满足$\\min(a_i,b_k)=\\min(a_k,b_i)$。\n【只需要让$a_j,b_j$相等，就可以构建众多反例。】\n错误根本原因（新内容！）  为什么不满足严格弱序中传递性就会造成错误：  因为sort实现时，采用了分治的思想。\n会将数据分为两个部分，对两个部分进行排序，然后使数列直接有序。\n但问题就刚好出在这个“直接有序”上。\n之所以在左右都有序后，会认为整个数列直接有序，\n就是因为利用了严格弱序中的传递性：\n认为$X \u0026lt; Y,Y \u0026lt; Z$，则$X \u0026lt; Z$，\n以及$X = Y,Y = Z$，则$X = Z$。\n但假如不满足的第一条的话，分治处理过后：\n左侧的数是小于中间的，中间的数也是小于右边的，但左侧的是却不一定小于右边的了。\n会造成很严重的合并后错误。\n但假如不满足的第二条的话，分治处理过后：\n如果都是小于条件，根据第一条可推合并后也有序，没有问题。  这也就是为什么我们这个方法还能得部分分的原因——决策判断时没判断出相等。 \r\n但一旦出现等于条件的情况，则不能推得左边的也等于右边的，\n同时$X=Y, Y\u0026lt;Z \\implies X\u0026lt;Z$、$X\u0026lt;Y, Y=Z \\implies X\u0026lt;Z$也无法推得。\n 举例：判断条件为$\\min(a_i,b_j) \u0026lt; \\min(a_j,b_i)$【就本题我们推的条件…… 对以下两组数据：\n    $a$ $b$     $i$ $1$ $1$   $j$ $1$ $2$   $k$ $2$ $2$    其中$X(i,j)=Y(j,i),Y(j,k)\u0026lt;Z(k,j)$，但$X(i,k) \\not\u0026lt; Z(k,i)$，为$X=Z$。\n    $a$ $b$     $i$ $1$ $2$   $j$ $2$ $1$   $k$ $1$ $1$    其中$X(i,j)\u0026lt;Y(j,i),Y(j,k)=Z(k,j)$，但$X(i,k) \\not\u0026lt; Z(k,i)$，为$X=Z$。\n 那么不满足传递性，就会导致虽然序列大部分满足决策条件，但并不是任意两项都满足条件的。\n而回到我们贪心的基本要求：需要任意两个元素都满足决策条件。\n故会造成错误。\n   改进方法 其实上述主要问题都归结于我们对相等状况的定义模棱两可。\n 对于满足严格弱序中的传递性的数据来说：\n出现相等状况，交换或者不交换都无所谓，因为可以通过传递性证得交换后对数列无影响。\n所以可以保持这种模棱两可的定义。  也就是说这种数据，我们即使将判断中的不取等判断改为取等的判断，也依旧不会有影响。只不过会多交换几次，让状态变得不同，但最终结果一致。\n  对于不满足严格弱序中的传递性的数据来说：\n我们就必须对相等状况作出严格的操作规定了，否则两种不同的状态会导致数据最终结果的不一致。\n也就是说我们要对相等状况进行特判。  那么我们就来考虑在$\\max(w_{i1},w_{j1}) = \\max(w_{i2},w_{j2})$的相等条件下，又该加什么判断。\n也就是说，除了这个很显然的条件在影响ans外，还有没有什么可能影响ans。\n根据个人看法不同，会有很多种可能的条件，以下列举两种正确的：\n  会发现：$a$的前缀和会影响$\\max(c_{i-1},\\sum_{j=1}^ia_j)$这个的选择，从而影响$w_i$，从而影响ans。\n因为要找最小的ans，所以我们**把$a$更小的放在前面**，这样就能让更加保证所得状态是最优的了。\n  会发现：两种状态的前后两项$w$，后者是一样的【我们比较条件就是用的两状态的后者】，因此我们要让前者尽量小，从而确保ans更小。\n所以我们把$b$更小的放在前面。\n   那么假如这两个条件判断出来也是相等的，需不需要再特判呢？  假如$\\min(a_j,b_i) = \\min(a_i,b_j)$和$a_i = a_j$（或者$b_i = b_j$）同时满足，\n则可以推出$a_i=a_j,b_i=b_j$，也就是这两项的数据完全一致，并不是比较用数据一致，因此我们这里也可以即交换又不交换，保持模棱两可定义。\n   很特殊的hack数据 在这里，我们会惊讶地发现，如果用选择排序的话，虽然是会TLE，但其结果是正确的。\n【相关原因请查看后面的「有关排序的深层理解」部分】\n个人发现了选择排序答案是正确的后，对各种排序的实现展开了思考和实验。\n认为像快速排序或归并排序等，是因为采用典型的分治思想才导致需要满足严格弱序的。\n那么对于其他排序方法比如“希尔排序”、“堆排序”、“锦标赛排序”等是否不需要满足严格弱序呢？\n【这里没考虑“计数排序”、“基数排序”和“桶排序”这三种非比较式排序算法。因为这里没有关键字，无法使用这三种排序方法。\n所以在实验的时候就弄出了一些其他的hack数据，\n然后其中发现了一组很特殊的hack数据！(:з」∠)……\n 数据：\n 1\n5\n9 7\n1 1\n4 5\n1 2\n6 5\n *以下表格中的option表示$\\max(c_{i-1},\\sum_{j=1}^ia_j)$选择的哪个*。\n  标准答案：27\n  利用选择排序后的结果\n    $a$ $b$ $c$ option     1 $1$ $2$ $3$    2 $1$ $1$ $4$ $c$   3 $4$ $5$ $11$ $\\sum a$   4 $9$ $7$ $22$ $\\sum a$   5 $6$ $5$ $27$ $c$      特殊性\n我们如果排序成：\n    $a$ $b$ $c$ option     1 $4$ $5$ $9$    2 $1$ $2$ $11$ $c$   3 $9$ $7$ $21$ $\\sum a$   4 $1$ $1$ $22$ $c$   5 $6$ $5$ $27$ $c$    会发现$1$和$2$（$i=1,j=2$）这两组数据，\n其实是不满足$\\min(a_i,b_j) \u0026lt; \\min(a_j,b_i)$这个条件的！\n故这也告诉了我们：最优解也可能存在有两项不满足决策条件的状态。\n【更准确叙述请查看后面的「有关贪心决策的满足度影响」部分】\n  有关自己使用其他排序方法验证的代码，以及其他两组hack数据可见Pastebin。\n决策条件是否正确的判断方法 1、条件检查器 基于以上分析，我们发现：\n如果按上述“基本决策寻找方法”得到的决策条件$P$是正确的，必须要满足基本的排序型贪心的条件：\n 数列任意两项满足决策条件。\n 如果决策条件$P$满足以下条件，则可证得排序后一定满足该基本条件：\n 满足严格弱序中的两个传递性。  根据以上一点，我们可以编写一个条件检查器。\n【这个条件检查器的方法是参考自“ouuan”的博客后了解的，个人在其基础之上有所修改并加入了注释……\n#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstdio\u0026gt;using namespace std; bool cmp(int i, int j); int a[10], b[10]; int main() { for (a[0] = 1; a[0] \u0026lt;= 6; ++a[0]) for (b[0] = 1; b[0] \u0026lt;= 6; ++b[0]) //构造第一组a,b数组数据：用来判断自反性  { if (cmp(0, 0)) //不满足自反性。  //分析知这条对于贪心思路并不是很重要，所以注释了。但如果用sort就很重要。  //printf(\u0026#34;No irreflexivity: %d %d\\n\u0026#34;, a[0], b[0]);  for (a[1] = 1; a[1] \u0026lt;= 6; ++a[1]) for (b[1] = 1; b[1] \u0026lt;= 6; ++b[1]) //构造第二组a,b数组数据：用来判断非对称性  { if (cmp(0, 1) \u0026amp;\u0026amp; cmp(1, 0)) //非对称性的判断  printf(\u0026#34;No asymmetric: %d %d %d %d\u0026#34;, a[0], b[0], a[1], b[1]); /* 这部分原本是判断 我们新的决策条件 与 最开始分析的决策条件 是否判断一致，但其实可以不用判断。 //同理，在ouuan所写的判断器中：有一个关于「排序完成后任意交换相邻元素均不会使答案更优」这个的判断，但实际上如果满足了严格弱序一定也会满足这个条件，也不用判断。 bool our_judge = cmp(0, 1), real_judge = min(a[0], b[1]) \u0026lt; min(a[1], b[0]), if_equal = min(a[0], b[1]) == min(a[1], b[0]); //注意这里真实判断（以决策条件判断），如果为0：有可能真的不满足，但也有可能是相等情况；如果为1：那就一定是满足 //所以我们要加个if_equal，如果是相同状况则不判断是否与真是判断相同 if (!if_equal \u0026amp;\u0026amp; our_judge != real_judge) //与真正决策条件判断不同 printf(\u0026#34;Not correct(%s): %d %d %d %d\\n\u0026#34;, (our_judge == 1 ? \u0026#34;We judge it\u0026#39;s right, but truth is wrong.\u0026#34; : \u0026#34;We judge it\u0026#39;s wrong, but truth is right\u0026#34;), a[0], b[0], a[1], b[1]); */ for (a[2] = 1; a[2] \u0026lt;= 6; ++a[2]) //构造第三组a,b数据：用来判断传递性  for (b[2] = 1; b[2] \u0026lt;= 6; ++b[2]) { bool flag_inequ = 1, flag_equ = 1; bool cmp_01 = cmp(0, 1), cmp_12 = cmp(1, 2), cmp_02 = cmp(0, 2); //注意我们判断两状态是否是用的!cmp(i,j) \u0026amp;\u0026amp; !cmp(j,i)（非对称性的利用）  bool euqal_01 = !cmp(0, 1) \u0026amp;\u0026amp; !cmp(1, 0), euqal_12 = !cmp(1, 2) \u0026amp;\u0026amp; !cmp(2, 1), euqal_02 = !cmp(0, 2) \u0026amp;\u0026amp; !cmp(2, 0); if ((cmp_01 == cmp_12 \u0026amp;\u0026amp; (cmp_01 == 1 || (cmp_01 == 0 \u0026amp;\u0026amp; !euqal_01 \u0026amp;\u0026amp; !euqal_12))) \u0026amp;\u0026amp; cmp_01 != cmp_02) //不符合不等传递性  { /* 怎么才算符合不等传递性： 1 1 -\u0026gt; 1 1 0 -\u0026gt; ? (2 \u0026lt; 7, 7 \\not\u0026lt; 5 ---\u0026gt; 2 \u0026lt; 5)(2 \u0026lt; 7, 7 \\not\u0026lt; 1 ---\u0026gt; 2 \\not\u0026lt; 1) 0 1 -\u0026gt; ? (Same way) 0 0 -\u0026gt; 0 //但要注意这里cmp为0：有可能是不满足，也有可能是因为等于的情况。所以要加!euqal来排除等于情况 */ flag_inequ = 0; printf(\u0026#34;No transitivity of inequivalence: %d %d %d %d %d %d\\n\u0026#34;, a[0], b[0], a[1], b[1], a[2], b[2]); } if (!(euqal_01 == 0 \u0026amp;\u0026amp; euqal_12 == 0) \u0026amp;\u0026amp; (euqal_01 \u0026amp;\u0026amp; euqal_12) != euqal_02) //相等传递性  { /* 怎么才算符合相等传递性： 1 1 -\u0026gt; 1 1 0 -\u0026gt; 0 0 1 -\u0026gt; 0 0 0 -\u0026gt; ? (2 ≠ 3, 3 ≠ 2 ---\u0026gt; 2 = 2)//这个很好知道吧【…… */ flag_equ = 0; printf(\u0026#34;No transitivity of equivalence: %d %d %d %d %d %d\\n\u0026#34;, a[0], b[0], a[1], b[1], a[2], b[2]); } if (flag_inequ == 1 \u0026amp;\u0026amp; flag_equ == 0) //私货：求证如果满足不等传递性，但不满足相等传递性，是否X=Y,Y\u0026lt;Z---\u0026gt;X\u0026lt;Z；X\u0026lt;Y,Y=Z---\u0026gt;X\u0026lt;Z？  { printf(\u0026#34;===In Case===\\n\u0026#34;); bool euqal_cmp01 = !cmp(0, 1) \u0026amp;\u0026amp; !cmp(1, 0), ineuq_cmp01 = cmp(0, 1), euqal_cmp12 = !cmp(1, 2) \u0026amp;\u0026amp; !cmp(2, 1), ineuq_cmp12 = cmp(1, 2), euqal_cmp02 = !cmp(0, 2) \u0026amp;\u0026amp; !cmp(2, 0), ineuq_cmp02 = cmp(0, 2); if (euqal_cmp01 \u0026amp;\u0026amp; ineuq_cmp12) { if (!ineuq_cmp02 \u0026amp;\u0026amp; !euqal_cmp02) printf(\u0026#34;---X=Y,Y\u0026lt;Z---\u0026gt;X not\u0026lt; Z: %d %d %d %d %d %d\\n\u0026#34;, a[0], b[0], a[1], b[1], a[2], b[2]); else if (!ineuq_cmp02) printf(\u0026#34;---X=Y,Y\u0026lt;Z---\u0026gt;X = Z: %d %d %d %d %d %d\\n\u0026#34;, a[0], b[0], a[1], b[1], a[2], b[2]); } if (ineuq_cmp01 \u0026amp;\u0026amp; euqal_cmp12) { if (!ineuq_cmp02 \u0026amp;\u0026amp; !euqal_cmp02) printf(\u0026#34;---X\u0026lt;Y,Y=Z---\u0026gt;X not\u0026lt; Z: %d %d %d %d %d %d\\n\u0026#34;, a[0], b[0], a[1], b[1], a[2], b[2]); else if (!ineuq_cmp02) printf(\u0026#34;---X\u0026lt;Y,Y=Z---\u0026gt;X = Z: %d %d %d %d %d %d\\n\u0026#34;, a[0], b[0], a[1], b[1], a[2], b[2]); } } } } } return 0; } bool cmp(int i, int j) { /* 展开式：【用来debug方便watch的…… int min_ij = min(a[i], b[j]), min_ji = min(a[j], b[i]); bool ans = 0; if (min_ij == min_ji) ans = a[i] \u0026lt; a[j]; else ans = min_ij \u0026lt; min_ji; return ans; */ return min(a[i], b[j]) \u0026lt; min(a[j], b[i]); //Case.1  //return min(a[i], b[j]) \u0026lt;= min(a[j], b[i]); //Case.2  //return min(a[i], b[j]) == min(a[j], b[i]) ? a[i] \u0026gt; a[j] : min(a[i], b[j]) \u0026lt; min(a[j], b[i]); //Case.3  //return min(a[i], b[j]) == min(a[j], b[i]) ? a[i] \u0026lt; a[j] : min(a[i], b[j]) \u0026lt; min(a[j], b[i]); //Case.4 } 上述提到了：如果满足了严格弱序一定也会满足「排序完成后任意交换相邻元素均不会使答案更优」这个条件。\n所以我并没有写上“ouuan”博客中的那个条件。\n而且对于严格弱序，我也认为只用判断传递性即可。\n【如果这种修改有误，请务必告诉我！……\n因为决策条件$P$满足严格弱序后，我们按照$P$排序后，一定会使任意两项均满足$P$，则满足我们的贪心的思想，使得肯定这个状态是最优解状态。\n【但这种口头解释没有严格证明可能没有说服力，可以自己在判断器里删掉注释然后验证一下_(:з」∠)_……\n2、与选择排序对拍 当然，我们发现了：用选择排序的话结果是正确的。\n所以我们也可以很快地写个选择排序，然后跟我们新的方法进行对拍。\n其他补充点 有关排序的深层理解 我们发现选择排序用之前的条件，虽然会TLE，但是是正确的。\n 洛谷上测试状态【其余未放出的均AC】：\n将其两组数据放到本地测评：\n 主要就是因为排序这种绝对的$O(n^2)$的算法，是严格让所有数据都两两比较。\n正式因为其两两比较，使得不需要利用满足数据严格弱序的传递性。\n不会像快排或归并等其他非$O(n^2)$的算法一样，利用严格弱序中的传递性，来对某些情况减少判断，达成了降低复杂度的办法。\n也就是说，他们为了提高速度，省略了一些比较。代价就是数据必须要满足一定的条件，即严格弱序。\n同样，就连冒泡排序这种本来也是$O(n^2)$的排序算法【但实际上并不是绝对的$O(n^2)$，其最坏是$\\frac{(n-1)n}{2}$次操作】，\n因为只是比较相邻的数据，并未严格任意两两比较。也是利用了传递性。\n有关贪心决策的满足度影响 之前发现：\n让任意两项都满足决策条件，是一定是最优解的。\n但之前发现：如果存在两项不满足，也有可能是最优解。\n也就是任意两项都满足决策条件的这种状态，是最优解状态的一种，为$∈$关系。\n但我们只能去找任意两项均满足的这种状态。因为对于存在两项不满足的，也有可能不是最优解，就成了概率问题。\n【而这道题概率出来就是80分……\n有关排序对严格弱序的不同要求   $X \\not\u0026lt; X$（比较条件非自反性） 若$X \u0026lt; Y$，则$Y \\not\u0026lt; X$（比较条件非对称性） 若$X \u0026lt; Y,Y \u0026lt; Z$，则$X \u0026lt; Z$（比较条件不等传递性） 若$X=Y,Y=Z$，则$X=Z$（比较条件相等传递性）   前面已经说了，对于1、2点，其实对于贪心的题目要求并不严格。\n不满足的话只是会多交换几次，导致状态不同，但最终的ans是一样的。\n但某些算法要求必须要遵守1、2点。\n  对于用STL库的sort()：\n其必须还要考虑1、2点非自反性和非对称性。\n因为内部的算法实现，对下标的判断需要用到这两个性质，否则会越界导致RE。\n【不过我没有具体去看函数内部的代码实现，只是根据网上搜的以及自己实验得出来的，不一定准确。但确实不考虑这两个的话会出现RE……\n  对于其他非$O(n^2)$排序方法：\n如：归并排序merge：\n则不用考虑1、2点。\n【当然还是要根据自己的排序写法来判断是否需要满足1、2点……\n  有关传递性的简单判断 我们排序比较时，只会比较两个元素，也就是两个下标，一般用$i,j$代表。\n而排序（决策）条件，也一定是与$a_i$和$a_j$的衍生关系。\n那么排序条件的下标会有两种情况：\n  一侧只有一个下标\n形如：$cmp(x,y)=A_x?A_y$\n当比较条件一侧只有一个下标的时候很好理解，就是普通的数列排序。\n单侧下标时，两个下标的选择不会影响其对应的比较用数据的值，\n故一般能符合比较条件不等传递性和比较条件相等传递性。\n 举例：    条件为$a_i\u0026gt;a_j$\n取$i,j$：$a_i=a_j$\n取$j,k$：$a_j=a_k$\n取$i,k$：$a_i=a_k$ 条件为$a_i+a_{i+1}\u0026gt;a_j+a_{j+1}$\n取$i,j$：$a_i+a_{i+1}=a_j+a_{j+1}$\n取$j,k$：$a_j+a_{j+1}=a_k+a_{k+1}$\n【则可直接推得$a_i+a_{i+1}=a_j+a_{j+1}=a_j+a_{j+1}=a_k+a_{k+1}$】\n取$i,k$：$a_i+a_{i+1}=a_k+a_{k+1}$     一侧两个下标都有\n形如：$cmp(x,y)=A_{x,y}?A_{y,x}$\n当一侧两种下标都有时，则不同下标的选择会影响其对应的比较用数据的值。\n故需要具体判断是否比较条件传递性和比较条件相等传递性。\n 举例：    条件为$a_i+a_{j+1}\u0026gt;a_j+a_{i+1}$\n取$i,j$：$a_i+a_{j+1}=a_j+a_{i+1}$\n取$j,k$：$a_j+a_{k+1}=a_k+a_{j+1}$\n【不可直接推得$a_i+a_{j+1}=a_j+a_{i+1}=a_j+a_{k+1}=a_k+a_{j+1}$】\n但可证得：取$i,k$：$a_i+a_{k+1}=a_k+a_{i+1}$     总结 有关排序型贪心，最基本的条件：\n 数列任意两项满足决策条件。\n 而我们可以利用传递性，只用分析相邻两项，来得到决策条件。\n但在找到决策条件之后，要判定其是否满足严格弱序中的“相等传递性”和“不等传递性”\n因此题目解决大致思路方法：\n  找出每种状态的ans，选邻项代入 假设相邻位置，写出两种状态的ans 根据题意写出排序条件并化简，得到最终决策方案（不一定划到最简） 判断是否满足传递性 如满足：自定义结构体，重载\u0026lt;运算符，使用sort，遍历寻答案    以上部分参考自“ouuon”的「浅谈邻项交换排序的应用以及需要注意的问题」，以及“Joker\u0026amp;Liar”的「浅谈邻项交换排序」\n写在最后：\n 真的没想到写了这么多orz……弄了整整四天来写这一个东西qwqqq……\n写这么长而且也很混乱，估计以后自己或者其他人也根本看不下去吧x【……\n不过其实这里面还是有很多新发现的。比如快速排序算法的快速原因，以及最珍贵的就是那个不符合任意两项满足条件但是也对的hack数据什么的……\n也算是很深入地去理解贪心中这排序型贪心的本质……并且有一些也是在“ouuan”dalao博客里所没有的新发现，也算是比较安慰了【？……\n就这样吧，最近刚好也发生了很多事……\n按照自己的步调前行吧……\n ","date":"2020-12-15T00:00:00Z","image":"https://blog.supersassw.com/p/neighbor-sort/71111285_p0_hud2648e021785c2a9f9434e425c67999f_2056049_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/neighbor-sort/","title":"邻项比较排序……"},{"content":"贪心 定义 贪心，指的是决策时都采取当前最优解的算法。\n可以通过局部最优解拓展得到全局最优解。\n用处 寻找最优解（如：找最大(小)值）\n贪心类别 一、排序型贪心 这种类型就是通过给数据排序，不同的排序方法演绎下去就会有不同的答案ans。\n然后要比较所有排序方法，选让这些ans的最值。\n  为什么会想到排序？\n 虽然我们只看重眼前利益选择当前的最优解，随时准备开冲去比较两者选获利最大的【指直接从头开始遍历然后选择】。\n但这个时候我们暂且压一下枪理智一下：我们怎么知道我们现在选的是不是最优解呢？\n也就是说，可能现在这两个中，我选了一个当前最优解，但实际上跟后面比起来，这两个都不是最优解。\n也就是著名的苏格拉底的“拣麦穗的故事”。\n所以我们以全局眼光来看这些数据，飞到这片麦田之上，就会发现：“哦~原来利益最大的在那个地方、第二大的又在另个地方……”\n然后我们知道这些获利最大的点在哪里，就用原力把他们放到我们面前来，然后直接取走就行了。\n或者说：我们先辛苦一下对这些数据排下序，然后直接取最优结果就可以了。\n   所以我们就能得到有关排序型贪心的定义：\n 通过对数据，按照某种决策条件排序，使得任意两项均满足该决策条件，而找到最优解。\n 实现方法  根据题意，分析每种状态的ans如何计算，以及题目要求取ans的什么最值。 采用邻项交换排序思想，选取相邻两项$i,i+1$，比较两种状态的ans，选择最优的ans。由此可以推出一种基于数据比较的决策方案。 按照该决策方案排序，算出排序后状态的ans值，即为结果。  邻项交换排序 这一部分请查看邻项交换排序笔记。\n二、反悔型贪心 依然是上面的引例：\n【我管不了那么多了我现在就要开冲.jpg……\n但一路冲下去，如果发现有比之前选择的更好的数据，\n我们是不是就会觉得后悔，觉得如果之前不选那个而选这个该多好。\n因此我们就可以从之前所选择的当中，取一个最差的，然后跟这个最好的换一下。\n这就是反悔贪心法的基本思路：\n 无论当前的选项是否最优都先接受，然后继续往后进行比较。\n如果发现有比之前选择更优的，则反悔，舍弃之前最差的换成这个选项；否则继续往后比较。直到序列遍历完。\n  要记录之前所选择的，则一般采用优先队列。  ","date":"2020-12-14T00:00:00Z","image":"https://blog.supersassw.com/p/greedy/80942286_p0_hu1614f1e19d3d1ca6099df8f8b769c088_1500547_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/greedy/","title":"贪心……"},{"content":"STL 详解 set——集合 set\u0026lt;int\u0026gt; STL_set\nset为关联容器。为一种体现集合性质的容器。\n其中不允许有重复元素。\n并且set中的元素是排好序的（升序）。\n用法： set\u0026lt;int\u0026gt; STL_set; //---对整体的操作--- STL_set.clear();\t//清空 STL_set.empty();\t//返回是否为空 STL_set.size();\t//返回元素个数 //---对元素的操作--- STL_set.insert(...);\t//在集合中插入元素 STL_set.erase(...);\t//删除集合中的元素 STL_set.count(...);\t//返回元素的个数【由于set不能存在重复元素，故只能返回0或1 //---迭代器--- STL_set.begin(); STL_set.end(); STL_set.find(...);\t//返回一个指向被查找到元素的迭代器，未找到返回set::end() STL_set.lower_bound(...)\t//返回大于等于某值的第一个元素的迭代器 STL_set.upper_bound(...)\t//返回大于某个值元素的迭代器 自定义性： set可支持自定义类型，但需要重载\u0026lt;运算符。\n struct type //用来存棋盘状态 { ...; bool operator\u0026lt;(type x) const { return ...; } }  实现： 内部以红黑树的形式实现。\n应用场景： set就是关键字的简单集合。当只是想知道一个值是否存在时，set是最有用的。\n同时可以实现数据去重。\n衍生STL：  multiset: 关键字可重复出现的set。 unordered_set: 未排序的set（用hash函数组织）。 unordered_multiset: 未排序的可重复出现的set。  map——映射 map\u0026lt;int, int\u0026gt; STL_map\nmap为关联容器。为一种体现映射关系的容器，每个关键字对应一个值。\n数据会根据键值大小关系排序（升序）。\n数据元素都是成对出现(pair)。\n每一对中的第一个值称之为关键字(key)（也称键值），每个关键字只能在map中出现一次。\n第二个称之为该关键字的对应值(value)（也称实值）。\n用法： map\u0026lt;int, string\u0026gt; STL_map; //---初始构造--- STL_map = {{1,\u0026#34;a\u0026#34;},{2,\u0026#34;b\u0026#34;}};\t//为c++11标准 //---数组操作--- STL_map[25252] = \u0026#34;niconiconi\u0026#34;;\t//如果没有对应key则插入，如果已经存在则会修改value //---对整体的操作--- STL_map.clear(); STL_map.empty(); STL_map.size(); //---对元素的操作--- \t//insert过于麻烦不予讲解。 STL_map.erase(...);\t//删除对应key的元素，成功删除返回1，否则返回0 STL_map.count(...);\t//返回对应key元素的个数【由于map不能存在重复key，故只能返回0或1 //---迭代器--- STL_map.begin(); STL_map.end(); STL_map.find(...);\t//返回查找元素的迭代器，未找到返回map::end() STL_map.lower_bound(...)\t//返回key大于等于某值的第一个元素的迭代器 STL_map.upper_bound(...)\t//返回key大于某个值元素的迭代器 自定义性： set可支持自定义类型，但需要重载\u0026lt;运算符。\n struct type //用来存棋盘状态 { ...; bool operator\u0026lt;(type x) const { return ...; } }  实现： 内部以红黑树的形式实现。\n应用场景： hash\n","date":"2020-12-03T00:00:00Z","image":"https://blog.supersassw.com/p/stl/79059953_p0_hudcdceb022a1e552a3fbecef4125cea72_897862_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/stl/","title":"STL……"},{"content":" 以下部分本地链接无法加载，需要修正…… \r 排序 不考虑算法  选择排序、冒泡排序、插入排序 $O(n^2)$ 计数排序、基数排序、桶排序 $O(n+w)$ 计数排序\n\r 希尔排序、锦标赛排序  快速排序 应用  寻找第k大的数  归并排序 应用  寻找逆序对\n可见之前笔记。\n（有关逆序对的问题还可以用树状数组或线段树来解决。）  对于逆序对问题的抽象：  询问最少经过几次（可能为相邻元素交换）交换，可使数列有序。   如果限制了为相邻元素交换，最开始很容易想到采用冒泡排序来做，但这样$O(n^2)$很容易TLE……\n发现即便是相邻交换，也是因为存在了逆序对才交换的……\n而每次交换后，能且仅能消除一个逆序对……\n要使序列达到最终有序，则肯定需要消除全部逆序对……\n故此类题目仍为求逆序对，且答案就为逆序对个数……\n 如果没有限制相邻元素交换，那么处理一位数，就能消除这位数的所有逆序对个数（与相邻交换的区别）\n所以就变成了找存在逆序对的位（简称：逆位）的个数。\n  模板题：\nP1908 逆序对  本地代码+题目分析+归并排序讲解+WA记录\n     总应用  贪心中的邻项交换排序  例题  P1774 最接近神的人  考点：归并排序、逆序对\n本地代码+题目分析+WA记录\n  SWJTU OJ-12.13 F XCPC  考点：归并排序、逆序对（没有相邻元素交换）\n题目分析\n   ","date":"2020-11-12T00:00:00Z","image":"https://blog.supersassw.com/p/sort/86036732_p0_hud48aef1ba1119480544a4ab4b9f32654_3422651_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/sort/","title":"排序……"}]