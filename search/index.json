[{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用  思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n 图片 \r\rPhoto by Florian Klauer on Unsplash\r \r\rPhoto by Luca Bravo on Unsplash\r\n\r\rPhoto by Helena Hertz on Unsplash\r \r\rPhoto by Hudai Gayiran on Unsplash\r\n![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://supersass.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://supersass.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"Shortcode的测试……\n Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\n  YouTube Privacy Enhanced Shortcode \r\r Twitter Simple Shortcode \r ","date":"2020-09-09T00:00:00Z","permalink":"https://supersass.github.io/p/test-shortcode/","title":"Shortcode Test"},{"content":"测试 啥都没有……\n","date":"2020-09-09T00:00:00Z","permalink":"https://supersass.github.io/p/test-union-find/","title":"笔记测试-并查集……"},{"content":"简介 是一种用来维护 区间信息 的数据结构。\n可以实现的操作：\n 单点、区间修改 区间查询（区间求和、最大值、最小值） 等等  描述 线段树会将一个非点区间（即长度大于$1$）利用递归的思想，二分为两个子区间来进行操作。\n这样就会将一个线段划分转化成一个树形结构。\n其中：紫色的a[]是原数组，红色的d[]是线段树：存储的区间的和，黄色范围代表管辖区间。\n每个节点会存储并维护其所管辖的区间的当前信息。（如上图存的就是区间的和）\n可根据题目要求，确定自己所需存储维护的信息。\n实现方法 提前的宏定义 #define NOW_Node node[index]\t//代表当前节点 #define NOW_LSon node[index].sonL\t//代表当前节点左儿子下标 #define NOW_RSon node[index].sonR\t//代表当前节点右儿子下标 0x00 建树 基本认识 根据上图可发现几个要点：\n 每一个节点i的左儿子下标是2i，右儿子下标是2i+1。 记：i管辖的区间为$[s,t]$。\n令：$mid=\\frac{s+t}{2}$。\n则左儿子2i管辖区间为$[s,mid]$，右儿子2i+1管辖区间为$[mid+1,t]$。  实现方法 之前已经介绍了递归的思想，那么只需要确定递归边界。\n由上图很容易看出，递归边界就是当长度为$1$的点。\n记：当前点为node[index]，代表区间为$[l,r]$。原数组为arr[]\n当$l=r$的时候，说明到达递归边界，这个时候的值直接为对应区间的值。\n也就是node[index] = arr[r]\n因为二分的操作使得递归的深度不会大于$log(n)$，故完全可以采用递归的方式简化代码，不用担心递归的栈溢出等缺点。\n储存方法 方法1、 struct typeNode { int val, L, R, mid, len;\t//val代表储存的值，L、R分别代表区间左、右端点，mid代表区间中点，len代表区间长度 }node[4*N]; 直接用左儿子下标为2i，右儿子下标为2i+1转递。\n函数为build(int index, int l, int r)，建左儿子用则为build(2*i, l, r)。\n 空间范围：反正直接把长度设置为$4n$。\n因为该线段树深度为$\\lceil log(n) \\rceil$，又因为为完全二叉树，总节点个数为$2^{\\lceil log(n) \\rceil +1}-1$。但建树的时候最后一层不一定从左往右建，也可能很右边会有一个，所以要预留出所有的最后一层的节点位置，即开$4N$。\n具体分析见关于线段树的数组到底是开2N还是4N。  方法2、 struct typeNode { int val, L, R, mid, len, sonL, sonR;\t//多了个sonL和sonR，代表左儿子的index和右儿子的index }node[2*N]; build()的时候需要多一个计数器变量cnt，记录总过有多少节点。\n函数为build(int \u0026amp;index, int l, int r)。其中传引用会在伪代码中解释。\n这里多存了个左儿子和右儿子的下标，使得可以保证从按顺序建，不会出现空间浪费，于是可以开$2N$。\n相较于方法2空间消耗会少一点。\n以下采用“方法2”的方式来储存。\n伪代码 struct typeSegment{ int cnt = 0;\t//记录node节点的数量，便可实现按顺序建树  struct typeNode{ int val, L, R, len, mid, sonL = 0, sonR = 0; } node[N * 2]; void build(int \u0026amp;index, int L, int R) //对区间[L,R]建立节点，下标为index \t{ index = ++cnt; /*引用index的原因： 这里因为引用index，在递归时会直接把seg[index].son_赋值为某儿子的index。 */ NOW_Node.L = L, NOW_Node.R = R, NOW_Node.mid = (L + R) \u0026gt;\u0026gt; 1, NOW_Node.len = R - L + 1;//节点基本信息  if (L == R) NOW_Node.val = arr[R]; //为递归边界，直接为对应区间的值 \telse { build(NOW_LSon, L, NOW_Node.mid); //划分建立左区间，注意这里传的index是sed[index].lson \tbuild(NOW_RSon, NOW_Node.mid + 1, R); //划分建立右区间 \tNOW_Node.val = node[NOW_LSon].val + node[NOW_RSon].val; //计算该区间信息 \t} } }Segment;\t//直接用个总结构体，便于模板化。//其实就是个个人癖好orz…… 0x01 区间查询 对区间进行值的条件查询，如对区间$[L,R]$求总和，求区间最值等操作。\n实现方法 将要查询的区间，拆成几个在其范围里的节点的区间进行求解计算。（类似于分块思想）\n 如果当前区间完全在查询区间的范围里，则直接返回这个区间的值。 如果不是，则分别查询左右区间计算最终值。  如果查询区间的左端点小于等于当前区间中点，则查询范围会存在于左儿子区间里，要查询左儿子。 如果查询区间的右端点大于当前区间中点，则查询范围会存在于右儿子区间里，要查询右儿子。  ⚠注意：这里为大于！因为中点是算在左区间里的！……\n     【直接给代码吧ヾ(•ω•`)o……\n伪代码 int query(int index, const int \u0026amp;q_L, const int \u0026amp;q_R) { if (q_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; q_R\u0026lt;= NOW_Node.R) return NOW_Node.val; //当前区间直接在查询区间里，直接返回值 \t//【我查了，一句返回了，有什么好说的…… \t//↓ 不完全包含于查询区间里，就要查询两子区间的值计算 \tint tmpAns = 0; if (q_L \u0026lt;= NOW_Node.mid) tmpAns += query(NOW_LSon, q_L, q_R); //如果要查询区间左端点，比当前区间的中点还大，证明左儿子区间完全不在 \tif (q_R \u0026gt; NOW_Node.mid) tmpAns += query(NOW_RSon, q_L, q_R);\t//为\u0026gt;，不是\u0026gt;= \treturn tmpAns; } 0x02 区间修改 对区间进行值的修改，如区间$[L,R]$加上或乘上一个数。\n(最初)实现方法 跟查询的方法一样，找到对应区间后直接修改值。\n但注意，如果不是长度为1的区间，值的修改要乘上对应修改区间的长度。\n 比如对$[1,2]$这个区间加上$2$。\n$[1,1]$和$[2,2]$这两个子区间会加$2$。\n但$[1,2]$则个大的区间应该加的就是$4$。\n同理，$[1,4]$这个大区间就该加$8$了。\n 缺点分析 【诶我说停停，先别着急写啊，不要啪的一下就写起来了很快啊……\n如果碰上这样的情况：\n  对区间$[1,10000]$加上$10000$次$233$。 查询区间$[23333,23333]$的值。   怎么样，有没有觉得自己被耍了！\n所以如果当老实人，他让我们修改区间，我们就老老实实修改区间，可是要吃大亏的。【指TLE……\n改进方法 所以他耍我们，我们也耍一下他xd。\n不是让我们对区间修改吗，我们就先偷下懒：不老老实实地全部修改完，只做个记号在那。\n等到他让我们真正查询这个区间的时候，我们也才真正的去修改，并返回查询值。【并且注意lazy清零！……\n这便是lazy懒标记的由来。\n但我们该怎么偷懒呢？\n 如果当前区间完全在修改区间的范围里，我们便可以按分析的那样，先把修改的值加到lazy里。等之后有需要再去真正地修改，即“下放lazy”。 如果不是，这里就需要注意，我们再直接加到lazy标记的话，有些明明不该修改的区间就会被修改。所以这里的懒就偷不得，就要真正的修改当前节点的值，并尝试修改子节点。（但如果儿子可以偷懒，就让儿子去偷懒）  如果修改区间的左端点大于当前区间中点，则不会修改左儿子区间。 如果修改区间的右端点小于等于当前区间中点，则不会修改右儿子区间。    伪代码  区间修改：  struct typeNode{ int ..., lazy;\t//这里多定义个lazy，用来存偷懒没修改的值 } void modify(int index, const int \u0026amp;m_L, const int \u0026amp;m_R, const int \u0026amp;m_val) { if (m_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; NOW_Node.R \u0026lt;= m_R) NOW_Node.lazy += m_val;\t//当前区间完全在范围里，直接偷懒 \telse { NOW_Node.val += (min(m_R, NOW_Node.R) - max(m_L, NOW_Node.L) + 1) * m_val;\t/* 这里是修改所包含区间的值 如要修改[4,9]，当前节点区间是(1,6)\t//这里为了区分用的小括号，实际上包含端点 则只会修改[4,6)，也就是val += (6 - 4 + 1) * 2 */ if (m_L \u0026lt;= NOW_Node.mid) modify(NOW_LSon, m_L, m_R, m_val); if (m_R \u0026gt; NOW_Node.mid) modify(NOW_RSon, m_L, m_R, m_val); } }  有lazy的区间查询：  struct typeNode{ ... void pushdown(typeSegment *Segment)\t//下放也不用太彻底，能摸一层是一层xd…… \t{ val += len * lazy;\tif (sonL) Segment.modify(sonL, L, mid, lazy); //存在子节点才下放【不然我这种结构就会无限下放_(:з」∠)_…… \tif (sonR) Segment.modify(sonR, mid + 1, R, lazy); lazy = 0;\t//！lazy注意清零！ \t} } int query(int index, const int \u0026amp;q_L, const int \u0026amp;q_R) { if (NOW_Node.lazy) NOW_Node.pushdown(*this);\t//注意查询的时候，只要有懒标记就必下放【别人都来查岗了你还摸鱼.jpg……  if (q_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; NOW_Node.R \u0026lt;= q_R)\t//以下跟普通的查询操作一样 \treturn NOW_Node.val; int tmpAns = 0; if (q_L \u0026lt;= NOW_Node.mid) tmpAns += query(NOW_LSon, q_L, q_R); if (q_R \u0026gt; NOW_Node.mid) tmpAns += query(NOW_RSon, q_L, q_R); return tmpAns; } Tip: 我这里的偷懒是直接连本身都先不修改，而在下放的时候才修改；其他人有些可能会先修改自身。算是个小优化，注意区分一下……\n最终代码 洛谷P3372 【模板】线段树 1\n#include \u0026lt;bits/stdc++.h\u0026gt; #define N 100000  #define NOW_Node node[index]\t//代表当前节点 #define NOW_LSon node[index].sonL //代表当前节点左儿子下标 #define NOW_RSon node[index].sonR //代表当前节点右儿子下标 using namespace std; long long arr[N + 5]; struct typeSegment { int cnt = 0; //记录node节点的数量，便可实现按顺序建树  struct typeNode { long long val; int L, R, len, mid, sonL = 0, sonR = 0, lazy = 0; void pushdown(typeSegment \u0026amp;Segment) //下放也不用太彻底，左右儿子仍加到lazy里。【能摸一层是一层xd…… \t{ val += len * lazy; if (sonL) Segment.modify(sonL, L, mid, lazy); //存在子节点才下放【不然我这种结构就会无限下放 \tif (sonR) Segment.modify(sonR, mid + 1, R, lazy); lazy = 0; //lazy注意清零。 \t} } node[N * 2]; void build(int \u0026amp;index, int L, int R) //对区间[l,r]建立节点，下标为index \t{ index = ++cnt; //引用原因： \t//这里因为引用index的原因，在递归时会直接把seg[index].lson赋值为左儿子的index。 \tNOW_Node.L = L, NOW_Node.R = R, NOW_Node.mid = (L + R) \u0026gt;\u0026gt; 1, NOW_Node.len = R - L + 1; //节点基本信息 \tif (L == R) NOW_Node.val = arr[R]; //为递归边界，直接为对应区间的值 \telse { build(NOW_LSon, L, NOW_Node.mid); //划分建立左区间，注意这里传的index是sed[index].lson \tbuild(NOW_RSon, NOW_Node.mid + 1, R); //划分建立右区间 \tNOW_Node.val = node[NOW_LSon].val + node[NOW_RSon].val; //计算该区间信息 \t} } void modify(int index, const int \u0026amp;m_L, const int \u0026amp;m_R, const int \u0026amp;m_val) { if (m_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; NOW_Node.R \u0026lt;= m_R) NOW_Node.lazy += m_val; //当前区间完全在范围里，直接偷懒。 \telse { NOW_Node.val += (min(m_R, NOW_Node.R) - max(m_L, NOW_Node.L) + 1) * m_val; /* 这里是修改所包含区间的值 如要修改[4,9]，当前节点区间是(1,6)\t//这里为了区分用的小括号，实际上包含端点 则只会修改[4,6)，也就是val += (6 - 4 + 1) * 2 */ if (m_L \u0026lt;= NOW_Node.mid) modify(NOW_LSon, m_L, m_R, m_val); if (m_R \u0026gt; NOW_Node.mid) modify(NOW_RSon, m_L, m_R, m_val); } } long long query(int index, const int \u0026amp;q_L, const int \u0026amp;q_R) { if (NOW_Node.lazy) //注意查询的时候，只要有懒标记就必下放【别人都来查岗了你还摸鱼.jpg…… \tNOW_Node.pushdown(*this); if (q_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; NOW_Node.R \u0026lt;= q_R) return NOW_Node.val; //当前区间直接在查询区间里，直接返回值//【我查了，一句返回了，有什么好说的……  //↓ 不完全包含于查询区间里，就要查询两子区间的值计算 \tlong long tmpAns = 0; if (q_L \u0026lt;= NOW_Node.mid) tmpAns += query(NOW_LSon, q_L, q_R); //如果要查询区间左端点，比当前区间的中点还大，证明左儿子区间完全不在 \tif (q_R \u0026gt; NOW_Node.mid) tmpAns += query(NOW_RSon, q_L, q_R); return tmpAns; } } Segment; //直接用个大的结构体，便于模板化。 int main() { int n, m, tmp, w, l, r, i; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;arr[i]); Segment.build(tmp, 1, n); //Segment.test(1); \twhile (m--) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;w); if (w == 1) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;i); Segment.modify(1, l, r, i); } else { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); printf(\u0026#34;%lld\\n\u0026#34;, Segment.query(1, l, r)); } } } ","date":"2020-09-09T00:00:00Z","permalink":"https://supersass.github.io/p/test-segment-tree/","title":"笔记测试-线段树……"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike1 Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code    Code Blocks Code block with backticks \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","date":"2019-03-11T00:00:00Z","image":"https://supersass.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://supersass.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\n Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude  Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\n Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et  Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://supersass.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://supersass.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so:  {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }}  To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files  Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://supersass.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\n N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; }","date":"2019-03-05T00:00:00Z","image":"https://supersass.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://supersass.github.io/p/emoji-support/","title":"Emoji Support"}]