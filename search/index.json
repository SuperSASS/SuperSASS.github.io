[{"content":"离散化介绍 离散化，就是将一组离散的数据，映射成集中的数据。【所以个人觉得应该叫集中化【？……\n其思想跟哈希(Hash)类似。\n当有些数据因为本身很大或者类型不支持，自身无法作为数组的下标来方便地处理，\n而影响最终结果的只有元素之间的相对大小关系时，\n我们可以将原来的数据按照从大到小编号来处理问题，即离散化。\n\r 引自：OI-Wiki「离散化」\n常用来离散化类型的是：大整数、浮点数、字符串。\n情况举例 本身很大情况 最常见的题比如：  判断在$N$个数中，某数$a_i$是否存在。 \r\n很简单的思路就是：\n用个布尔数组bool exist[]来记录某数是否存在。\n但如果数据范围是$1 \\le N \\le 10^5, 0 \\le a_i \\le 10^9$，\n也就是：数的个数$N$远小于数的范围$a_i$时，\n很明显，如果直接用$a_i$作下标来记录，会导致数组开不下。\n 而对于这道题，$a_i$的值是多少，并没有太大意义，我们只用关心它出现没有。\n因此我们可以把这些分散的$a_i$按大小顺序重新编号。\n举例\r5个数，其分别为：\n9463 1 233333333 78 5 此时如果直接以下标来存储，数组就要开为bool exist[233333333 + 5];。\n 将其重新编号（映射）为：\n4 1 5 3 2 此时数组就可以开为bool exist[5 + 5];。\n\r 类型不支持情况 将题改为：  $N$个字符串，判断某字符串$s_i$是否存在。 \r\n这个时候甚至直接不能作为bool exist[]数组下标了。\n 可以将其映射为能作为下标的数字。\n要查找某字符串，用该映射函数将所寻字符串映射为数字ID，\n然后直接看exist[ID]是否为$true$即可。\n实现方法 思路 上面介绍说到：离散化后的数据只与相互间大小关系有关。\n所以对于原数据要先放在另一个容器中排序，得到他们之间的大小关系。\n然后该容器中需要去除重复元素，来最大程度节省空间。\n 比如原数据为$100$个$8$和$1$个$9$。\n如果不去重，离散化后$8$会映射为$1$，而$9$会映射为$101$，\n去重过后，$8$会映射为$1$，$9$则会映射为$2$了。\n 这样过后便得到了原数据与新数据的一一映射关系表。\n这个时候再将原数据按表全部替换，完成离散化。\n 所以离散化一共有三个重要操作：\n 对原数据放到另一个容器，并按大小关系排序。 去除排好序后容器的重复元素，得到一一映射关系。 按照一一映射关系，将原数据替换为新数据。  举例\r原数据为：\n98 783 1 23333 1 57 912 5 1 98 排序后为：\n1 1 1 5 57 98 98 783 912 23333 去重后为：\n1 5 57 98 783 912 23333 则得到一一映射关系表：\n   原数据 新数据     1 1   5 2   57 3   98 4   783 5   912 6   23333 7    替换后，即离散化为：\n4 5 1 7 1 3 6 2 1 4 \r 具体实现 一、大整数离散化 去重操作使用到的是unique函数，\n映射关系表对应，则用lower_bound这个查找函数。\n有关这两个函数的详细信息，可以百度查阅相关资料。\n 代码：\nint raw[MAX_N + 5], //原数据  n, //原数据个数  cont[MAX_N + 5], //临时容器  disc[MAX_N + 5]; //离散化后数据  void discrete() { memcpy(cont, raw, (n + 1) * sizeof(int)); //1. 原数据放入另一容器  sort(cont + 1, cont + n + 1); //1. 排序  int disc_len = unique(cont + 1, cont + n + 1) - cont - 1; //2. 去重，并得到去重后的有效长度（运用的是数组地址相减代表长度）。  for (int i = 1; i \u0026lt;= n; i++) //3. 按照一一映射关系，得到离散化序列  disc[i] = lower_bound(cont + 1, cont + disc_len + 1, raw[i]) - cont; //利用lower_bound找到原数据在cont数组中的地址，减去cont头地址后得到离散结果（即cont中下标） }  运行结果：\n 没有重复数据：\n\r大整数离散化 - 示例1\r 有重复数据：\n\r大整数离散化 - 示例2\r  二、字符串离散化 【由于暂时没做到相关的题就没做总结2333……\n这里就跟字符串哈希的操作是一样的了，\n可以查看OI-Wiki上的「字符串哈希」。\n其他事项 不去重情况 有时候根据题目要求，相同元素可能会有作用。 如下面的问题：  对于数组$a[i]$，问两区间$(l_1,r_1),(l_2,r_2)$间有多少个相同元素。 \r\n如要使用较快的：“bitset+取并集”的操作，\n这里离散化的时候就不要去重，\n并采用以下技巧： 用个$cnt[i]$数组，记录$a_i$在bitset数组$bit[]$出现的次数，\n当出现$a_n$时，则使$bit[a_n+cnt[a_n]]++$。\n\r\n这样，出现了几个$a_n$，就会在$bit[]$中存几个，\n取交集的时候就能直接得到个数了。\n 不去重的原因，是使得相邻两元素离散后的值有差距，\n其差距就是该数出现的次数【见上方「本身很大情况」中举的例子】\n而去重后，两值间则不会有差距，\n无法通过这种方法来存储所有出现的$a_n$。\n ","date":"2021-03-04T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-discrete/Yande-312234_hu74e31cf7a8be9f78c1abc828bcffbc8e_3268181_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-note-discrete/","title":"ACM学习笔记：离散化……"},{"content":"简介 属于离线算法中的一种。\n用来解决离线区间询问问题，\n将其加以扩展后，还可以解决树上路径询问问题和支持修改操作。\n使用条件 须满足以下条件：\n对于区间$[l,r]$，\n其查询后的答案，能够在$O(1)$扩展到其相邻区间的答案。\n 即：\n$[l-1,r]$、$[l+1,r]$、$[l,r-1]$、$[l,r+1]$这四个区间\n 实现 如果满足使用条件后，\n自然而然就能想到这种解题方法：\n 根据上一个询问，一步步扩展到当前询问。 \r 这就是莫队算法中最基本的解题思路，\n这样一直扩展下去，就能得到所有询问的答案。\n 但如果就按照题中给的询问顺序，一个个挨着扩展的话，\n肯定会造成大量的重复移动操作。\n e.g.\n99 100 1 2 99 100 1 2 99 100 每次l和r都会从一端极值移动到另一端极值。\n 不排序直接求解，易得其复杂度为$O(n^2)$。\n 因此莫队算法的核心则是：\n我们应该怎样对询问排序，使得这一步步扩展的操作次数尽量少。\n也就是该如何定义排序算法。\n排序算法 1. 直接排序 首先自然而然想到的排序算法就是：\n 直接按照询问的l和r为主次关键字进行排序。 \r\n结构体的\u0026lt;定义为：\nstruct queryType_direct { int l, r, id; bool operator\u0026lt;(const queryType_direct \u0026amp;a) const { return l == a.l ? r \u0026lt; a.r : l \u0026lt; a.l; } //当l不同时，l小的排在前面； \t//当l相同时，r小的排在前面。 } direct[MAX_M + 5];  但这样排序算法十分粗糙，\n其复杂度仍为$O(n^2)$，仅常数小一些而已，\n很容易TLE。\n 复杂度大致计算方式：\n以这种排序方法，\nl为升序，所以移动次数最坏为$n$，\nr最坏情况为反复在两端点间移动，移动次数为$\\frac{(n-2)n}{2}$（等差数列计算）。\n总移动次数最坏为$\\frac{n^2}{2}$，\n故复杂度为$O(n^2)$。\n 2. 分块排序 为最有效又简单的排序算法。\n具体方法为：\n将$n$个询问分为$M$个块。\n对于同一个块，按照r的大小排序，\n对于不同的块，则按照l的大小排序。\n\r\n结构体的\u0026lt;定义为：\nint BLOCK_SIZE; struct queryType_block { int l, r, id; bool operator\u0026lt;(const queryType_block \u0026amp;a) const { return l / BLOCK_SIZE == a.l / BLOCK_SIZE ? r \u0026lt; a.r : l \u0026lt; a.l; } //当 l/BLOCK_SIZE == r/BLOCK_SIZE 时，为同一块，按照r的大小排序； \t//不为同一块时，按照l的大小排序。 } block[MAX_M + 5]; 而块的大小BLOCK_SIZE，一般取为$\\sqrt{n}$。\n 虽然看起来很粗糙，与直接排序的区别十分小（就多了个/BLOCK_SIZE），\n但其复杂度却能显著的降到$O(n\\sqrt{n})$。\n 复杂度计算方式：\nOI-Wiki上的证明方法太多了懒得看x，这里用另一种很不严谨的方式来说明orz……\n同一块中，询问个数和块的长度均为$\\sqrt{n}$，\nl最坏情况也为反复在两极值端点间振荡，但端点距离变为了$\\sqrt{n}$，移动次数大致为$\\sqrt{n}*\\sqrt{n}=n$，\nr为递增，所以最坏情况移动次数为$n$，\n跨块的时候，\nl最坏移动$\\sqrt{n}$次，\nr最坏移动$n$次，\n所以每一块（同时算上同一块和跨块的移动操作）移动次数大致为$3n+\\sqrt{n}$，\n一共$\\sqrt{n}$块，\n故最坏情况，总移动次数为$3n\\sqrt{n}+n$。\n即复杂度为$O(n\\sqrt{n})$。\n 2.(1). 分块的优化——奇偶化排序 对于这组已排好序的数据： （令：n为100，即BLOCK_SIZE为$10$）\n 1 1 2 100 10 11 11 100  如果就按照这样的顺序进行操作，\n在第二步r为$100$后，\n执行第三步会跳到$11$，执行第四步又会跳到$100$。\n而将顺序改为：\n 1 1 2 100 11 100 10 3  则能减少从一极值跳到另一极值的情况。\n 也就是说，对于第二种“分块排序”方法：\n在执行完某一块跳到下一块的时候，\nr会从当前块的最大值，唐突移动到下一块的最小值，\n从则造成多余的移动操作。\n而如果将奇数块改为从小到大排序，偶数块改为从大到小排序，\n则在跳块的时候，能很平滑的从这一块最大过渡到下一块最大。\n这种优化能使程序快$30%$。\n结构体的\u0026lt;定义为：\nint BLOCK_SIZE; struct queryType_block_pro { int l, r, id; bool operator\u0026lt;(const queryType_block_pro \u0026amp;a) const { return l / BLOCK_SIZE == a.l / BLOCK_SIZE ? (r == a.r ? 0 : (l / BLOCK_SIZE \u0026amp; 1) ^ (r \u0026lt; a.r)) : l \u0026lt; a.l; } //这里运用位运算，实现了当为奇数块时从小到大排序，偶数块时从大到小排序。 } block_pro[MAX_M + 5]; \r注意：需要特判r == a.r的情况！\n否则对于两询问$a,b$，\n其l属于同一奇数块，且r相等的情况，\n排序时会同时满足$a\u0026lt;b$和$b\u0026lt;a$，\n使得sort()出错。\nsort出错原因是因为其要满足严格弱序，\n有关严格弱序的介绍可以看这里写的「ACM学习笔记：邻项比较排序……」文章中有提及。\n\r\r\r  理解不了压行写法的话，也可以看OI-Wiki上的不压行写法。 \r 3*. 曼哈顿最小生成树排序 其实最优的排序方法，是构造曼哈顿最小生成树。\n一种方法是把所有区间$[l,r]$看成平面上的点$(l,r)$，并对所有点建立曼哈顿最小生成树，\n每次沿着曼哈顿最小生成树的边在询问之间转移答案。\n\r 引自：OI-Wiki。\n但其复杂度其实也是$O(n\\sqrt{n})$，\n故一般都采用最简单的分块排序。\n【个人也完全不会这个排序方法就不写了_(:з」∠)_……\n操作次数比较 以莫队模板题“P1494 小Z的袜子”来进行比较。\n当$n,m$较大时：\n 输入数据（$n=50000,m=50000$）链接。 \r \r三种排序操作次数对比 - n,m较大\r\n \u0026ldquo;Raw\u0026rdquo;：未排序直接操作。 \u0026ldquo;Direct\u0026rdquo;：直接排序。 \u0026ldquo;Block\u0026rdquo;：分块排序。 \u0026ldquo;Block Pro\u0026rdquo;：分块排序+奇偶化。   但注意：\n分块排序的操作次数不一定恒小于直接排序。\n当$n,m$较小时，很有可能反而大于直接排序。\n 输入数据（$n=10,m=15$）链接。 \r \r三种排序操作次数对比 - n,m较小\r\n可以发现反而直接排序操作次数更少。\n但由于当$n,m$较大时，这种情况几乎不存在，\n所以可以不用考虑。\n注意事项 排完序后，会破坏原有询问的顺序，\n故要加个id变量，来存储原询问的顺序。\n\r 移动操作 当排好序过后，关键就是：\n如何通过现在求得的$(l,r)$区间的答案$ans$，\n一步步移动l和r，\n来求得新区间$(l',r')$的答案$ans'$。\n 需要先根据题目分析，\n来计算出增加或删除某个元素，对答案的影响。\n然后用while判断，一步步l++、l--、r++、r--，\n得到新询问区间的答案。\nwhile的位置很重要，不能随意调换他们的位置。\n可以简单记住以下三种正确顺序：\n l--, r--, r++, l++ l--, r++, l++, r-- l--, r++, r--, l++  【l--和--l一样，只要l的加减与r的加减顺序对了就行。\n有关证明，可见OI-Wiki上的「关于四个循环位置的讨论」。\n\r 总模板 int BLOCK_SIZE; struct queryType { int l, r, id; bool operator\u0026lt;(const queryType_block_pro \u0026amp;a) const { return l / BLOCK_SIZE == a.l / BLOCK_SIZE ? (r == a.r ? 0 : (l / BLOCK_SIZE \u0026amp; 1) ^ (r \u0026lt; a.r)) : l \u0026lt; a.l; } //分块+奇偶化 } query[MAX_M + 5]; inline void move(int pos, int sign, int \u0026amp;nowAns) //sign=1代表增加，sign=-1代表减少。 { // update nowAns } void solve() { BLOCK_SIZE = sqrt(n); sort(query + 1, query + m + 1); int nowL = 1, nowR = 0, nowAns = 0; #define L query[i].l #define R query[i].r #define ID query[i].idid  for (int i = 1; i \u0026lt;= m; i++) { while (nowL \u0026gt; L) move(--l, 1, nowAns); while (nowR \u0026lt; R) move(r++, 1, nowAns); while (nowL \u0026lt; L) move(l++, -1, nowAns); while (nowR \u0026gt; R) move(--r, -1, nowAns); ans[ID] = nowAns; } } 例题  P1494 小Z的袜子\n题解可见「ACM练习——P1494 小Z的袜子……」。  ","date":"2021-03-01T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-mo_algo/85829025_p0_hud48d475653a68121c5c5dd4c9c15f623_2139511_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/acm-note-mo_algo/","title":"ACM学习笔记：莫队算法……"},{"content":"题目链接 P1494 小Z的袜子\n题目分析 标准的莫队模板题。\n 有关莫队的知识点可以看个人笔记「ACM学习笔记：莫队算法……」 \r 则分析这道题的具体移动操作。\n对于当前状态$[l,r]$区间，记：\n $cnt[i]$为当前某颜色的出现次数， $ans$为当前答案（抽到两只颜色相同的袜子的情况总数）。   当扩展区间(l--,r++)时，记增加的颜色为$c$，\n那么其跟当前区间$[l,r]$中，颜色相同的袜子都能配对。\n也就是说，其贡献的满足情况数为$cnt[c]$，\n即ans += cnt[c]。\n e.g.\n当前区间为$[1,6]$，袜子颜色分别为$A,A,B,B,B,C$【为了更好区分，将颜色用字母暂时代替】，\n则答案$ans$为$4$。\n若向右扩展区间，新增加的$7$号袜子颜色为$A$，\n袜子变为$A,A,B,B,B,C,A$。\n则其跟之前的$2$个颜色为$A$的袜子均能配对，\n所以贡献答案为$cnt[A]$为$2$，$ans += 2$，\n则新的$ans$等于$6$。\n 然后cnt[c]++。\n 当缩短区间(l++,r--)时，记删去的颜色为$c$，\n那么其跟当前区间$[l,r]$中，颜色相同的其他袜子都不能再配对。\n也就是说，其损失的满足情况数为$cnt[c]-1$，\n即ans -= cnt[c] - 1。\n然后cnt[c]--。\n 再次优化（压行），则可得出最终的两个move操作函数。\n扩展函数：\ninline void add(const int \u0026amp;color, LL \u0026amp;ans) { ans += cnt[color]++; } 缩短函数：\ninline void dec(const int \u0026amp;color, LL \u0026amp;ans) { ans -= --cnt[color]; }  最后在重点注意一下move时：++和--的前后位置（是l++还是++l），\n在草稿本上自己模拟走一遍就能知道了。\n以及再注意下约分的问题，\n无了。\n个人代码  Pastebin链接。 \r //P1494 [小Z的袜子](https://www.luogu.com.cn/problem/P1494) #include \u0026lt;bits/stdc++.h\u0026gt;#define ALL(NAME_i, BEGIN, TO) \\ int NAME_i = BEGIN; \\ NAME_i \u0026lt;= TO; \\ NAME_i++ #define ALL_invert(NAME_i, BEGIN, TO) \\ int NAME_i = BEGIN; \\ NAME_i \u0026gt;= TO; \\ NAME_i-- typedef long long LL; using namespace std; #define MAX_N 50000 #define MAX_M 50000  int color[MAX_N + 5], cnt[MAX_M + 5], BLOCK_SIZE; //cnt-当前状态各颜色出现了多少次 LL nume[MAX_M + 5], deno[MAX_M + 5]; //nume-分子，deno-分母  struct queryType { int l, r, id; //bool operator\u0026lt;(const queryType \u0026amp;a) const { return l == a.l ? r \u0026lt; a.r : l \u0026lt; a.l; } //直接排序  //bool operator\u0026lt;(const queryType \u0026amp;a) const { return l / BLOCK_SIZE == a.l / BLOCK_SIZE ? r \u0026lt; a.r : l \u0026lt; a.l; } //分块排序  bool operator\u0026lt;(const queryType \u0026amp;a) const { return l / BLOCK_SIZE == a.l / BLOCK_SIZE ? (r == a.r ? 0 : (l / BLOCK_SIZE \u0026amp; 1) ^ (r \u0026lt; a.r)) : l \u0026lt; a.l; } //分块排序+奇偶性优化 } query[MAX_M + 5]; inline LL C(const int \u0026amp;n, const int \u0026amp;m) //组合数计算函数 { LL ans = 1; for (int i = n; i \u0026gt;= n - m + 1; i--) ans *= i; for (int i = 2; i \u0026lt;= m; i++) ans /= i; return ans; } inline LL GCD(const LL \u0026amp;a, const LL \u0026amp;b) { return b ? GCD(b, a % b) : a; } inline int intRead() { int f = 1, num = 0; char t = getchar(); while (t \u0026lt; \u0026#39;0\u0026#39; || t \u0026gt; \u0026#39;9\u0026#39;) f = t == \u0026#39;-\u0026#39; ? -1 : f, t = getchar(); while (t \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; t \u0026lt;= \u0026#39;9\u0026#39;) num = num * 10 + t - \u0026#39;0\u0026#39;, t = getchar(); return f * num; } inline void add(const int \u0026amp;color, LL \u0026amp;ans) { ans += cnt[color]++; } //增加某一颜色的move操作 inline void dec(const int \u0026amp;color, LL \u0026amp;ans) { ans -= --cnt[color]; } //减少某一颜色的move操作  int main() { int n = intRead(), m = intRead(); BLOCK_SIZE = sqrt(n); for (ALL(i, 1, n)) color[i] = intRead(); for (ALL(i, 1, m)) query[i].l = intRead(), query[i].r = intRead(), query[i].id = i; sort(query + 1, query + m + 1); int now_l = 1, now_r = 0; //这里初值l=1,r=0，可以想想为什么。  LL now_nume = 0; #define L query[i].l #define R query[i].r #define ID query[i].id  for (ALL(i, 1, m)) if (L == R)\t//L==R情况的特判  nume[ID] = 0, deno[ID] = 1; else { while (now_l \u0026gt; L) add(color[--now_l], now_nume); while (now_r \u0026lt; R) add(color[++now_r], now_nume); while (now_l \u0026lt; L) dec(color[now_l++], now_nume); while (now_r \u0026gt; R) dec(color[now_r--], now_nume); //注意这里++和--的前后位置！  nume[ID] = now_nume; if (now_nume) { deno[ID] = C(R - L + 1, 2); LL gcd = GCD(nume[ID], deno[ID]); nume[ID] /= gcd, deno[ID] /= gcd; //约分操作  } else deno[ID] = 1; //如果计算出ans是0，需要特判，否则求GCD会出错  } for (ALL(i, 1, m)) printf(\u0026#34;%lld/%lld\\n\u0026#34;, nume[i], deno[i]); } ","date":"2021-03-01T00:00:00Z","image":"https://blog.supersassw.com/p/acm-prac-2021_03_01/87513233_p0_hu1cd82d89b6635953dfff4fbbec4eda5e_886459_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/acm-prac-2021_03_01/","title":"ACM练习——P1494 小Z的袜子……"},{"content":" 以下为涅普计划的课程笔记，建议搭配课程视频理解。 \r 0x00 课程视频 课程视频\r\r\r视频Bilibili链接\r 0x01 什么是密码学 【基本概念与作用应该都知道一点吧，这里不做基础介绍了_(:з」∠)_……\n 古典密码学主要关注信息的保密书写和传递，以及与其相应的破译方法。\n现代密码学不只关注信息保密问题，\n还同时涉及信息完整性验证、信息发布的不可抵赖性、以及在分布式计算中产生的来源于内部和外部的攻击的所有信息安全问题。\n CTF中的古典密码学题目有时也会出现在杂项里面，\n古典加密常常不给出加密算法，需要判断或者尝试一下。\n而CTF中的现代加密常常会给出加密算法，或者以一些形式提示某种常用的加密算法。\n即通过公开的加密算法和题目给的条件来思考解密的算法并加以实现。\n 密码学描述中，对传输者和窃取者有习惯名称。\n\r什么是密码学 - 名称约定\r\n 可以用数学中的函数形式来表达加密解密的过程。\n\r什么是密码学 - 数学表示\r\n $k$代表密钥，$m$代表明文，$c$代表密文。 $E$代表加密函数，$D$代表解密函数。 加密过程为：$c=E(k,m)$ 解密过程为：$m=D(k,c)$  0x02 凯撒加密 定义 凯撒加密(Caesar Cipher)是一种最简单且最广为人知的加密技术，它属于替代加密，\n明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。\n按密匙进行移位后，可以得到一张一一对应的密码表，\n基本的加密解密过程都可以通过查表来完成。\n\r凯撒加密 - 密码表\r\n外圈对应明文，内圈对应密文。\n加密时：将明文字母一一替换成内圈字母，\n解密时：将密文字母一一替换成外圈字母。\n  类型：单表替代加密。 加密对象：一般为字母。 加密方式：字母按偏移量（密钥）移位。 安全性：非常差。\n密钥只有25种情况，很轻易就能枚举出来。  加密脚本 from string import ascii_uppercase Plaintext = \u0026#34;game.granbluefantasy.jp\u0026#34; # 在这里输入明文 Key = 3 # 在这里输入密钥 Plaintext = Plaintext.upper() # 为了加密过程简单，将字符串字母全转换为大写 def Encrypt(Plaintext, Key): # 加密函数，操作为减少偏移量 Ciphertext = \u0026#34;\u0026#34; for i in Plaintext: if i not in ascii_uppercase: Ciphertext += i else: Ciphertext += chr(((ord(i) - ord(\u0026#34;A\u0026#34;) - Key) % 26) + ord(\u0026#34;A\u0026#34;)) return Ciphertext print(Encrypt(Plaintext, Key)) # 直接输出加密结果 运行结果：\n\r凯撒加密 - 加密示例\r\n爆破脚本 由于密钥情况很少，可以直接爆破枚举出来，\n观察找出有意义的字符串，则为明文。\nfrom string import ascii_uppercase Ciphertext = \u0026#34;DXJB.DOXKYIRBCXKQXPV.GM\u0026#34; # 在这里输入密文 Ciphertext = Ciphertext.upper() def Decrypt(Ciphertext, Key): # 解密函数，假定加密过程为减少偏移量 Plaintext = \u0026#34;\u0026#34; for i in Ciphertext: if i not in ascii_uppercase: Plaintext += i else: Plaintext += chr(((ord(i) - ord(\u0026#34;A\u0026#34;) + Key) % 26) + ord(\u0026#34;A\u0026#34;)) return Plaintext for Key in range(26): # 爆破密钥，范围为0~26 print(\u0026#34;Key = \u0026#34;, Key, \u0026#34;---\u0026gt;\u0026#34;, Decrypt(Ciphertext, Key), sep=\u0026#34;\u0026#34;) 运行结果：\n\r凯撒加密 - 解密示例\r\n可以发现Key = 3时，\n出现了一串有意义的字符串GAME.GRANBLUEFANTASY.JP。\n注意这里的密钥不一定正确，\n因为加密过程可能为增加偏移量，也可能为减少。\n但密钥对我们来说并不重要，所以不用在意其正确性。\n\r 0x03 关键词加密 定义 关键词加密(Keyword Cipher)也是一种单表替代加密，与凯撒加密不同之处在于密钥可以更为复杂。\n加密时需要选择一个关键词，\n如果这个关键词有重复的字母，去除除第一次出现之外的所有的相同的字母。\n e.g.\n如果选定的关键词为“success”，则使用“suce”。\n 将该关键词写在字母表的下方，并用字母表的其他字母按标准的顺序填写余下的空间，\n这样就构建了字母一一对应关系的密码表。\n加密时用下面一行中的字母对应替换上面一行的字母；\n解密时用上面一行中的字母对应替换下面一行的字母。（也可能反过来）\n  类型：单表替代加密。 加密对象：一般为字母。 加密方式：用关键词（密钥）生成密码表，然后按照密码表替换字母。 安全性：一般。\n密钥不能轻易枚举出来，\n但通过密码分析可能破译出密码。  示例 生成密码表 假定关键词为angstromcf。\n则生成密码表如图：\n\r关键词加密 - 生成密码表\r\n上面一行为标准的字母表。\n下面一行先将关键词angstromcf填上，\n然后将剩余未出现的字母，按照顺序填入。\n加密 对于明文：actf{yum_delicious_salad}。\n定加密的替换方式为：上面一行替换下面一行，\n即：将明文中的上面一行中的字母，对应替换成下面一行的字母。\n e.g.\n第一个a字母，替换成a，\n第二个c字母，替换成g，\n第三个t字母，替换成q。\n 则得到密文：agqr{yue_stdcgciup_padas}。\n解密 对于密文：agqr{yue_stdcgciup_padas}。\n由于加密时为上面一行替换下面一行，\n所以解密的替换方式为：下面一行替换上面一行，\n即：将密文中的下面一行中的字母，对应替换成上面一行的字母。\n e.g.\n第一个a字母，替换成a，\n第二个g字母，替换成c，\n第三个q字母，替换成t。\n 则得到明文：actf{yum_delicious_salad}。\n0x04 仿射加密  「这个比前面的要稍微复杂一点。」 —— Am473ur \r 比较复杂的加密方法，因为涉及到一定的数学知识。\n定义 在仿射加密中，如果只对字母加密（注意这个前提），\n则每个字母都对应一个数字（字母a~z分别对应数字0~25）。\n密钥为：$0\\sim25$之间的数字对$(a,b)$。\n其中$a$与$26$的最大公约数必须为$1$，$\\gcd(𝑎, 26) = 1$\n即$a$与$26$互素。\n e.g.\n$a = 5$就可以，\n因为只有$1$能整除$5$和$26$，$\\gcd(5, 26) = 1$。\n$a = 2$就不可以，\n因为$\\gcd(2, 26) = 2$。\n 记：$p$为明文字母对应的数字，$c$为密文字母对应的数字。\n 加密算法为： $$c \\equiv a \\cdot p + b \\pmod{26}$$ 需要注意是计算完$a \\cdot p + b$再取模。\n也就是代码为(a*p+b)%26，而不是a*p+(b%26)。\n\r 解密算法为： $$p \\equiv a^{-1} \\cdot (c-b) \\pmod{26}$$ 其中$a^{-1}$代表$a$的逆元。  特别的：当$a=1$时，这种加密方法就是凯撒加密，其中$b$就是偏移量。\n 需注意这种方法的加密对象也可能包括数字等其他符号。\n 其实前面的加密方法也可以包括其他字符。\n比如凯撒加密，只需要把012接在xyz后面参与加密即可。\n 如加密方式为+2，\n则明文abc xyz 012 789，加密为cde z01 234 9ab。\n 不过前面的加密方式一般均为字母，\n而仿射加密则有可能包含数字（如后面的例题）。\n 只需要把其他字符也对应一个相应的编号即可。\n甚至可以就用ASCII码表，就可以加密所有ASCII表中的字符了。\n e.g.\n对于a这个字符，转化为数字97，\n假设通过加密算法运算，得到结果为33，转化为字符!。\n则将a加密为!。\n对于7这个字符，转化为数字55,\n假设通过加密算法运算，得到结果为83，转化为字符S。\n则将7加密为S。\n那么对于字符串Nico2333...，\n其中所有的字符都可以加密，而不只是针对字母加密，\n加密结果如6$Ja8www(((。\n 然后对于要加密的字符表中，总字符个数为$m$个，\n那么$a$和$b$的取值范围$0 \\sim (m-1)$，满足$\\gcd(a,m)=1$\n同时模数为$m$。\n因此真正加密算法应该是： $$c \\equiv a \\cdot p + b \\pmod m$$ 其中$m$代表字符个数，\n$a∈(0,m-1), b∈(0,m-1)$，且需满足$\\gcd(a,m)=1$。\n  类型：单表替代加密。 加密对象：字母、数字等均可。 加密方式：将每个符号转换为数字$p$后，通过公式计算$c \\equiv a \\cdot p + b \\pmod{26}$，再将$c$转换为对应符号。 安全性：较差。\n若加密对象只为字母，且为一层仿射加密，则情况数为$12\\times26 - 1 = 311$种，也可以枚举得到。\n若情况种数较多，仍可能通过密码分析破译出密码。  方法原理  以下部分设计较多的数论知识，如只用来做题可以不必详细了解原理。 \r 仿射加密原理\r对于这些古典加密方法，\n最重要的就是加密函数需要满足一一对应关系，即为双射函数，\n这样才能保证加密后可以正确解密。 【如果为一对多或多对一，那么加密后解密则会造成混乱，因为不存在反函数。\n首先将符号映射成一个唯一数字（编号），\n经过加密算法运算后，\n因为这个加密算法为线性方程$ax+b$，并且最终会对字符个数$m$取模，\n这样可以保证运算后的结果仍在字符集编号范围中，可以转换为对应符号。\n但注意这样运算后，并不能确保为一一对应关系，\n e.g.\n字符集只有四个，即$m=4$，编号为$0,1,2,3$，\n取$(a,b)=(2,1)$，\n经过加密算法$c \\equiv a \\cdot p + b \\pmod m$\n对于$0$，运算后为$1$，\n对于$1$，运算后为$3$，\n对于$2$，运算后为$1$，\n对于$3$，运算后为$3$。\n则并不为一一对应关系，通过密文无法得到明文。\n 而要确保为一一对应，即使加密算法为双射函数，\n则需要满足$\\gcd(a,m)=1$，即$a,m$互质。\n对于以下证明，可能需要先了解有关同余和线性同余方程的相关知识，\n可以查看本博客的文章ACM学习笔记：线性同余方程……中的“前提知识”和“初步认识”章节。\n 证明：\n要证明当$\\gcd(a,m)=1$时，函数$E(p)=(a \\cdot p + b) \\bmod m$为双射函数，\n可以采用反证法。\n  反证多对一不成立：\n假设存在$p_1,p_2 \\in [0, m-1]$，且$p_1 \u0026lt; p_2$，\n满足$a \\cdot p_1 + b \\equiv C \\pmod m$，$a \\cdot p_2 + b \\equiv C \\pmod m$，\n即：$a \\cdot p_1 + b \\equiv a \\cdot p_2 + b \\pmod m$。\n则有： $$a \\cdot p_1 + b + m \\cdot n = a \\cdot p_2 + b (n \\in N^+)$$ $$a \\cdot (p_2 - p_1) = m \\cdot n (n \\in N^+)$$ $∵p_2 - p_1 \\in N^+$ $$p_2 - p_1 = a \\mid (m \\cdot n)$$ 由定义可知：\n$∵\\gcd(a, m) = 1$\n即$m$不能被$a$整除，\n所以只能是$n$为$a$的整数倍，才能使得$a \\mid (m \\cdot n)$。\n$∴n / a \u0026gt;= 1$\n$∴p_2 - p_1 \u0026gt;= m$\n$∴p_1$和$p_2$不可能同在$[0,m-1]$范围内，与假设矛盾，故不成立。\n  反证一对多不成立：\n假设存在$C_1, C_2 \\in [0, m-1]$，且$C_1 \u0026lt; C2$，\n满足$a \\cdot p + b \\equiv C_1 \\pmod m$，$a \\cdot p + b \\equiv C_2 \\pmod m$，\n即：$C_1 \\equiv C_2 \\pmod m$。\n则有：\n$$C_1 + m \\cdot n = C_2 (n \\in N^+)$$\n$∴C_2 - C_1 \u0026gt;= m$，\n$∴C_1$和$C_2$不可能同在$[0,m-1]$范围内，与假设矛盾，故不成立。\n  由此可知，该函数只能为一一对应，即为双射函数。\n 参考自\u0026quot;hahastudio\u0026quot;在V2EX上对 「数论，加密，仿射变换后唯一性问题」问题的回答。\n 满足了为双射函数，还有一个重要的点就是：\n该函数的反函数容易求得。\n否则也不能轻易地解密。\n而这个求余操作的反函数，需要用到一个叫“逆元”的东西。\n加密算法为：$c = (a \\cdot p + b) \\bmod 26$，\n则解密算法为：$p = (c - b) \\cdot a^{-1}$\n对于逆元的了解，\n可以查看本博客的文章ACM学习笔记：线性同余方程……中的“2. 线性同余方程的反函数”章节。\n 证明：\n【看了上面链接文章里的内容后，这里就应该很好理解了吧应该……\n$$c \\equiv a \\cdot p + b \\pmod{m}$$ $$c - b \\equiv a \\cdot p \\pmod{m}$$ $$(c - b) \\cdot a^{-1} \\equiv a \\cdot p \\cdot a^{-1} \\pmod{m}$$ $$(c - b) \\cdot a^{-1} \\equiv p \\pmod{m}$$\n因为$p \u0026lt; m$，\n所以$p = (c - b) \\cdot a^{-1}$，得证。\n \r 逆元求解 对于逆元的求解，Python中有两个函数可以求解。\n  可以用Python的第三方库gmpy2的invert函数。\nfrom gmpy2 import invert ans = invert(5, 26) # 表示求5对模数26的逆元。ans = 21 print(ans) # 21 gmpy2包的安装方法可查看\u0026quot;osc_e45irv7l\u0026quot;的「python3安装gmpy2」文章。\n  可以用Python的第三方库Crypto的inverse函数。\nfrom Crypto.Util.number import * ans = inverse(5, 26) # 表示求5对模数26的逆元。ans = 21 print(ans) # 21 Python3中Crypto库安装可以输入命令pip install pycryptodome\n  两者区别在于：\n对于逆元的求解，两数必须互素。\n如果输入的两参数不互素，\ngmpy2的invert函数会使程序报错，\n而Crypto的inverse不会，其会返回一个很怪的结果【是先将两参数除掉一个最大公约数让其互素，再返回结果……\n加密脚本 from string import ascii_lowercase table = ascii_lowercase # 定义字符集 MOD = len(table) # 确定模数m def Encrypt(Plaintext, A, B): # 加密函数 Ciphertext = \u0026#34;\u0026#34; for i in Plaintext: if i not in ascii_lowercase: Ciphertext += i else: rawIndex = table.find(i) # 先将字符转换为数字编号 cipherIndex = (rawIndex * A + B) % MOD # 加密函数计算 Ciphertext += table[cipherIndex] return Ciphertext 爆破脚本 首先由于状态数少，所以可以枚举爆破。\n并且我们知道答案格式的开头为flag，\n所以可以只查找爆破结果为flag开头的字符串输出，得到正确答案。\nfrom Crypto.Util.number import * from string import ascii_lowercase table = ascii_lowercase # 定义字符集 MOD = len(table) # 确定模数m def crack(): # 爆破a、b函数 for A in range(MOD): for B in range(MOD): if (A*table.find(\u0026#34;f\u0026#34;)+B) % MOD == table.find(Ciphertext[0]): # 按当前a、b加密f字符后，与密文第一位相同 if (A*table.find(\u0026#34;l\u0026#34;)+B) % MOD == table.find(Ciphertext[1]): # 按当前a、b加密l字符后，与密文第二位相同。【后两句if类推 if (A*table.find(\u0026#34;a\u0026#34;)+B) % MOD == table.find(Ciphertext[2]): if (A*table.find(\u0026#34;g\u0026#34;)+B) % MOD == table.find(Ciphertext[3]): # flag均匹配，证明就为当前a、b return (A, B) def Decrypt(Ciphertext, A, B): # 解密函数 Plaintext = \u0026#34;\u0026#34; inv = inverse(A, MOD) # 求得A对Mod的逆元 for i in Ciphertext: if i not in table: Plaintext += i else: rawIndex = table.find(i) # 先将字符转换为数字编号 plainIndex = (rawIndex - B) * inv % MOD # 解密函数计算 Plaintext += table[plainIndex] return Plaintext 如果为其他格式开头，相应修改即可。\n例题 对于字符串vjsg{dckvzksr}，\n其采用了单层仿射加密，字符集为小写字母，\n请解密出flag。\n已知最终flag为纯数字。\n加密过程 可以先尝试解题，\n没有思路再根据加密过程得到思路。\n加密过程\rfrom string import digits, ascii_lowercase from secret import numbers, A, B table = ascii_lowercase # 定义字符集 MOD = len(table) # 确定模数m assert min([i in digits for i in numbers]) # 验证flag格式正确，不用管 print(\u0026#34;numbers =\u0026#34;, numbers) flag = \u0026#34;flag{\u0026#34;+\u0026#34;\u0026#34;.join([ascii_lowercase[int(i)] for i in numbers])+\u0026#34;}\u0026#34; print(\u0026#34;flag =\u0026#34;, flag) assert numbers == \u0026#34;\u0026#34;.join([str(ascii_lowercase.find(i)) for i in flag[5:-1]]) # 验证flag格式正确，不用管 def Encrypt(Plaintext, A, B): # 加密函数 Ciphertext = \u0026#34;\u0026#34; for i in Plaintext: if i not in ascii_lowercase: Ciphertext += i else: rawIndex = table.find(i) # 先将字符转换为数字编号 cipherIndex = (rawIndex * A + B) % MOD # 加密函数计算 Ciphertext += table[cipherIndex] return Ciphertext print(\u0026#34;Ciphertext =\u0026#34;, Encrypt(flag, A, B)) 运行结果：\n其中的最终flag为flag{18453407}。\n 由代码分析可知，\n程序先从secret库中得到flag的数字部分。\n然后把数字按照位置转换为字母。\n e.g.\n将数字0转换为a。\n将数字1转换为b。\n将数字2转换为c。\n 最后再用secret库中的A和B，\n对flag进行仿射加密，得到密文。\n\r 解题过程 知道加密方式为一层仿射加密，且字符集为小写字母。\nflag的开头格式为flag。\n则可使用爆破脚本。\nfrom Crypto.Util.number import * from string import ascii_lowercase Ciphertext = \u0026#34;vjsg{dckvzksr}\u0026#34; # 在这里输入密文 table = ascii_lowercase # 定义字符集 MOD = len(table) # 确定模数m def crack(): # 爆破a、b函数 for A in range(MOD): for B in range(MOD): if (A*table.find(\u0026#34;f\u0026#34;)+B) % MOD == table.find(Ciphertext[0]): # 按当前a、b加密f字符后，与密文第一位相同 if (A*table.find(\u0026#34;l\u0026#34;)+B) % MOD == table.find(Ciphertext[1]): # 按当前a、b加密l字符后，与密文第二位相同。【后两句if类推 if (A*table.find(\u0026#34;a\u0026#34;)+B) % MOD == table.find(Ciphertext[2]): if (A*table.find(\u0026#34;g\u0026#34;)+B) % MOD == table.find(Ciphertext[3]): # flag均匹配，证明就为当前a、b return (A, B) def Decrypt(Ciphertext, A, B): # 解密函数 Plaintext = \u0026#34;\u0026#34; inv = inverse(A, MOD) # 求得A对Mod的逆元 for i in Ciphertext: if i not in table: Plaintext += i else: rawIndex = table.find(i) # 先将字符转换为数字编号 plainIndex = (rawIndex - B) * inv % MOD # 解密函数计算 Plaintext += table[plainIndex] return Plaintext A, B = crack() print(\u0026#34;A = {}, B = {}\u0026#34;.format(A, B)) flag = Decrypt(Ciphertext, A, B) print(flag) print(\u0026#34;\u0026#34;.join([str(ascii_lowercase.find(i)) for i in flag[5:-1]])) 运行结果：\n\r仿射加密 - 例题 爆破运行结果\r\n得到最终flag为flag{18453407}。\n0x05 单表替代密码分析 定义 之前的三种加密算法，均为单表替代加密。\n也就是一个字母与一个字母一一对应的关系。\n单表替代加密无论过程如何，\n最终都形成了一张密码表，\n加密解密都通过查表来进行。\n因此如果我们不知道具体采用什么加密方法，\n就只需要知道哪个字母对应哪个字母，\n分析出一张“密码表”，\n就能对单表替代加密的密文进行解密了。\n这种分析过程就是单表替代密码分析。\n采用分析，甚至可以不用知道密钥是什么，就可以直接得到明文。\n分析方法 如果暴力枚举分析得到密码表，\n则情况数为$26\\times25\\times24\\times\\cdots\\times2\\times1 = 26! = 403291461126605635584000000$。\n因此除非加密方法简单，否则几乎不可能通过枚举得到密码表。\n 基本分析方法有三种：\n 词频分析 双联分析 模式匹配  将三种分析方法综合运用，找出可能性最大的结果。\n词频分析 下图为单个英文字母在文章中出现的频率：\n\r词频分析 - 词频表\r\n我们对于一串较长密文（如对文章加密），统计每个字母出现的频率。\n如果发现某一字母与上表字母的频率接近，\n则两字母应该是对应关系。\n e.g.\n分析后若得到密文中字母X的频率接近为$10.39%$，接近$10.47%$。\n因此可以推测密文X对应明文T。\n 双联分析 词频分析是针对单个字母进行分析，\n同时英语单词中也有很多连续的两字母出现频率很高，\n称作双联字母(bigrams)。\n因此可以用双联分析来辅助我们进行分析。\n下表为1000个单词中，各双联字母出现次数。 \r双联分析 - 次数表\r\n模式匹配 另外，如果有一个较大的单词库，\n还可以通过单词的格式，进一步帮助我们缩小可能的范围。\n e.g.\n单词happy，为12334格式，\n单词success，为1233411格式。\n 那么被进行单表替换后，它的格式并不会发生改变。\n这种模式匹配的优点在于：\n即使密文长度较短，也能尽可能找到接近真相的结果。\n 如果密文长度较短，则词频分析和双联分析很可能不正确。 \r 工具：\n利用模式匹配尝试解密单表替代加密的网站。\n0x06 维吉尼亚加密 维吉尼亚密码是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码。\n为了生成密码，需要使用密码表。\n这一密码表包括了26行字母表，每一行都由前一行向左偏移一位得到。\n\r维吉尼亚加密 - 密码表\r\n具体使用哪一行字母表进行加密是基于密钥进行的，\n在过程中会不断地变换。\n  类型：多表替代加密。 加密对象：一般为字母。 加密方式：根据密钥依次查表替换，得到密文。 安全性：较强。\n多表加密中，对于两个相同的字符，并不一定都会加密为两个相同的字符。\n如第一个a可能加密为g，但第二个a可能加密为o。\n所以能避免直接的词频分析攻击。\n必须要知道密钥才能得到明文。  加密过程 首先有一串明文和一串密钥，\n其中密钥长度要小于明文。\n e.g.\n明文为SUPERSASSW，\n密钥为NICO。\n  将密钥调整到跟明文一样的长度。\n操作方法为不断重复密钥。  调整后密钥为NICONICONI。\n  通过等长的明文和密钥，\n将明文作为列标，密钥作为行标（也可能反之），\n依次查表，得到密文。  如第一位：\n明文为S，密钥为N，\n对应表的N行S列，则密文为F。\n    一位位查表完成后，\n得到密文为：FCRSEACGFE。\n可以明显发现：\n明文中四个同样的S，\n被分别加密为不同的F、A、G、F。\n由于明文与密文并不为一一对应关系，\n所以可以避免直接的词频分析攻击。\n 解密过程 解密的过程就是加密过程反过来。\n e.g.\n密文FCRSEACGFE，密钥为NICO。\n调整密钥为与密文等长字符串为NICONICONI。\n根据密钥第一个字母F所对应的N行字母表，\n发现密文第一个字母F位于S列，\n因而明文第一个字母为S。\n密钥第二个字母C对应I行字母表，\n而密文第二个字母C位于此行U列，\n因而明文第二个字母为U。\n以此类推便可得到明文。\n 破解方法 1. 分析长度 为了传输方便，一般来说密钥都很短小，\n所以密钥会重复，以达到明文的长度。\n首先提出破解方法的\u0026quot;Frederick Kasiski\u0026quot;是基于这样一个简单的观察：\n“密钥的重复部分与明文中的重复部分的连接，在密文中也产生一个重复部分”。\n如果一个字符串在明文中重复，并且被密钥相同的部分加密，那么在密文中也会出现重复的字符串。\n密文中出现的重复字符串的前后长度，则是关键词长度的倍数。\n密文中出现足够多次，就可以根据这几个长度的倍数，来确定真实的长度。\n 直接看文字可能难以理解，结合下面的例子更好理解。 \r  e.g.\n\r维吉尼亚加密 - 破解例子\r\n$(9,6)$的公约数只有$1$和$3$，\n而$1$不可能为密钥长度（否则变为单表加密），\n故密钥长度则为$3$。\n 2. 转化为单表加密问题 找到密钥的长度$n$后，\n则多表加密的问题便可以转化为$n$个单表加密的问题。\n e.g.\n如上例。\n找到长度为$n=3$后，\n则对于从左往右第$1$、$4$、$7$、$\\cdots$位，运用的都是同一种单表加密方式。\n同理：对于第$2$、$5$、$8$、$\\cdots$位，和$3$、$6$、$9$、$\\cdots$位，也是另一种单表加密。\n对每一种单表加密逐个分析，得到部分明文，\n最终就能得到整个明文。\n 0x07 替换和编码 古典加密还包含很多种形式的简单替换和编码。\n这些替换也常常出现Misc中，如：\n Morse电码 敲击码 福尔摩斯跳舞的小人\n\r替换和编码 - 福尔摩斯跳舞的小人 表\r 培根密码\n\r替换和编码 - 培根密码\r  有关编码内容可以阅读Misc部分的数据编码笔记。\n类型和编码 \r替换和编码 - 类型和编码\r\n 密码学中数字主要研究整数。  类型转换 整数进制转换 x = 123456 # 十进制整数 x_hex = hex(x)[2:] # 十进制转十六进制 print(\u0026#34;hex:\u0026#34;,x_hex) # hex: 1e240 x_bin = bin(x)[2:] # 十进制转二进制 print(\u0026#34;hex:\u0026#34;,x_hex) # bin: 11110001001000000 # x_hex与x_bin均为字符串类型 x_a = int(x_hex, 16) # 十六进制转十进制 print(x_a) # 123456 x_b = int(x_bin, 2) # 二进制转十进制 print(x_b) # 123456 字符串类型转换 字符串(str)类型和字节(bytes)类型相互转换。\n 字符串类型是纯文本类型。\n而字节类型是二进制数据。\n表示为b'...'，其中...为可读表示方法。\n s = \u0026#34;flag{qwqqqOrzzz}\u0026#34; # 字符串类型 s_bytes = s.encode() # 字符串类型转字节类型 print(s_bytes) # b\u0026#39;flag{qwqqqOrzzz}\u0026#39; s_str = s_bytes.decode() print(s_str) # flag{qwqqqOrzzz} 整数和字节类型转换 这种类型转换在密码方向题目中很常见。\n【但个人刚入门，暂时不知道转换为整数类型有什么用，等以后见识到了再补充_(:з」∠)_……\n整数类型可以直接参与数学计算，\n字节类型会展示可读的字符。\nfrom Crypto.Util.number import * s = b\u0026#39;flag{this_is_flag}\u0026#39; # 字节类型 s_int = bytes_to_long(s) # 字节类型转为整数 print(s_int) # 8922333133093133239960474404255406756030333 s_bytes = long_to_bytes(s_int) # 整数转字节类型 print(s_bytes) # b\u0026#39;flag{this_is_flag}\u0026#39; 编码 Base64编码 import base64 s = b\u0026#39;flag{this_is_flag}\u0026#39; # 字节类型 s_encode = base64.b64encode(s) # 进行base64编码 print(s_encode) # b\u0026#39;ZmxhZ3t0aGlzX2lzX2ZsYWd9\u0026#39; s_decode = base64.b64decode(s_encode) # 进行base64解码 print(s_decode) # b\u0026#39;flag{this_is_flag}\u0026#39; 0x08 写在最后  以上大部分为个人总结，由于这里也刚入门，很多地方可能存在错误。如发现错误请及时指出，谢谢！…… \r  由于目前博客不支持附件上传下载，所以如果需要上述中的文件，可以联系我分享文件【联系方式在关于页面中有…… \r  如对以上内容存在疑惑不解的地方，也可以询问我。如果我了解的话会尽力解答；不了解的话可以一起努力弄明白hhh…… \r\n这部分涉及到数论的知识，故可能会感觉有点难……\n个人刚好为了学ACM数论知识点，补了ACM方面的笔记，算是一举两得2333……\n感谢Am473ur师傅的辛勤付出！……\n以上……\n","date":"2021-02-04T00:00:00Z","image":"https://blog.supersassw.com/p/ctf-note-crypto_1/85100927_p0_hu5c6c9f4da506a8b7dfcc39af1be1b7cf_10213578_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/ctf-note-crypto_1/","title":"Crypto - 古典密码……"},{"content":" 以下为涅普计划的课程笔记，建议搭配课程视频理解。 \r 流量分析：\n利用流量分析工具，抓取网络请求中的各种流量数据包，\n分析其中的信息，并得到自己所需要的有用信息（如flag）。\n0x00 课程视频 课程视频\r\r\r视频Bilibili链接\r 0x01 所需工具  Burp Suite Nmap Packet Tracer Wireshark  0x02 互联网五层模型 基本介绍：\n\r互联网五层模型 - 基本介绍 1\r\n 实际上互联网应该是七层模型，但因为具体实现上大部分只实现了五层，所以这里只介绍五层模型。 \r 这五层并不是层次关系，而是一种包含关系，\n也就是说：物理层中包含了一个数据链路层、数据链路层包含了一个网络层，以此类推。 \r互联网五层模型 - 基本介绍 2\r\n当信号传导对应层时，该层的信息就会被切去。\n e.g.\n当信息通过物理层传输完成后，其物理层的信息就会被切去，\n这之后信息通过数据链路层，其数据链路层的信息就会被切去。\n 个人没有详细去了解以下部分（互联网五层模型），\n只是大致写了课程中所讲到的内容。\n但其知识点又较为复杂，\n如需更深入了解可自行查阅相关资料。\n\r 物理层 物理层就是在现实世界中数据的传输方式。\n其有很多传输方式，不同方式的原理不同。\n比如：\n Wi-Fi无线通信——通过电磁波来进行传输。 千兆网线——通过其中八根金属芯进行传输。 百兆网线——通过其中四根金属芯进行传输。   物理层在传输到一个信息后，\n会被计算机将其中的物理信号，调制解调成数据链路层的一个信号，\n也就是一个以太网帧格式的信号。\n数据链路层 在数据链路层中，每台设备都被分配了对应的且独一无二的MAC地址（物理地址）。\n MAC地址：\n每个网卡都有个独一无二的MAC地址，\n当网卡被厂家生产出来的时候，就已经有一个确定的MAC地址。\n 以太网协议属于数据链路层，\n其协议主要体现在以太帧上。\n以太帧中的网络数据包分为两个主要地址：\n一个是源地址的MAC地址，\n一个是目的地址的MAC地址。\n当某台计算机想给另外一台计算机发送消息时，\n需要在以太帧头中指明发送方和接收方的MAC地址。\n网络层 当我们计算机的网络较为大且复杂的时候，\n我们使用简单的MAC地址并不能很好的管理网络。\n因为MAC地址是和硬件绑定的，\n因为假如我们更换了计算机设备，那么就需要重新配置网络的信息。\n这个时候IP地址网络协议就诞生了。\n 在网络层中，每台设备都被分配了一个虚拟的且独一无二的IP地址（网络地址）。\nIP地址与MAC地址的关系：\n可以是一对多，也可以是多对一。\n也就是说一个MAC地址可以分配给多个IP，\n同一个IP也可以被多个网卡（MAC地址）所使用。\n根据ARP协议，可以将物理地址和网络地址相互转换。\n\r网络层 - ARP举例\r\n子网与网段的概念 通过与子网掩码的与运算，可以从逻辑上把一个大网络划分成一些小网络。\n 子网掩码：\n是由一系列的1和0构成，通过将其同IP地址做“与”运算来指出一个IP地址的网络号是什么。\n对于传统IP地址分类来说：\nA类地址的子网掩码是255.0.0.0；\nB类地址的子网掩码是255.255.0.0；\nC类地址的子网掩码是255.255.255.0。\n  e.g.\n将一个B类网络166.111.0.0划分为多个C类子网来用的话，\n只要将其子网掩码设置为255.255.255.0即可。\n这样166.111.1.1和166.111.2.1就分属于不同的网络了。\n 像这样，通过较长的子网掩码将一个网络划分为多个网络的方法就叫做划分子网。\n一般来说，对于192.168.1.x与192.168.2.x，其属于不同的网段，\n要通过路由器，使得不同网段能相互访问。\n传输层 在网络层的基础上，我们完成了数据通过IP地址的传送，\n但是我们仍然要确保数据传输的可靠性。\n这里便产生了许多协议，如：\n UDP协议 TCP协议  UDP协议 是不可靠连接。\n因为不能确定对方是否收到数据包。\nQQ通讯使用的OICQ协议，也是基于UDP协议。\nTCP协议 要点为三次握手和四次挥手。\n总览图：\n\rTCP - 过程总览\r\n三次握手 流程：\n SYN\n客户端向服务端发送一个请求连接包，\n标识符为SYN J。 SYN, ACK\n服务端收到请求连接包，并对SYN J进行确认，\n然后发送一个回复包，标识符为SYN K, ACK J+1。 ACK\n客户端向服务端发一个确认收到回复包，\n标识符为ACK K+1  抓包如图：\n\rTCP - 三次握手抓包\r\n四次挥手 流程：\n FIN M ACK M+1 FIN N ACK N+1  应用层 基本协议：\n HTTP SSH SFTP  都是基于UDP或TCP等传输层的协议来实现的。\nHTTP报文 \r应用层 - HTTP请求和响应报文\r\n请求报文：\n\r应用层 - HTTP请求报文\r\n响应报文：\n\r应用层 - HTTP响应报文\r\nHTTP与HTTPS协议区别 HTTP是未加密的，可以直接被Wireshark截获；\n而HTTPS是加密的，请求的路径和内容是不能被直接截获的。\n将这些加密的协议统一称为\u0026quot;TLS\u0026quot;或\u0026quot;SSL\u0026quot;加密协议。\n0x03 流量分析工具 Wireshark 用于流量数据包的抓包、记录、分析等。\n开始界面 \rWireshark - 开始界面\r\n其中显示的是捕获到的各种本地接口。\n 以太网：表示的是用网线进行上网的物理接口。 WLAN：表示的是用Wi-Fi进行上网的物理接口。 VMware：虚拟机上网使用的虚拟接口。 VPN：使用VPN上网的网络接口。 USBPacp：USB的接口。   当同时连接以太网和WLAN时，\n决定使用哪个接口的是跃点数。\n跃点数越低，优先级越高。\n对于计算机来说，默认情况下：\n物理网口往往比无限网口跃点数低。\n所以默认使用以太网接口。\n打开网络接口 可以在这里截获这个接口上传输的流量包。\n例一——HTTP 以国家企业信用信息公示系统网页为例：\n刚访问网站时，我们会向网站服务器发送一个GET类型的request数据包，\n作用是得到刚进入网站的首页index.html这个网页文本。 \r截获流量包 - GET的request内容\r\n根据这个request数据包，网站服务器会返回一个response数据包，\n当前这个请求的response数据，包就是网页的内容。 \r截获流量包 - response返回内容\r\n 使用浏览器访问页面后，发现其使用的是不安全的HTTP协议。\n\r截获流量包 - 不安全图示\r\n因此用过滤器过滤出HTTP，然后寻找GET /index.html。 \r截获流量包 - 过滤HTTP\r\n这个数据包就是网络中负责请求的request数据包。\n其必然对应于一个返回的response数据包，\n查看下方\u0026quot;Hypertext Transfer Protocol\u0026quot;中的\u0026quot;Response in frame\u0026quot;，\n可以得到返回的数据包在所截获数据包中的编号\u0026quot;No.\u0026quot;。（双击即可跳转到该response数据包）\n e.g.\n上面GET的request数据包中，\n\r截获数据包 - response数据包所在帧\r\n发现在编号No.174处。\n\r截获数据包 - response数据包\r 即对应这一数据包\n 查看response数据包中的\u0026quot;Line-based text data: text/html\u0026quot;，\n可以看到相同的HTML内容。 \r截获数据包 - response数据包内容\r\n例二——HTTPS 以国家税务总局四川省税务局网页为例：\n可以发现其使用的是安全的HTTPS协议。\n\r截获流量包 - 安全图示\r\n此时单纯过滤HTTP数据包，\n无论怎么刷新网页，都是无法过滤出这个网站所产生的数据包的。 \r截获流量包 - HTTPS\r\n 此时数据包采用了TLS协议加密，\n所以我们无法直接截获。\n数据导出 可以使用如下方法导出Wireshark中所有的HTTP包的数据。\n 选择\u0026quot;File - Export Objects - HTTP\u0026hellip;\u0026quot;\n\rWireshark - 数据导出 方法1 1\r \rWireshark - 数据导出 方法1 2\r 也可以在某个TCP包上面选择\u0026quot;右键 - Follow - TCP Stream\u0026quot;，从而获取一整个TCP连接的数据。\n\rWireshark - 数据导出 方法2 1\r  保存 点击菜单栏中的“文件 - 保存”，\n能将所有截获的流量包，保存为pcapng格式文件。\n以供今后分析使用。\nCTF应用  给个流量包，从中找到flag。\n简单的题目可以直接字符串查找flag。  Cisco Packet Tracer 网络拓扑模拟的软件。\n网络连线  不同设备用直连线（实线） 相同设备用交叉线（虚线）  当两台计算机直接连接通信的时候，发挥主要作用的是物理层。\n计算机将信号发送到网线上，另外一台计算机负责接收。\n网络设备 集线器 Hub 应用于物理层。\n集线器对接收到的信号进行再生整形放大，以扩大网络的传输距离，\n同时将所有结点集中在以它为中心的节点上。\n采取广播式发送，而不是针对式发送。\n会将数据包发送至与集线器相连的所有节点。\n相当于多台计算机同时连接在一根导线上。\n 优点：\n 便宜。  缺陷：\n 不安全。 如果有黑客成功将自己电脑接线于集线器上，\n那么其就能监听截获其他设备所发送给另外设备的数据包。 可能信号冲突。  交换机 Switch 应用于数据链路层。\n利用以太网协议，\n主要体现在以太帧上。\n交换机在接收到信号之后，\n会告知交换机要发送的设备的网卡的MAC地址是多少。\n于是交换机会根据这个地址正确将信号转发至某一端口（即网线），\n从而避免了网络内所有计算机都能收到信号。\n起到了信号隔离的作用，也成为隔离冲突域。\n 同时支持分别发送和广播式发送。\n将目的地址写为0.0.0.0，便能广播式发送。\n 优点：\n 安全性高。  缺点：\n 如果网卡坏了，MAC地址需要更改，则不能用之前的MAC地址。\n需要刷新记录的MAC表。  路由器 路由器能使设备之间跨网段访问。\n相当于一个网关。\n如图所示网络\n\r路由器 - 网络举例\r\n两个网段分别是192.168.0.0/24和192.168.1.0/24。\n网关则是路由器连接每个网段的接口。\n e.g.\n192.168.0.2想与192.168.1.4跨网段通信，\n则需要把消息转发给路由器上的网关，\n路由器再根据IP地址转发。\n Nmap/NetCat 有关这两个工具师傅并未很详细讲到具体作用和与CTF有关联系，\n于是个人写的很简略，并且可能存在错误。\n但稍微查询感觉这两个工具作用很大，\n需要深入了解可以自我查询相关资料。\n\r 基于TCP协议的监听或发送数据的命令。\nNetCat用netcat或nc；\nNmap用ncat。\n两者使用方法差不多。\n 输入ncat (地址) (端口)，\n可以连接上该地址，并发送简单的TCP数据包。\n参数  -lk (端口)：监听某一端口。 --chat：在服务器中启动聊天服务。  e.g.\nncat -lk (端口) --chat。\n   0x04 课堂练习与个人解析 1. 上课认真听了吗 题目描述 flag在三种不同的流量中。\n 附件：\n udphttptcp.pcapng\n本题所需分析的流量包  解题方法 三种流量分别对应今天所学的TCP、HTTP、UDP。\n下载流量包后用Wireshark打开。\n 首先尝试直接搜索关键字flag{。\n按Ctrl+F打开搜索栏，\n第一个选项栏选择“分组字节流”，\n 有关第一个选项栏中三个选项的解释：\n 分组列表：代表的是最上面的窗口，在Info栏中进行搜索。 分组详细：代表的是中间的窗口。 分组字节流：代表的是最下面的窗口，在十六进制文件中搜索。 第三个选项栏选择“字符串”，\n搜索框中填写flag{。\n\r第一题 - 搜索栏设置\r   一直搜索，会分别搜索到三个flag。\n第一个flag\rUDP帧：\nflag内容：\n第二个flag\rTCP帧：\nflag内容：\n第三个flag\rHTTP帧：\nflag内容：\n 之前提到过，HTTP协议也是基于TCP协议实现的，\n所以这里现实的类别也是TCP协议。\n在详细窗口中，可以发现\u0026quot;Reassembled PDU in frame: \u0026hellip;\u0026ldquo;这样一个超链接字段，\n双击后，便可以找到最开始的HTTP数据包。\n \r 对这三个flag排列组合测试，得到最终的flag：flag{25434026}。\n2. 我是间谍 题目描述 我是间谍，我在干什么呢？\n 附件：\n imaspy.exe\n需要分析的“恶意软件”，分析其发送流量的数据包。  解题方法 首先需要注意的是：\n对于恶意软件，我们应该在一个隔离的环境中运行，\n也就是应该在一台虚拟机或沙盒中运行该软件。\n【虽然这道题中的程序并不是真的恶意程序……\n并且由于宿主机中流量很多，不好轻易找出恶意软件的流量，\n所以更应该在虚拟机中运行。\n 但这里还是直接在宿主机中运行并抓取流量的。\n虽然流量很多不好直接找到，\n但我们仍可以用万能的搜索。\n 启动Wireshark监听并运行程序。\n待程序执行完成并关闭窗口后，\n跟上道题一样，直接在分组字节流中搜索字符串flag{。\n可以直接得到flag。\n\r第二题 - 搜索内容\r\n这里只写了课堂上的两道习题。\n有关课后的两道习题，在视频最后部分师傅有所解答，\n可以去视频中查看。\n\r  0x05 写在最后  因为个人水平原因，这篇笔记可能写的很简略不清晰或存在很多错误，请见谅！…… \r 这部分有点不知道怎么做笔记……\n只可意会不可言传的那种感觉_(:з」∠)_……\n而且很多知识（比如网络方面）如果要真去弄懂，又要学很多方面的东西……\n想了好久才最终把这个整理完成orzzz……\n写得好乱【……\n 以上大部分为个人总结，由于这里也刚入门，很多地方可能存在错误。如发现错误请及时指出，谢谢！…… \r  由于目前博客不支持附件上传下载，所以如果需要上述中的文件，可以联系我分享文件【联系方式在关于页面中有…… \r  如对以上内容存在疑惑不解的地方，也可以询问我。如果我了解的话会尽力解答；不了解的话可以一起努力弄明白hhh…… \r\n感谢fjh1997师傅的辛勤付出！……\n以上……\n","date":"2021-02-03T00:00:00Z","image":"https://blog.supersassw.com/p/ctf-note-misc_3/57890506_p0_hu20a1b54dc3f8ad2cd21d3e328c8fd47f_537572_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/ctf-note-misc_3/","title":"Misc - 流量分析……"},{"content":" 以下为涅普计划的课程笔记，建议搭配课程视频理解。 \r 0x00 课程视频 课程视频\r\r\r视频Bilibili链接\r 0x01 常见进制与进制转换 常见进制 计算机领域中，常用进制有：\n 二进制(Binary、bin) 八进制(Octal、oct) 十六进制(Hexadecimal、hex)   有关这几种进制的优缺点、用处分析，可见“六六”在知乎问题“二进制，十进制，十六进制各有什么优缺点？”中的回答。 \r 而在计算机中，存储信息归根到底都是以二进制存储的。\n八进制和十六进制，只是为了简化二进制的表达，方便观察记录。\n 如将1010 0101 1100 1011这复杂的一串二进制，转化为十六进制就为A 5 C D，更方便记录和观察。\n 进制转换 因为信息都是以二进制的形式存储，所以二进制可以转换为各种信息。\n\r进制转换类别\r\n1. 二进制转ASCII码 每八位为一个整体，将其转换为十进制后，对应ASCII码表查询得到对应的字符。\n e.g.\n一串二进制串01101110 01101001 01100011 01101111，\n将其按每八位一节转换为十进制后为110 105 99 111，\n查询ASCII码表，得到字符串nico。\n 2. 二进制转Morse码 跟二进制转ASCII码一样，\n将一串二进制转化为ASCII码中的.和-和␠(空格)，来表示摩尔斯码。\nMorse码中：\n . 对应的ASCII码为46、二进制为0010 1110。 - 对应的ASCII码为45、二进制为0010 1101。 ␠ 对应的ASCII码为32、二进制位0010 0000。   e.g.\n一大串二进制数据：\n00101101 00101110 00100000 00101110 00101110 00100000 00101101 00101110 00101101 00101110 00100000 00101101 00101101 00101101\n发现其中仅由00101101、00101110、00100000三种二进制节构成，对应于-、.、␠，故可知应为Morse码的二进制。\n使用二进制转Morse转换工具，得到-. .. -.-. ---，\n在使用Morse转文本转换工具，得到nico这个文本。\n 3. 二进制转二维码 对于一二进制字符串，转成十进制、十六进制后分析不出有用信息，\n若其长度$n$，满足$n=a^2(a∈Z)$，也就是这个长度是个完全平方数(如$625$），\n可以考虑转换为二维码。\n其中0则代表白色，1则代表黑色。（也可能为反过来）\n转换方式使用Python中的PIL(Pillow)库，按上述规则将二维码绘制出来。\nPython代码：\nfrom PIL import Image MAX = * # 在这里输入二维码的长宽（为二进制字符串长度开根） str = \u0026#34;...\u0026#34; # 在这里输入二进制字符串 pic = Image.new(\u0026#34;RGB\u0026#34;,(MAX, MAX)) i = 0 for y in range(0, MAX): for x in range(0, MAX): if (str[i] == \u0026#39;1\u0026#39;): pic.putpixel([x,y], (0, 0, 0)) # 为1，填充黑色 else: pic.putpixel([x,y], (255, 255, 255)) # 为0，填充白色 i += 1 pic.show() # 打开生成的二维码 pic.save(\u0026#34;flag.png\u0026#34;) # 保存二维码为flag.png  e.g.\n例题中所生成的二维码：\n\r进制转换 - 二进制转二维码例子\r\n 4. 二进制转图片 先将二进制字符串转换为十六进制，\n再用十六进制编辑器，将转换后的十六进制数据，写入到新的文件中。\n e.g.\n对于例题所给的长串二进制，\n先使用工具将其转换为十六进制，\n\r进制转换 - 转图片 转十六进制\r\n然后打开十六进制编辑器，新建十六进制文件（不是文本文件），\n将转换后的十六进制结果，粘贴到新文件中。\n 注意：010 Editor粘贴十六进制文本的快捷键位Ctrl+Shift+V，并非Ctrl+V。 \r \r进制转换 - 转图片 写入十六进制文件\r\n可以发现文件头尾分别为FF D8和FF D9，可知为JPG文件，\n保存为JPG格式文件，可得到转换后的图片。\n\r进制转换 - 转图片 转换得到图片\r\n 0x02 常见编码 ASCII 【应该都很熟悉这个ASCII码了……\n把常用的字符（如a ~ z、A ~ Z、0 ~ 9、常用符号等），以一个特定的数来表示。\n则可以将常用的字符，转化为二进制数并且直接存储到计算机中。\n标准的ASCII定义了128个字符，刚好为$2^7$个，所以部分ASCII码以每7位二进制为一个组合，来表示这128种字符。\n但通常来说，为了统一，都是以每8位二进制为一个组合，最高位补0。\n以下为ASCII码表可显示字符部分：\n\rASCII码表 - 可显示部分\r\n 控制字符部分(0 ~ 31)可查看ASCII编码对照表。 \r Base家族 base64 为最为常见的编码。\n编码原理 把3个8位的字节转化为4个6位的节，\n之后在每个6位的节的前面补两个0，重新形成8位（一字节）形式。\n6位的二进制最大容量为$2^6 = 64$，故其字符集只有64个字符，\n分别为A ~ Z、a ~ z、0 ~ 9、+、/。\n\rbase64编码表\r\n e.g.\n\rbase64转换例子\r\n  虽然=是不存在于编码表的，但其可能会出现在base64编码后的字符串中，\n其作用是：\n当字符不为$3$的倍数个时，会先用0将末尾补全，再用=表示填补了多少字节(8bits)的0。\n e.g.\nA的ASCII是0100 0001，只有8位，\n则会用0补成24位，变成0010 0001 0000 0000 0000 0000，\n然后划分成4个6位后高位补0，即为00010000 00010000 00000000 00000000， 对照表编码后即为QQ，补了$2$个字节的0，所以最终为QQ==。\n 注意：不能将末尾补的00000000看作A。 \r\n 但为了避免=在URL和Cookie中产生歧义，部分base64编码也会把=去掉。\n作用 可能有人会不懂发明这个base64编码有什么作用（比如我），\n为什么不能直接传输原来的文本数据，而要通过这个base64编码后再传，\n甚至编码后占用空间还变大了.jpg……\n个人查阅学习了以后稍微有所理解，这里稍微写下来记录一下。 【以下为个人理解，很有可能有错误，仅供参考！……\n个人理解的base64作用\r首先对于各种文本的编码，如果只是简单的西欧文本（也就是ASCII码中包括的东西，如字母），处理就相对统一。\n但对于其他文本（如中文、俄文等），简单的ASCII码不能满足，于是会有各种其他的编码方式来处理这些文本（如GBK、JIS等）。\n需注意这里的文本编码方式，都是怎么将我们这些各种字符，转化为数字（二进制）运用到计算机中。\nASCII码也是，就是将“a”字符传化为二进制0110 0001来处理。\n\r\r这些编码方式，普遍与ASCII码的编码方式有区别。\n其中最突出的就是：\n ASCII码的一字节8位中，最高位是0的， 其他编码方式，很可能会使最高位位1。  比如对于汉字“你”，\n以UTF-8方式编码后，为111100100 10111101 10100000（hex: E4 BD A0)\n可以发现与标准的ASCII码对比，最高位是1。\n   注意标准ASCII码与扩展ASCII码的区别：\n标准的ASCII码最高位是0，也就是范围为0 ~ 127。\n而对于那些最高位是1的ASCII码，是之后扩充的，其属于不可见字符，\n对这些不可见字符，不同国家的处理方式也会不同。\n所以只有最高位是0（范围为0 ~ 127）的ASCII码为真正的统一标准。\n\r\r 这样的后果就是：\n一些设备，对于传输过来的标准ASCII码中字符数据，处理方式都是一样的没问题。\n但对于那些不可见字符的处理方式，就很可能不一样。\n 比如传输了一个“a”过来，其以ASCII码传输为0110 0001，\n对于这个，所有设备都知道它是个“a”这个字符，所以能正确传输，\n而对于“你”这个汉字，如果直接UTF-8编码后传输过来为111100100 10111101 10100000，\n不同设备的处理方式就会不同了。\n 比如有些可能强行将最高位变为0，传输成011100100 00111101 00100000，就完全不同了，\n有些可能把这个当成个控制命令，而不是继续传输这个数据。\n   所以经过bse64编码后，将所有字符转化为标准ASCII码，\n就能有效地避免在传输过程中的歧义操作了，\n传输完成后再解码回来就可以了。\n\r  以下base编码方式大部分与base64相同，唯一区别只是字符集不同，故不再给出编码原理。 \r base36 字符集 0 ~ 9、A ~ Z(或a ~ z)\n包含$0 \\sim 9$的数字，加上所有$26$个字母（不区分大小写，即大写或小写均可）。\n不包含任何标点。\n特点  加密仅支持整数数字。 解密仅支持字符串。 不支持中文。  base58 字符集 123456789、abcdefghijk、mnopqrstuvwxyz、ABCDEFGH、JKLMN、PQRSTUVWXYZ。\n仅包含部分数字和部分字母，\n其中不包含：\n 0（数字0） l（小写L） O（大写o） I（大写i）  特点 为base64的字符集中，\n去掉了四个容易引起视觉混淆的字符(0、l、O、I)，和两个符号(+、/)。\n$9$个数字$+49$个字母$=58$，所以称为base58。\nbase62 区别于base64的地方只是去掉了+和/。\nbase85 base85不太常用。\n类似于base64的二进制文本编码形式，\n通过使用$5$个ASCII字符来表示四个字节的二进制数据。\n 这个base85个人暂时不是很理解，\n因为大于了$2^6=64$，所以跟base64的编码原理应该是不一样的，\n字符集也不清楚。\n【但网上也很少关于base85的资料orz……\n目前只找到一份图，看样子应该是将4个字节划分为$6+7+6+7+6$这种划分形式转换为ASCII码的。\n\rbase85 - 例子\r\n来源于Base系列编码浅析。\n因为说不常用就没深入去了解，\n想要了解可以到google查阅英文文档看看吧。\nbase91、92 base91的字符集为：0-9、a-z、A-Z、!#$%\u0026amp;()*+,./:;\u0026lt;=\u0026gt;?@[]^_`{|}~\u0026quot;（就是你键盘上除了\\、-、'能打出来的所有符号）\n\rbase91 - 字符集\r\nbase92比base91多一个〜（注意不是~）\n 这两个编码方式相关资料很少，\n只用了解并且会使用转换工具应该就可以了，不需要太深入掌握吧应该【……\n转换工具  网络上各种base编码转换工具。 CyberChef中Magic模块。\n特点：可自动识别为哪种base编码。 CyberChef中的 \u0026ldquo;From base \u0026hellip;\u0026rdquo; 模块。  Morse电码 【简介略……\n\rMorse电码表\r\n计算机中表示方法：\n 用.来表示点 -来表示划 常用空格␠来表示分割  shellcode shellcode是一段用于利用软件漏洞而执行的代码。\nshellcode为16进制的机器码，因为经常让攻击者获得shell而得名。\n 在这里其实就是一串16进制数据，\n先转换为10进制，然后解码成ASCII即可。\n e.g.\n一串shellcode\\x54\\x68\\x65，\n转换为10进制为84 104 101，\n对照ASCII码则为The。\n urlencode url编码又称百分号编码，是统一资源定位(URL)编码方式。\nURL地址（网址）中规定：\n数字、字母和特定字符（/、,、:、@等）可以直接使用，\n其余必须通过%xx来编码。\n（其中的xx代表ASCII的十六进制。）\n也就是说编码形式上跟shellcode差不多，不过把\\x换成了%而已。\n e.g.\nThe编码成urlencode就是%54%68%65\n 关于urlencode的拓展\r经常可以见到，在地址栏中，一些汉字就会变成%xx这样的编码形式。\n也就是这些汉字先以UTF-8编码变成16进制，然后又按urlencode加上%。\n e.g.\n萌娘百科中童田明治的页面URL为：https://zh.moegirl.org.cn/%E7%AB%A5%E7%94%B0%E6%98%8E%E6%B2%BB，\n“童田明治”以UTF-8编码成十六进制数据后，分别为：\n E7 AB A5（童） E7 94 B0（田） E6 98 8E（明） E6 B2 BB（治）  对应到上方的URL中，就是%E7%AB%A5等。\n \r Unicode 中文又称国际码、万国码等。\n表示形式：\n 十六进制表示  \\u**** \u0026amp;#x****;   十进制表示  \u0026amp;#****;    Unicode与UTF-8等的区别与联系 个人在学习的时候发现这两类东西很迷惑，网上各种说法也很混淆。\n通过查找资料加上自我脑补x后，对这两类稍微明白了一点。\n于是这里顺带提一下UTF-8、UTF-16等UTF-*编码，及其与Unicode编码的关系。\n【内容太多故做折叠处理……\n两类的区别联系\r首先对于Unicode编码，\n其跟ASCII码一样，是一种对字符的编码方式，\n或者以术语来称呼，是一种“字符集”。\n其完成的是一种“字符—数字”的一一映射的转换。\n 比如ASCII码中，对于A这个字符，对应的数字（十进制）为65，也就是将字符A映射到数字65，\nUnicode编码中，对于A这个字符，对应的数字（十进制）为41，也就是将字符A映射到数字41。 而Unicode编码中，对于\n Unicode其实也有个跟ASCII码一样的表，不过太大了所以一张图放不下x……\n 其实Word中的“插入字符”，其就是按照Unicode的编号顺序来排列的，\n可以看作一张跟ASCII码表一样的Unicode码表：\n下方的字符代码，则是这个符号在Unicode这个映射表中对应的数字的十六进制形式。\n  Unicode本身是不断在扩充的，\n最初它只选择了2个字节(16位)，最多能表示$2^{16} = 65536$个字符。\n 但这里说选择2个字节实际上不恰当，因为Unicode并不是一种存储方式，而只是一种字符与数映射关系。存储方式由后面讲的UTF-8来决定 \r\r后面发现$65536$个也不够，所以又在前面加了8位，称为“扩展位”，\n一共24位，最多能存$2^{24} = 16777216$个了。\n【但这样扩展后又太多了，目前扩展位最多只用到了10(hex)，也就是Unicode范围为000000 ~ 10FFFF。\n【【等到以后发现外星语后就可能再扩充，一直用到FFFFFF这样吧233333……\n这里可以牢记两个对应思想：\n $1$位十六进制对应$4$位二进制 $1$字节对应$8$位，也就是$2$位十六进制。  \r\r 请注意：上面所说的Unicode只是一种字符集，一种对应方式，并没有涉及到怎么存储。\n这里就可能会感到奇怪：明明通过Unicode，都对应成了数字，为什么不能直接像ASCII码一样把数字存下来就好了？\n对啦！这种想法就是Unicode的存储方式之一——直接把序号存下来，跟ASCII码一样。\n这种存储方式就叫做UTF-32。\nUTF-32编码方式：\n将Unicode中的序号转换为16进制，再最高位补0至32位。\n e.g.\n对于“🀀”这个符号来说，【不要管为什么要举麻将啦2333【因为这个序号大一些这样……\n其Unicode序号是126976，\n也就是在Unicode这张表中，将字符🀀映射成了数字126976，\n转换为16进制为1F000，\n那么按我们想的，直接把这个序号数字存储下来，\n但注意计算机中最好按$2^n(n∈N^+)$个字节来存储，【具体原因好像是因为内存对齐？……\n这里已经是$5*4=20$位了，2个字节不够，\n所以只能选择4个字节，也就是32位来存。\n那么跟很多编码操作一样，最高位补0， 于是变成了001F 0000。\n那么也就是按UTF-32编码后🀀则被编码成001F 0000。\n  可以发现，\nUTF-32好处就是非常直观，\n但缺点也很明显：太浪费空间了。\n原本用ASCII编码，1个字节就能存储表示的英文字母，\n到UTF-32编码，就要用4个字节了。\n这在当时昂贵的存储代价和极扣x的程序员们的眼中是不能忍受的！\n于是他们又机智地创造出别的编码方法，\n也就是UTF-8和UTF-16。\n这两种编码方法具体怎么实现这里就不讲了，有兴趣可以自己查阅。\n但可以知道的是：\nUTF-16用$2$或$4$字节，\nUTF-8用$1\\sim4$字节。\n无论怎样，都比UTF-32纯用$4$字节好多了。\n 那么对于以上，可以总结出以下说法：\n  Unicode只是一种字符集，是一种字符对应数字的映射，并不能说是一种编码。\n  各种UTF-*才真正实现了Unicode在计算机上的存储，才能说是编码。\n  Unicode可以对字符进行“初步编码”，然后用\u0026amp;#、\u0026amp;#x、\\u来表示。\n 真，Unicode序号为30495(hex:771F，可以表示为\u0026amp;#30495;、\u0026amp;#x771F;、\\u771F。\n   UTF-*是对Unicode编码后的数字进行的的一种“再编码”。\n   更多扩展\r对于网络上各种Unicode编码工具，\n如果只是简单的对中文编码是不存在问题的。\n而对版本较新，序号较大（16进制用了5位及以上）的字符，则会出现问题。\n 仍以序号比较大的🀀为例：\n首先通过网站查询，得到以下信息。\n将重要信息已经用红线划出。\n查询地址\n则Unicode编码结果应该为\u0026amp;#126976;、\u0026amp;#x1F000;、\\u1F000\n 站长工具\n发现与推断出的不符合。 SOJSON在线解析\n点击HTML预览后，很明显看到左上角为两个乱码。   如果需要正确转换，可以使用千千秀字中的HTML字符实体转换工具。\n 刚接触Unicode时，总会将其与ASCII比较，\n但现在可以发现：\nASCII编码，实际上是字符集和编码方法的整合。\n字符集就是基本的ASCII码表，\n不过其编码方法十分简单粗暴，字符集对应的序号是多少，编码后就是多少。\n而Unicode中，字符集有了后，\n本来也有跟ASCII一样简单粗暴的编码方法，就是UTF-32，\n但当时的储存代价很高，于是人们将扣的艺术运用到机制，\n创造了UTF-16、甚至UTF-8这些编码方式，减小了储存消耗。\n这也产生了现在的歧义。\n 假想一下：\n如果当时技术力就很高，储存代价极小，\n有可能像ASCII那样，就用UTF-32存，\n不用再去想UTF-8这种抠门方式，\n那应该今天就不会有这种Unicode于UTF-8是什么关系的迷惑了_(:з」∠)_……\n \r\r\r aaencode 使用颜文字进行的编码。\n特点：\n可以将JavaScript代码编码，并且可以直接执行。\n也就是常说的颜文字js加密。\n e.g.\n一段js代码，\nalert(\u0026#34;nico\u0026#34;) 将这段js代码用aaencode编码后，\nﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ [\u0026#39;_\u0026#39;]; o=(ﾟｰﾟ) =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)={ﾟΘﾟ: \u0026#39;_\u0026#39; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +\u0026#39;_\u0026#39;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ \u0026#39;_\u0026#39;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;)[ﾟｰﾟ] }; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +\u0026#39;_\u0026#39;) [c^_^o];(ﾟДﾟ) [\u0026#39;c\u0026#39;] = ((ﾟДﾟ)+\u0026#39;_\u0026#39;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [\u0026#39;o\u0026#39;] = ((ﾟДﾟ)+\u0026#39;_\u0026#39;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [\u0026#39;c\u0026#39;]+(ﾟДﾟ) [\u0026#39;o\u0026#39;]+(ﾟωﾟﾉ +\u0026#39;_\u0026#39;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +\u0026#39;_\u0026#39;) [ﾟｰﾟ] + ((ﾟДﾟ) +\u0026#39;_\u0026#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [\u0026#39;c\u0026#39;]+((ﾟДﾟ)+\u0026#39;_\u0026#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [\u0026#39;o\u0026#39;]+((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;) [ﾟΘﾟ];(ﾟДﾟ) [\u0026#39;_\u0026#39;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+\u0026#39;_\u0026#39;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +\u0026#39;_\u0026#39;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=\u0026#39;\\\\\u0026#39;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +\u0026#39;_\u0026#39;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=\u0026#39;\\\u0026#34;\u0026#39;;(ﾟДﾟ) [\u0026#39;_\u0026#39;] ( (ﾟДﾟ) [\u0026#39;_\u0026#39;] (ﾟεﾟ+/*´∇｀*/(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+(ﾟｰﾟ)+(ﾟΘﾟ)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+(ﾟｰﾟ)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+(ﾟｰﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((o^_^o) +(o^_^o))+((o^_^o) - (ﾟΘﾟ))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((o^_^o) +(o^_^o))+(ﾟｰﾟ)+(ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+(c^_^o)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+((o^_^o) - (ﾟΘﾟ))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+((o^_^o) +(o^_^o))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+(ﾟΘﾟ)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+(ﾟｰﾟ)+(o^_^o)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+((ﾟｰﾟ) + (o^_^o))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+((o^_^o) - (ﾟΘﾟ))+(ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+(ﾟΘﾟ)+(ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (\u0026#39;_\u0026#39;); 使用开发者工具中控制台执行这段编码后的代码效果：\n\raaencode - 效果\r\n可以看到效果确实同alert(\u0026quot;nico\u0026quot;)。\n 【这是什么稀奇古怪又可可爱爱的编码方式啊.jpg……\njjencode 用途等同\u0026quot;aaencode\u0026quot;，\n不同在于jjencode使用$、=、+、_、[、]等符号进行编码。\n e.g.\n同上例，\nalert(\u0026#34;nico\u0026#34;) 将这段js代码用jjencode编码后，\n$=~[];$={___:++$,$$$$:(![]+\u0026#34;\u0026#34;)[$],__$:++$,$_$_:(![]+\u0026#34;\u0026#34;)[$],_$_:++$,$_$$:({}+\u0026#34;\u0026#34;)[$],$$_$:($[$]+\u0026#34;\u0026#34;)[$],_$$:++$,$$$_:(!\u0026#34;\u0026#34;+\u0026#34;\u0026#34;)[$],$__:++$,$_$:++$,$$__:({}+\u0026#34;\u0026#34;)[$],$$_:++$,$$$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+\u0026#34;\u0026#34;)[$.$_$]+($._$=$.$_[$.__$])+($.$$=($.$+\u0026#34;\u0026#34;)[$.__$])+((!$)+\u0026#34;\u0026#34;)[$._$$]+($.__=$.$_[$.$$_])+($.$=(!\u0026#34;\u0026#34;+\u0026#34;\u0026#34;)[$.__$])+($._=(!\u0026#34;\u0026#34;+\u0026#34;\u0026#34;)[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$=$.$+(!\u0026#34;\u0026#34;+\u0026#34;\u0026#34;)[$._$$]+$.__+$._+$.$+$.$$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$$+\u0026#34;\\\u0026#34;\u0026#34;+$.$_$_+(![]+\u0026#34;\u0026#34;)[$._$_]+$.$$$_+\u0026#34;\\\\\u0026#34;+$.__$+$.$$_+$._$_+$.__+\u0026#34;(\\\\\\\u0026#34;\\\\\u0026#34;+$.__$+$.$_$+$.$$_+\u0026#34;\\\\\u0026#34;+$.__$+$.$_$+$.__$+$.$$__+$._$+\u0026#34;\\\\\\\u0026#34;)\u0026#34;+\u0026#34;\\\u0026#34;\u0026#34;)())(); 运行后一样的效果。\n uuencode 是二进制信息和文字信息之间的转换编码。\n常用于电子信息的传输。\n 具体编码过程没有去了解。\n【能够了解并使用工具转换就可以了x……\njsfuck 跟\u0026quot;aaencode\u0026quot;和\u0026quot;jjencode\u0026quot;差不多。\n区别是：用六个字符[]()!+来重新编码。\nbrainfuck 跟\u0026quot;jsfuck\u0026quot;、\u0026ldquo;aaencode\u0026quot;和\u0026quot;jjencode\u0026quot;差不多。\n【你呀，总能给我玩点新花样【指js……\n区别是：用八个字符[]\u0026lt;\u0026gt;+-.,来重新编码。\nOok 比赛中常见。\n有两种形式。\n1. \u0026ldquo;Ook!\u0026rdquo; 由Ook.、Ook!、Ook?三个字符串组成。\n2. \u0026ldquo;Short Ook!\u0026rdquo; 只有.、!、?三个字符组成。\n 经典例题：\n在图片的lsb隐写中，藏有ShortOok!。\n\rOok - 经典例题\r\n 敲击码 是一种很简单的对文本信息进行编码的方式。\n基于$5\\times5$的方格（波利比奥斯方阵）来实现，\n区别在于：K字母被整合到C中。\n\r敲击码\r\n e.g.\nF，对应位置为$(2,1)$，所以可以编码为21。\n 二维码 用某种特定的几何图形按一定规律，在平面分布的黑白相间的图形，来记录数据符号信息。\n种类：\n 堆叠式/行排式（堆积式或层排式） 矩阵式  常见的二维码：\n Code 16K Code 49 PDF417 QR Code  \r二维码 - 常见形式\r\n矩阵式二维码 最流行的就是QR Code，\n也就是我们常说的二维码。\n其是在一个矩阵空间通过黑、白像素在矩阵中的不同分布进行编码。\n用点（方点、圆点或其他形状）的出现表示二进制1，\n不出现表示二进制0，\n点的排列组合确定了矩阵式二维码所代表的意义。\n矩阵式二维码是建立在计算机图像处理技术、组合编码原理等基础上的一种新型图形符号自动识读处理码制。\n代表性的矩阵式二维码：\n Code One MaxiCode QR Code Data Matrix Han Xin Code Grid Matrix  QR Code 特点  储存大容量信息。\n传统的条形码只能处理$20$位左右的信息量，QR码可以处理条形码几十到几百倍的信息量。 支持所有类型的数据。（如：数字、英文字母、日文字母、汉字、二进制、控制码等） 在小空间内可打印。\n使用纵向和横向两个方向处理数据，所以相同信息量，QR码所占空间为条形码十分之一。（Micro QR码可以更小） 解码速度快。  基本结构  格式信息：纠错等级 版本信息：即二维码规格（QR码符号共有$40$种规格的矩阵）  \r二维码 - 基本结构\r\n考点  将定位点拿掉，需要自己去补充定位点。 修复二维码。\n基于纠错等级，只给部分信息，需要自己补全。\n可以使用工具：QRazyBox。\n 解题方法：使用工具先调整纠错等级，使得跟残缺二维码一致；然后再手动填充。 \r  稀奇古怪的编码  以下编码由于特点明显，故不详细介绍。均可以直接搜索相关编码解码工具。 \r 社会主义核心价值观编码 特点：由社会主义核心价值观十二个词构成。\n与佛论禅 特点：开头为“佛曰：”。\n与熊论道 特点：开头为“熊曰：”。\n 0x03 写在最后  以上大部分为个人总结，由于这里也刚入门，很多地方可能存在错误。如发现错误请及时指出，谢谢！…… \r  由于目前博客不支持附件上传下载，所以如果需要上述中的文件，可以联系我分享文件【联系方式在关于页面中有…… \r  如对以上内容存在疑惑不解的地方，也可以询问我。如果我了解的话会尽力解答；不了解的话可以一起努力弄明白hhh…… \r\n感谢1cePeak师傅的辛勤付出！……\n以上……\n","date":"2021-02-02T00:00:00Z","image":"https://blog.supersassw.com/p/ctf-note-misc_2/87075144_p0_hu955303b5c4388e9f242f6715e6abbbd5_906682_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/ctf-note-misc_2/","title":"Misc - 数据编码……"},{"content":" 以下为涅普计划的课程笔记，建议搭配课程视频理解。 \r 图片隐写：\n将一些不可告人x的东西（如flag）以各种方式隐藏在图片中。\n自已需要分析出隐写方法，并找出隐藏的信息。\n0x00 课程视频 课程视频\r\r\r视频Bilibili链接\r 0x01 准备工具 十六进制编辑器  \u0026ldquo;010 Editor\u0026rdquo;\n优点：有模板（需要安装）\nTip: 复制16进制的快捷键为Ctrl+Shift+C。 \u0026ldquo;WinHex\u0026rdquo;  其实也称二进制编辑器，因为文件都是以bin二进制来存储的，不过为了阅读方便，将8位2进制串转化为2位16($2^4=16$)进制串。\n虚拟机——\u0026ldquo;Kail\u0026rdquo; 相关命令   strings\n打印文件中可打印的字符。\n作用：可找出图片中隐写的字符串。\n例子\r在终端中输入strings strings.jpg后\n可以看见\u0026quot;Nepnep{welcome}\u0026ldquo;和\u0026quot;print(hell oworld)\u0026ldquo;这两条信息。\r   grep\n用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。\n输入grep -a \u0026quot;flag\u0026quot; xxx.jpg\n则会把文件中含\u0026quot;flag\u0026quot;字符串部分前后显示出来。\n例子\r如图：\n可以看见\u0026quot;BJD{haokanma_xjj}\u0026ldquo;这个flag。\r   file\n用于辨识文件类型。\n可以显示文件的格式，属性等信息。\n例子\r对\u0026quot;strings-file\u0026quot;这个无后缀名文件进行分析。\n可以看见文件的基本信息，为JPEG文件。\n Tip: JPEG和JPG是同一个格式。 \r\r\r      binwalk\n用于搜索给定二进制镜像文件以获取嵌入的文件和代码的工具，即可以查看文件中含有的其他文件。\n在CTF中binwalk常用于分析隐藏文件。\n参数：\n -e 分离出文件到新文件夹中（但可能不全）。  例子\r输入binwalk xxx.png\n输入binwalk -e xxx.png 得到新文件夹，里面有提取出的文件。\n\r   foremost\n注意：需要使用apt-get install foremost安装。\n也可以提取文件（也不一定能提取所有文件）。\n比较于binwalk，binwalk更加强大，速度也快。但是有时候如果不能分离出来，就可以试试看foremost。\n例子\r输入foremost xxx.png后，得到output文件夹，其中目录树如图。\n其中png文件夹中为原图片，而jpg文件夹中则为分离处的新图片。\naudit.txt则为所分离文件的信息。\n\r   dd 搭配binwalk分析后，指定提取文件。\n命令为dd if=xxx.png of=out.jpg bs=1 skip=***\n 参数解释：\n if=xxx.png为要分离的文件名。 of=out.jpg为输出的文件名。 bs=1为每次读取几个块（一般为1）。 skip=***为从哪里开始读入（搭配binwalk分析后确定）。\n如上面输入binwalk命令后，可得知内含的JPEG文件从271007开始，则此处skip=271007。     0x02 知识点 文件头文件尾 每个文件格式有相应的文件头和文件尾，可通过十六进制编辑器查看。\n e.g.\n.jpg：开头——FF D8，结尾——FF D9。\n 重点：超过文件尾的部分不会被读取。\n文件模板 以十六进制查看方式打开后，若存在对应模板，\n则会将整个十六进制划分成一个个部分，每部分会有各自的作用。\n可根据模板的划分，快速确定某一部分十六进制代表什么意思，有什么作用，储存什么信息等。\n如图：\n\r文件模板\r\n可见通过PNG文件模板将十六进制分为了许多部分。\n最常用的信息如告知图片长宽、属性。\n文件属性 就是文件的属性【？……\n点击右键属性，可查看文件的一定属性信息。\n如图：\n\r文件属性\r\n0x03 图片隐写分类 \r图片隐写分类\r\n1. 属性隐写 【就单纯在文件属性（标题、作者等）中写东西，很少用……\n2. 16进制隐写 一般在文件的16进制格式中增添或修改，达到隐写字符串的目的。\n常见形式：\n 在文件尾后直接隐写内容。  原理：文件不会读取超过文件尾的部分。   e.g.\n\r16进制隐写 - 文件尾\r\n可以发现文件尾后还有niconiconi这个字符串。\n  在中间部分隐写内容。  原理：有些时候在中间处修改添加内容，是不会或略微影响文件正常读取的，从而达到隐写的效果。 判断方法：图片可能会有所怪异，如中间有条线。  e.g.\n\r16进制隐写 - 例题\r\n可以发现黑丝【？】那有明显的一条线。\n     对应方法：使用Linux命令中的strings或grep。\n使用例见上方虚拟机——\u0026ldquo;Kail\u0026quot;的命令部分\n 不给出文件后缀名，不能直接判断出这个文件是什么格式。\n可以通过16进制编辑器，查看对应的文件头，从而找出是什么格式。\n3. 文件包含 隐写的内容可能为简单的字符串，也可能为若干个新的文件。\n解决方法：\n 通过Linux命令binwalk来分析或binwalk -a尝试分离。 通过Linux命令foremost来尝试分离。 通过Linux命令dd来尝试分离。  以上三种命令的使用例见上方虚拟机——\u0026ldquo;Kail\u0026quot;的命令部分。\n 直接以16进制编辑器\u0026quot;010 Editor\u0026rdquo;，将所隐藏的文件16进制部分写入到一个新的文件后并打开。  4. 文件头修改隐写 将文件头修改或删除，文件将不能读取。\n但破坏文件尾可能不会影响读取。\n需要通过16进制编辑器查看文件头尾部分，分析出该有的文件头。\n5. gif 特殊帧 隐藏在帧中的信息。\n e.g.\n\rgif - 特殊帧\r\n【需要点击图片才能查看动图】\n可以明显看见图中会闪过一些东西。\n 一般选择逐帧分析的方法。\n【当然可以选择用手速来截图查看【b站视频闪过图片的常用方法x……\n 逐帧分析工具：\n PhotoShop\n会将每帧分为一层图层，即可查看。 Stegsolve.jar\n打开图片后，点击\u0026quot;Analyse\u0026quot;中的\u0026quot;Frame Browser\u0026quot;也可以逐帧查看。 Ulead GIF  帧的时间间隔 信息也可能隐藏在帧时间间隔中。\n e.g.\n很多帧都是$0.1$s，但某几帧是$0.2$s，就很有问题.jpg……\n 采用\u0026quot;Ulead GIF\u0026quot;来查看帧时间间隔。\n6. png(bmp) 长高修改(IHDR) 可能通过修改宽高，隐藏了某些信息，\n通过16进制编辑器来修改查看。\n其中宽高信息则在模板中IHDR部分里可查看。\n一般是修改高，因为修改宽会导致不能正常显示。\n并且修改得大一点更好，避免重复修改。\n e.g.\n\r长高修改 - 修改高\r\n\r长高修改 - 发现隐写信息\r\n将该图片的高增大后，则可发现隐藏信息。\n  判断是否高被修改的方法：\n  通过检验CRC32确定。 当用\u0026quot;010 Editor\u0026quot;打开图片后，若输出窗口中会报错，显示CRC32有问题，证明这张图片的属性（如本类中的高）被篡改过。\n e.g.\n\rCRC32错误显示\r\n 也可以手动计算校验和来比对。\n手动计算方法\r 先选中IHDR到crc之前的部分。\n对应模板中的\u0026quot;union CTYPE type\u0026quot;和\u0026quot;struct PNG_CHUNK_IHDR_ihdr\u0026quot;两个部分。\n 然后点击“工具”中的“校验和”，选择“CRC-32”。\n 得到计算结果后与crc部分比对即可。\n注意文件中的检验和是1FCF9E8E，没有那个h。  \r\n  脚本爆破来得到真实高度。\n就是暴力的意思，不断修改高度并比对校验和，如果一致则为正确高度。\n爆破python代码：\nimport os import binascii import struct misc = open(\u0026#34;***.png\u0026#34;,\u0026#34;rb\u0026#34;).read() # 请在这里填写要爆破的文件名 # 爆破高 crc32_bytes = misc[0x1d:0x20 + 1] # 文件IHDR块的crc32的bytes crc32_hex_eval = eval(\u0026#39;0x\u0026#39; + crc32_bytes.hex()) # 将crc32的bytes串 -\u0026gt; hex串 -\u0026gt; 值  for i in range(4096): data = misc[0x0c:0x0f + 1] + misc[0x10:0x13 +1 ] + struct.pack(\u0026#39;\u0026gt;i\u0026#39;, i) + misc[0x18:0x1c + 1] # 爆破IHDR数据 crc32 = binascii.crc32(data) \u0026amp; 0xffffffff # 计算当前crc32 if crc32 == crc32_hex_eval : print(\u0026#34;height:\u0026#34;, i) print(\u0026#34;height_hex: \u0026#34; + hex(i))   数据块IDAT修改 本来IDAT数据块是写满当前块后再换下一个块，\n但用\u0026quot;010 Editor\u0026quot;查看后发现有IDAT块有异常（不满足上述规律），故这个数据块可能藏有信息。\n检测方法：\n 使用pngcheck.exe来查看IDAT数据块情况。  e.g.\n输入pngcheck.exe -v ***.png后，\n\rpngcheck\r\n发现最后部分有异常。\n    将该数据块十六进制提取出来后，用脚本或其他方法得到信息。\n得到信息方法：\n \u0026ldquo;010 Editor\u0026rdquo; + \u0026ldquo;zlib.py\u0026rdquo;\n用010查看后得到异常部分的16进制，复制后放入脚本运行可得到信息。\n\rzlib得到信息\r 用binwalk -e提取，直接得到信息。 \rbinwalk得到信息\r  lsb隐写 为贝塔姐姐强调的部分。\n 「接下来我们讲一个大头er~」 —— 贝塔 \r 又称“最低有效位隐写”。\n将隐写内容转换为2进制，整合修改到图片2进制形式的最低位，使得颜色被修改程度极小，肉眼无法分辨。\n但可以通过某些命令或脚本来分辨出。\n不带密匙   通过\u0026quot;Stegsolve.jar\u0026quot;分析。\n用\u0026quot;Analyse\u0026quot;的\u0026quot;Data Extract\u0026rdquo;，一个个选项测试得到文本串或者新的文件。\n可参考\u0026quot;cat47\u0026quot;的文章stegsolve使用方法。\n  zsteg（很好用）\n使用命令zsteg xxx.png来查看各种方式下的文本串或者文件（如果这个命令中没有发现，则可以用zsteg -a xxx.png），\n然后用命令zsteg -e ...(分析的通道) \u0026gt; ***.xxx得到文件\n e.g.\n对某图片使用命令zsteg lsb.png后，\n\rzsteg - 分析\r\n发现b1,rgb,lsb,xy这个方式存在一个PNG文件。\n则使用命令zsteg -e b1,rgb,lsb,xy \u0026gt; ans.png得到文件。\n\rzsteg - 提取\r\n 可参考\u0026quot;β-AS\u0026quot;姐姐的文章隐写工具zsteg安装+使用教程。\n   带密匙 带密钥的可以用\u0026quot;cloacked-pixel\u0026quot;脚本。\n该脚本为python2环境，并且需要numpy、matplotlib、Pillow、pycrypto库的支持。\n 由于为过气python2环境（且并无python3版本），所需配置较为复杂，所有注意事项已写在下方折叠栏中。 \r cloacked-pixel脚本的各种注意事项\r同时安装python2和python3方法：\r请参考文章如何设置python2，python3，并添加环境变量。\r\rpython2库本地安装方式：\r感觉pip2现在好像不能在线安装库了【？……\n所以只能在pypi中将库下载到本地安装。\n选择合适的版本，下载到本地。\n下载完成后在cmd中，输入pip2 install ...(本地路径)。\n 路径快速输入方法：输入pip2 install后，将文件直接拖入cmd窗口中即可。 \r\r即可成功安装。\n参考自文章Python2.7本地安装numpy包\n\r\r上述库的下载地址：\r 以下库为个人挨个查询并对应版本后下载，均为Python2.7所能支持的最新版本，可直接下载后按上述安装方法安装。 \r\r numpy six cycle（需要先安装six） pytz kiwisolver python-dateutil backports.functools-lru-cache pyparsing matplotlib（需要先安装cycle、pytz、kiwisolver、python-dateutil、backports.functools-lru-cache、pyparsing） Pillow pycrypto（安装方法有所不同，请见python2.7 安装pycrypto库中“下载压缩包解压到本地”部分）\n同时安装时还需要\u0026quot;vcvarsall.bat\u0026quot;，方法为两步：   下载\u0026ldquo;Microsoft Visual C++ Compiler for Python 2.7\u0026rdquo;并安装。\n  按照完美解决“Unable to find vcvarsall.bat”错误中配置注册表。\n【其中路径为C:\\Users\\SuperSASSw\\AppData\\Local\\Programs\\Common\\Microsoft\\Visual C++ for Python\\9.0】\n不确定是否还需要配置环境变量（个人为配置了的），如果仍有问题，请点击开始菜单中的\u0026quot;Microsoft Visual C++ Compiler Package for Python 2.7\u0026quot;这个文件夹中，自己对应平台的\u0026quot;Visual C++ 2008 xx-bit Command Prompt\u0026quot;这个快捷方式。\n    以下折叠部分为安装crypto库所需库，但安装这个后发现不对（有个Random不存在orz……），\n查询后发现为上面那个\u0026quot;pycrypto\u0026quot;库。\n\r\rcrypto所需库\r shellescape PyYAML chardet certifi urllib3 idna requests（需要先安装chardet、certifi、urllib3、na） Naked（需要先安装YAML、requests）  \r\r 【弄了我好久啊这些库qwqqq太累了……\n\r\r\r 命令：\npython2 lsb.py extract ***.png *** KEY\n ***.png为源文件名。 ***为输出文件名。（由于不确定什么格式，可以先不加扩展名，用010查看后再加上对应扩展名） KEY为密匙。   e.g.\n输入命令python2 lsb.py extract lsb（123456）.png ans 123456\n\r带密匙的lsb - 使用脚本后结果\r\n打开ans后，发现直接为flag。\n\r带密匙的lsb - 打开ans文件\r\n bmp 用\u0026quot;wbStego4.3open\u0026quot;工具对bmp或pdf等格式文件进行加密解密。\n e.g.\n打开工具，按照步骤来执行就可以得到文件了。\n\rwbStego4.3open - 步骤2 选择方式\r \rwbStego4.3open - 步骤3 选择文件及类型\r\n\rwbStego4.3open - 步骤4 输入密匙\r \rwbStego4.3open - 步骤5 输入输出文件名\r\n\rwbStego4.3open - 结果\r\n  Tip: 这个软件不能直接关闭，需要用任务管理器结束orz…… \r  0x04 写在最后  以上大部分为个人总结，由于这里也刚入门，很多地方可能存在错误。如发现错误请及时指出，谢谢！…… \r  由于目前博客不支持附件上传下载，所以如果需要上述中的文件，可以联系我分享文件【联系方式在关于页面中有…… \r  如对以上内容存在疑惑不解的地方，也可以询问我。如果我了解的话会尽力解答；不了解的话可以一起努力弄明白hhh…… \r\n剩余部分因为时间原因没有继续讲啦_(:з」∠)_……\n看好久有时间自学一下【？……\n再次感谢贝塔姐姐的详细讲解！【第一节课真的超不容易的……\n之前没有接触过CTF，不过了解后对其兴趣很高……\n希望经过这次涅普计划的系统学习能有很大的收获吧√……\n以上……\n","date":"2021-02-01T00:00:00Z","image":"https://blog.supersassw.com/p/ctf-note-misc_1/86016044_p0_hu66f5a9c42e7a0ea12354f65ca719fe6e_1732854_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/ctf-note-misc_1/","title":"Misc - 图片隐写……"},{"content":"题目链接 P4863 JerryC Loves Driving\n题目分析 对于一层求和，其实就是一层for，那么两层求和就是两层for，也就是二维的。\n而对于求和O(n)的优化计算方法，最基本的就是转换为等差数列O(1)计算。\n我们将两层求和的每一项列表观察（看是否有等差数列），得出下表：\n\r求和表\r\n图片来自于「Insouciant21」的题解。\n观察发现，对于每一列，是类似呈等差数列的形式的，\n对于第$i$列，是由$i$个$0 \\sim n$的等差数列组成。\n 如第四列：为$4$个$0,1,2,\\cdots,n$的等差数列组成。\n 因此我们就可以O(1)计算出每一列的和，那么就只用按列循环依次求和，O(n)的时间内求出结果。\n 想到求解方法后，我们来确定求和计算范围。\n 以下以$A=2, B=7$来举例。\n \r求和表范围1\r\n对于题上给出的两个界：上界$A$和下届$B$，\n按照题中所给公式，最初始的范围，则对应图中红色框选内容。\n由于0部分不影响，所以也可以看成蓝色矩形部分。\n但如果直接这样进行计算，会发现会有很多要考虑的地方，或说运用等差数列时有很多边界的处理。\n 如图中所给例子：\n对于$2$这一列，则上方的$1$并不完全属于$n$个等差数列中，要排除。\n对于$3$这一列，则下方的$-2$并不完全属于$n$个等差数列中，要排除。\n 于是我们可以想到对于求$f(A \\sim B)$这一范围，可以转化为求$f(B)-f(A-1)$这两范围的差。\n如图所示：\n\r求和表范围2\r\n则可以只用考虑下界的不符合。\n 这是一个很重要的方法：\n将两个不确定的界的函数($f(x \\sim y)$)，转化为两个有一个确定的界的函数之差（$f(C \\sim x)-f(C \\sim y)$）。（如定积分中经常运用）\n 解题方法 $O(n)$方法 对于每一列$i$：\n其和（的绝对值）为：$i$个$1,2,3,\\cdots,n$的等差数列的和，加上剩余非等差数列的部分。\n每一列均为$n - 0 + 1$即$n + 1$项。\n等差数列部分：\n首项——$a_1 = 0$；\n末项——$a_n = (n + 1) / i - 1$；【原因是：首先项数有$n+1$项（包括0行），整除$i$，则得到等差数列的项数，那么末项$a_n = a_1 + (n-1)*d$，即为项数$-1$。\n项数——$n = (a_n - a_1) / 1 + 1$（公差为1），即为$a_n + 1$。\n非等差数列部分：\n每一项均为$a_n + 1$；\n前面已经计算了$cnt * i$项，所以剩余部分的项数为$n + 1 - (cnt * i)$。\n$O(\\sqrt{n})$方法 首先根据上述的规律可以发现：\n 每一个数重复次数是按列递增的。  第$1$列是$1,2,3,\\cdots,n$，每个数出现$1$次；第$2$列是$1,1,2,2,3,3,\\cdots,n,n$，每个数出现$2$次。\n  奇数行和偶数行的符号是一样的。  基于以上两点，我们发现：\n如果存在间隔的几列（使符号相同，能合并处理），满足他们有的数字为一样的（比如都只有$1,2,3$，只是出现次数不同）。\n 如求$f(33)$中\n 例一：\n第$9$列为$0,0,\\cdots,0;-1,-1,\\cdots,-1;-2,-2,\\cdots,-2;-3,-3,-3,-3,-3,-3,-3$（$9$个$0$，$9$个$-1$，$9$个$-2$，$7$个$-3$）\n第$11$列为$0,0,\\cdots,0;-1,-1,\\cdots,-1;-2,-2,\\cdots,-2;-3$（$11$个$0$，$11$个$-1$，$11$个$-2$，$1$个$-3$）\n为下图中蓝色两列。\n  例二： 第$12$列为$0,0,\\cdots,0;1,1,\\cdots,1;2,2,\\cdots,2$（$12$个$0$，$12$个$1$，$10$个$2$）\n第$14$列为$0,0,\\cdots,0;1,1,\\cdots,1;2,2,2,2,2,2$（$14$个$0$，$14$个$1$，$6$个$2$）\n第$16$列为$0,0,\\cdots,0;1,1,\\cdots,1;2,2$（$16$个$0$，$16$个$1$，$2$个$2$）\n为下图中橙色三列。\n \r举例求和表\r\n 那么这几列的等差数列，是可以合并为一个更大的等差数列一起求和的。\n 上例一中：\n第$9$列中的有$9$个$-1$、$9$个$-2$；\n第$11$列中的有$11$个$-1$、$11$个$-2$；\n于是这两列便可合并为$20$个$-1$，$20$个$-2$一起用高斯求和（等差数列求和）。\n 但对于最后的一项数（如上例一中的$-3$），因为出现次数不一致，不能很好的直接合并，需要单独处理计算，\n所以我们只能合并倒数第二项用高斯求和，然后对剩下的最后一项单独处理。\n这样就可以在计算的过程中合并几列同时计算，达到减少操作降低复杂度的效果。\n【不过至于是否为O($\\sqrt{n})$的复杂度我就没证了_(:з」∠)_……\n 那么重点就是：\n  怎么分奇偶，找到哪几列出现数字相同。\n 先算出这一列能出现的最大数，然后再用$n$除以这个数，得到只能出现到这个数的最大列。\n 比如求$f(33)$，处理第$9$列时，\n第$9$列能出现最大的数是$33/9$为$3$，但只能出现到$3$的最大列为$33/3$为第$11$列（可以配合上面给出的图来理解）。\n    怎么处理计算不能合并的最后一项。\n 首先最后一项这个数我们知道是好多（为$n/i$），所以关键是求他有多少个。\n由第一点发现可知，对于下一个间隔列，前面的项出现次数均多了$2$次，\n或者说最后一项出现次数依次减$2$。\n所以其实对于最后一项的出现次数，也是个等差数列。\n找到等差数列的几个参数求和，得到有多少个。\n 首项：对应最后一列$i$，总项数为$n+1$个，前面项每个数均出现了$i$次，一共有$N$个数（计算方法就是等差数列求项数）。 末项：对应第一列，计算方法同首项。 项数：就是合并了几项。   比如求$f(33)$，处理第$12$列时，最大列到$16$列\n 首项——第$16$列中：前面的项（$0$和$1$）均出现了$16$次，所以这一列最后一项（$2$）出现次数为$2$次。 末项——第$12$列中：前面的项均出现了$12$次，所以这一列最后一项出现次数为$10$次。 项数——合并了$12$、$14$、$16$列，项数为$3$. 则可求得最后一项$2$一共出现了$(2+10)*3/2=18$次。      怎么处理计算合并后的等差数列。\n 方法就同$O(n)$方法中求等差数列了，\n只是在最后一项（an）和乘的次数（由乘i变成了乘cnt）变了一点。\n对于合并后的出现次数，也是个高斯求和。\n 比如求$f(33)$，处理第$9$列时，最大列到$11$列\n第$9$列每一项出现次数为$9$次，\n第$11$列每一项出现次数为$11$次，\n所以一共出现$9+11 = 20$次，\n    个人代码  Pastebin链接。 \r //P4863 [JerryC Loves Driving](https://www.luogu.com.cn/problem/P4863) #include \u0026lt;bits/stdc++.h\u0026gt;#define ALL(NAME_i, BEGIN, TO) \\ int NAME_i = BEGIN; \\ NAME_i \u0026lt;= TO; \\ NAME_i++ #define SGN (nega ? -1 : 1) typedef long long LL; using namespace std; LL solve(int n) { LL ans = 0; bool nega = 1; for (ALL(i, 1, n)) { LL a1 = 0, //首项  an = (n + 1) / i - 1, //末项  cntSeq = an + 1; //项数  ans += i * ((a1 + an) * cntSeq / 2) * SGN; //先求等差数列的和  ans += (n + 1 - (cntSeq * i)) * (an + 1) * SGN; //再计算剩下的部分  nega = !nega; //变符号  } return ans; } LL solve_Odev(const int \u0026amp;n, bool odd) { LL ans = 0; int maxColumn; bool nega = odd ? 1 : 0; for (int i = odd ? 1 : 2; i \u0026lt;= n; i = maxColumn + 2) //注意赋值语句为maxColumn + 2，也就是合并处理完几列后，直接跳到处理完的列后面。  { //1. 怎么分奇偶，找到哪几列出现数字相同。  LL maxNum = n / i; //当前列能出现的最大数（或最后一项）  maxColumn = n / maxNum; //只能出现到这个数的最大列  if (odd \u0026amp;\u0026amp; !(maxColumn \u0026amp; 1)) //本来处理奇数列，但算出来最大列为偶数情况  maxColumn--; if (!odd \u0026amp;\u0026amp; (maxColumn \u0026amp; 1)) //本来处理偶数列，但算出来最大列为奇数情况  maxColumn--; /* 对应于上图中，当n = 33, i = 12时： maxNum = 2 maxColumn = 16\t【对应为 合并12~16列。 */ //2. 怎么处理计算不能合并的最后一项。  int minCnt = (n + 1) - maxColumn * maxNum, //首项——这几列中，最后一项出现最少的次数（为最后一列，用maxColumn）  maxCnt = (n + 1) - i * maxNum, //末项——这几列中，最后一项出现最多的次数（最当前列，用i）  cntColumn = ((maxColumn - i) \u0026gt;\u0026gt; 1) + 1; //项数——合并了几列  /* 注意的点： 1. 总项数为n+1个，因为0也算！ 2. 不为maxNum - 1，因为0也算！【前面项的项数为((maxNum-1) - 0) / 1 + 1，即maxNum */ int cntNum = ((maxCnt + minCnt) * cntColumn) \u0026gt;\u0026gt; 1; //求得关键——最后一项有多少个（高斯求和）  ans += maxNum * cntNum * SGN; /* 对应于上图中，当n = 33, i = 12, maxColumn = 16时： minCnt = 2\t【对应为 最后一列有2项 maxCnt = 10\t【对应为 第一列有10项 cntColumn = 3\t【对应为 合并了3列 cntNum = 18\t【对应为 最后一项由18个 */ //3. 怎么处理计算合并后的等差数列。  LL a1 = 0, //首项  an = maxNum - 1, //末项  cntSeq = an + 1; //项数  /* 以上跟O(n)方法的几乎一样。 区别在于当这一列完全为等差数列时（不存在不为等差数列的部分）： O(n)方法计算等差数列和，会包括最后一项； O(sqrt(n))方法计算等差数列和，不会包括最后一项。 */ int cnt = ((i + maxColumn) * cntColumn) \u0026gt;\u0026gt; 1; //合并后出现次数（高斯求和）  ans += cnt * (((a1 + an) * cntSeq) \u0026gt;\u0026gt; 1) * SGN; //（高斯求和）  } return ans; } LL solve_block(const int \u0026amp;n) { LL ans = 0; ans += solve_Odev(n, 0) + solve_Odev(n, 1); return ans; } /* LL slove_original(int A, int B) //最原始的做法，但考虑的会更复杂所以未完成为错误的 //错误点为为考虑开始部分为非等差数列 { LL ans = 0; bool nega = 1; for (ALL(i, 1, B)) { int seqBgeinIndex = A + max(i - A, 0), cnt = (B - seqBgeinIndex + 1) / i, seqEndIndex = seqBgeinIndex + cnt * i - 1; LL a1 = max(A / i, 1), an = a1 + cnt - 1; ans += i * ((a1 + an) * cnt / 2) * SGN; ans += (B - seqEndIndex) * (an + 1) * SGN; nega = !nega; } return ans; } */ int main() { int A, B; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;A, \u0026amp;B); //printf(\u0026#34;%lld\\n\u0026#34;, solve(B) - solve(A - 1));  printf(\u0026#34;%lld\u0026#34;, solve_block(B) - solve_block(A - 1)); } ","date":"2021-01-25T00:00:00Z","image":"https://blog.supersassw.com/p/acm-prac-2021_01_25/Yande-199983_hu24344327ed1750f50cc0e0aab802591d_7554577_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-prac-2021_01_25/","title":"ACM练习——P4863 JerryC Loves Driving……"},{"content":"数组课后练习题 判断题 第一、二、十八题（重要） 第一题\r 在对全部数组元素赋初值时，不可以不指定一维数组的长度。 \r\r知识点：\n 一位数组赋初值 【书 P121】  \r\r个人做错了这道题！\n\r\r答案与分析\r 错误 \r\r也就是说可以不指定数组长度……\n分析 如果提供了全部初始值数组，也可以不指定长度，编译提供会自动帮你指定。\n如：\nint a[] = {3,1,2,5,6,-2}; //编译系统会帮你指定为a[6] \r\r第二题\r 在对全部二维数组元素赋初值时，可以不指定二维数组的行数。 \r\r知识点：\n 二位数组赋初值 【书 P125】  \r\r个人做错了这道题！\n\r\r答案与分析\r 正确 \r\r分析 同一维数组， 如果提供了全部初始值数组，也可以不指定第一维长度，编译提供会自动帮你计算出长度并指定。\n但注意！\n不能省略第二维的长度。\n\r\r正确例子：\nint a[][3] = {1,2,3, 4,5,6, 7}; //编译系统会帮你指定为a[3][3] \n\r\r错误例子：\nint a[3][] = {1,2,3, 4,5,6, 7}; //编译系统无法确定长度 \n\r\r\r\r\r练习——第十八题\r 在给全部数组元素赋初值时，可以不指定二维数组中的常量表达式，例如int a[][] = {1,2,3,4,5,6}。 \r\r 作为之前二维数组的练习题。 \r\r个人做错了这道题！\n\r\r答案\r 错误 \r\r\r\r\r 第十题  定义一个一维字符数组有$50$个元素，用该一维字符数组表示一个字符串数组最多允许有$50$个字符 \r 知识点：\n 字符数组的容量 【书 P128】  \r 答案与分析\r 错误 \r\r分析 字符数组char []，容量比定义的长度要少一个。\n因为字符数组还要存一个末尾的/0，\n所以题上定义了$50$个元素（char a[50]），但实际上只能存$49$个字符。\n同理：如果一个字符串长度是$n$，\n则它占用的空间是$n+1$个。\n例子见考前总结中最后的第7点。\n\r\r\r  第十一、十三题 第十一题\r C++中各种数据类型的变量在定义后会被自动初始化为0。 \r\r知识点：\n 一维数组的初始值 【书 P121】  \r\r答案与分析\r 错误 \r\r分析 一般方式定义的数据类型，如int a，double b[10]，都是不会被赋初值的。\n 这也就是为什么我们不赋初值就使用它会报错的原因，因为里面有以前的脏数据 \r\r但如果加上static这个修饰词，定义为静态变量，就会被赋初值为0了。\n如：\nstatic int a; //a = 0 static int b[5]; //b1~b5 = 0 \r\r第十三题\r 静态（static）数组被定义时，数组的所有元素自动获取初始值0。 \r\r知识点：\n 静态一维数组 【书 P121】  \r\r答案与分析\r 正确 \r\r分析 同十一题，静态数组，里面所有元素自动赋初值为0。\n\r\r\r 第十七题  在C++中数组是具有一定顺序关系的若干相同类型变量的集合体。 \r 知识点：\n 数组的概念 【书 P120】  \r 答案与分析\r 正确 \r\r分析 纯概念题，记住！\n\r  第二十题（重要） 程序段：\nchar s1[10]; s1 = \u0026#34;program\u0026#34;; 是合法的使用。\n\r 个人做错了这道题！\n为一道很容易错的操作题。\n\r 知识点：\n 一维字符数组的定义 【书 P127】  \r 答案与分析\r 错误 \r\r分析 请仔细阅读书上P127中「1.一维字符数组的定义」！\n里面有很多没有讲到的点，但很容易错。\n\r 由第二十题衍生的练习题  作为第二十题相关的练习题。 \r 这些都是根据书上P127中「1.一维字符数组的定义」里面的内容所出题。\n故没有写分析，请仔细阅读书上事例来自行分析。\n第二十一题\r程序段：\nchar s1[10] = {\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;}; cout \u0026lt;\u0026lt; s1; 是合法的使用。\n\r\r个人做错了这道题！\n与二十二题很容易混淆！\n\r\r答案\r 正确 \r\r\r\r第二十二题\r程序段：\nchar sa[] = {\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;}; cout \u0026lt;\u0026lt; sa; 是合法的使用。\n\r\r个人做错了这道题！\n与二十一题很容易混淆！\n\r\r答案\r 错误 \r\r仔细看看与二十一题的区别在什么地方，\n很小的区别就造成了答案的不一样。\n\r\r第五十四题\r有如下的字符串数组定义语句：\nchar str1[] = {\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;}; char str2[] = {\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;\\0\u0026#39;}; char str3[] = \u0026#34;program\u0026#34;; 下列说法正确的是（）。\n A、str1中的数据可以作为一个整体（字符串）参加运算。\nB、str2和str3中的数据只能作为一个整体（字符串）参加运算。\nC、str2和str3中的数据既可以以元素为单位参加运算，也可以作为一个整体（字符串）参加运算。\nD、str1、str2和str3中的数据既可以以元素为单位参加运算，也可以作为一个整体（字符串）参加运算。\n所谓作为一个整体，即是如以下操作：\nstr1 = \u0026#34;abcd\u0026#34;; cout \u0026lt;\u0026lt; str1; 而以元素参加运算，即是如以下操作：\nstr1[2] = \u0026#34;a\u0026#34;; cout \u0026lt;\u0026lt; str1[3]; 如果只能以元素操作，则不能cout \u0026lt;\u0026lt; str1这样作为整体操作。\n\r\r\r\r个人做错了这道题！\n\r\r知识点：\n 二维数组的使用方法 【书 P125】  \r\r答案\r C、str2和str3中的数据既可以以元素为单位参加运算，也可以作为一个整体（字符串）参加运算。 \r\r\r\r\r选择题 第三十、三十一题 第三十题\r在下面的一维数组定义中，（）有语法错误。\n A. int a[] = {1,2,3};\nB. int a[];\nC. int a[] = {0};\nD. int a[5];\n\r\r知识点：\n 一维数组的初始化 【书 P121】  \r\r个人做错了这道题！\n为一道很容易错的操作题。\n\r\r答案与分析\r B. int a[]; \r\r分析  A、对于确定初始值的数组，可以不指定长度，是正确的。（见上面第一题） B、这种定义方式是不存在的，要么赋初值，要么指定长度。 C、很容易错选的选项，这种方式其实就代表定义个长度为1的数组，然后a[0]=0。是正确的。 D、基本的定义方式，是正确的。  注意还有一种定义类型int a[...] = {0}，代表定义个...长度的数组，其中全部赋初值为0。\n\r\r第三十一题\r在下面的二维数组定义中，（）有语法错误。\n A. int x[10][10];\nB. int x[][10] = {{1,3} ,5 ,7};\nC. int x[][];\nD. int x[10][10] = {0};\n\r\r知识点：\n 二维数组的初始化 【书 P125】  \r\r答案与分析\r C. int x[][]; \r\r分析   A、基本的二维数组定义方式，没赋初值，是正确的。\n  B、这里有赋初值，所以可以不用指定行数，是正确的。\n 最终数组状态为：\nx[0][0] = 1; x[0][1] = 3; x[1][0] = 5; x[2][0] = 7;    C、错因跟上一样。\n  D、这里就是第三十题说得，定义一个确定长度的二维数组，然后全部赋初值为0，是正确的。\n  \r\r\r第三十五题 定义一个一维数组，正确的语句是（）。\n A. int a(10);\nB. int n = 10; int a[n]\nC. int n; cin\u0026gt;\u0026gt;n; int a[n]\nD. const int n = 10; int a[n]\n\r 知识点：\n 一维数组的定义 【书 P120】  \r 答案与分析\r D. const int n = 10; int a[n] \r\r分析 首先A选项，不知道他在干嘛，直接排除。\n对于B、C、D选项，涉及到一维数组的定义这个知识点。\nB和C中的n均是变量，故错误。\nD中的n为常量（const），故正确。\n书上原话  在定义数组时，数组的大小必须是常量，而不能是变量或者变量表达式。 \r\r\r  第三十六题 以下哪种说法错误？（）。\n A. 数组中的元素在某些方面彼此相关。\nB. 数组中的所有元素具有相同的下标。\nC. 数组中的所有元素具有相同的数据类型。\nD. 数组中的所有元素具有相同的名字。\n\r 答案与分析\r B. 数组中的所有元素具有相同的下标。 \r\r分析 纯概念题，记住！\nB是错的很容易看出来，\n主要是A、C、D是对的要记住。\n\r  第五十二题 若有定义语句int a[3][6]，\n按在内存中的存放顺序，a数组的第$10$个元素是（）。\n 我出成了填空题！……\n请想出正确答案！……\n\r 知识点：\n 二维数组的使用方法 【书 P125】  \r 答案与分析\r a[1][3] \r\r分析 二维数组的存放方式，也是按着顺序存放的。\n并且先是按行顺序存放，一行存完了再换下一列。\n也就是按照a[0][0],a[0][1],a[0][2]\u0026hellip;a[0][5],a[1][0],a[1][1],\u0026hellip;,a[2][5]的顺序存放，\n所以第$10$个，就是$10 = 2 * 3 + 4$，也就是第$2$行第$4$列，为a[1][3]。\n\r  第五十九题 以下关于二维数组的说法中，错误的是（）。\n A. 若在定义二维数组的同时给其赋初值，则二维数组的列数可以省略。\nB. 二维数组的每一行相当于一个一维数组，因此二维数组可以看成是由一维数组构成的数组。\nC. 给二位数组赋值时，可以将所有元素写在一个{}内。\nD. 引用二维数组时，必须包含数组名、行下标和列下标。\n\r 知识点：\n 二维数组的各种概念 【书 P125】  \r 答案与分析\r A. 若在定义二维数组的同时给其赋初值，则二维数组的列数可以省略。 \r\r分析 纯概念题，记住！\n\r 未写入的题  第十二题——数组[]里能放的东西，只有常量和常量表达式 第十四题——数组不是C++基本数据类型 第十六题——数组再内存中是连续存在的（包括二维数组） 第十九题 （个人做错） ——字符串处理函数（strcpy、strcmp等）的头文件（\u0026lt;string.h或cstring或\u0026lt;iostream\u0026gt;），是不含string类的（头文件为\u0026lt;string\u0026gt;）。 第三十四题：  字符数组（char []）只能用字符串函数来处理（strcpy、strcmp）\n字符串（string）只能用运算符号（+、==）来处理。\n两者有各自对应的运算方式。\n   ","date":"2021-01-09T00:00:00Z","image":"https://blog.supersassw.com/p/univ-cpp-prac-array/Yande-314214_hua49f15ef087bdbbd47ec4ec6c539acdb_2635208_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/univ-cpp-prac-array/","title":"程序设计——数组习题……"},{"content":"以下为个人对教材中每章课后练习所出现的名字解释题进行的总结。\n教材为：心理学导论（第三版）——人民教育出版社 （黄希庭 郑涌 著）\n 由于老师跳过了第二章，并且教学进度被缩短的原因，对第二章以及第五章后部分名字解释未整理。 \r  带“心理学大辞典”的定义表示该定义是从「心理学大辞典」中查阅得来。 \r  斜体表示该名词未在课后练习中出现，但个人总结出来了，仅供参考。 \r 第一章 绪论 第一节 心理学的性质  心理学：心理学是一门研究心理现象的事实、机制、规律、和本性的实证科学。  一、个体心理现象概览 从个体心理的动态—稳态维度区分：\n 心理倾向：心理活动在特定时间里的指向状态。 心理过程：心理活动在一定时间内发生、发展的过程。  认知过程：个体获取知识和运用知识的心智活动。（人以感知、记忆、思维等形式反映客观事物的性质和联系的过程——心理学大辞典） 情绪过程：产生心理现象的历程。（人对客观事物的某种态度的体验——心理学大辞典） 意志过程：力图达到有目的、有计划地改造世界的心理过程。（人有意识地克服各种困难以达到一定目的的过程——心理学大辞典）   心理特征：一个人心里活动中经常表现出来的稳定特点。  三、心理学的科学性  可复制性：一项科学研究的结果是能够按照原创者所提供的研究方法精确加以重复验证的。 可证伪性：在表述一个科学理论时，必须遵循从该理论所推导出各种预测有可能被证伪。 系统性：心理学的科学知识是通过系统的实证研究而获得的。  第二节 心理学的方法 一、心理学研究的基本原则  可公开检验原则：科学发展是可以由任何人重验、批评、否定或继续发展的。 主客观资料科学整合原则：对人的心理研究中必须考虑把所有收集到的客观资料与主观资料科学地整合起来。 人文关怀原则：心理学研究者在科学研究中应遵守心理学家的职业道德。 操作性定义：以可观察、可测量的操作给一个概念下定义。  二、心理学研究的基本变量  刺激变量（S）：能够引起机体反应的刺激特征。 机体变量（O）：个体自身特征。 反应变量（R）：刺激引起在行为上发生变化的反应种类和特征。  三、心理学研究的基本方法  实验法：在控制的条件下系统地操纵某种变量的变化，来研究该变量的变化对其他变量产生的影响。（心理学大辞典 P1131）  自变量：研究者选定并在试验中操纵、掌握，以影响被试行为的因素。 因变量：被试的反应，即研究者想要预测的行为。 控制变量：除了自变量会对因变量影响之外，所有其他因素都应保持恒定或加以控制。 无关变量：与实验目的无关的变量。 实验组：专门接受实验处理的一组被试。（心理学大辞典 P1135） 控制组\u0026lt;对照组\u0026gt;：不受实验处理的被试组。（心理学大辞典 P700）   准实验法：在实验研究的设计上或情景控制上不具备实验法的一个或两个基本条件的研究方法。 问卷法：用问卷提问题的方式，要求被调查者就某个或某些问题问答自己的想法。  相关系数：用来度量两个或几个变量之间相互联系的性质和程度的指标。   演绎法：从理论或假设出发得出结论来验证其对心理现象或行为变化的预测和解释力的论证方法。 质性研究法：对特定的心理现象、行为、团体互动进行深入系统的观察、资料收集、分析理解，从而对所研究的心理现象或行为特征及其发展脉络提供具体、系统的描述。  归纳法：由繁到简、由特殊情形推论出普遍规则的过程。    第三节 心理学的历史  构造主义 机能主义 行为主义 格式塔心理学 精神分析 人本主义心理学  第四节 当代心理学的特点  生物学取向：着重从生物、生理、遗传基因的角度研究心理与行为。 行为取向：着重研究个体的行为是怎样受到环境和经验影响的。 认知取向：主张用信息加工观点来研究人类心理过程和结构。 社会文化取向：着重研究社会文化怎样影响个体的心理与行为。 心理动力学取向：着重研究个体心理与行为的动力因素。   第三章 心里的生物基础 第一节 神经系统与神经元  神经系统：由巨量神经细胞形成的神经组织与结构的总称。  一、中枢神经系统的结构和机能  中枢神经系统：是人体神经系统的主要部分，包括脑和脊髓\n功能：传递、储存和加工信息，产生各种心理活动，支配与控制人的全部行为。  二、周围神经系统的结构和机能  周围神经系统：从中枢神经系统发出，导向人体各部分，可分为躯体神经系统和自主神经系统\n功能：与身体各部分的联络工作，起传入和传出信息的作用。  三、神经元的结构和机能  神经元：是神经系统结构和功能的基本单位。 全或无定律：当刺激强度未达到某一阈值限时，神经冲动不会发生；而当刺激强度达到该值时，神经冲动发生并能瞬时达到最大强度，此后刺激强度即使再继续加强或减弱，已诱发的冲动强度也不再发生变化。 突触：相邻神经元其间的空隙。（神经元之间或神经元与效应器细胞之间传递信息的结构——心理学大辞典 P1264）  第三节 脑机制的研究方法 三、脑电图及事件相关电位  脑电图：在头皮表面记录到的自发节律性电活动。 事件相关电位：通过平均叠加技术从头颅表面记录大脑诱发电位，来反映大脑高级心理活动过程中大脑的神经电生理改变。  五、脑成像技术  功能性磁共振成像：功能更强的磁共振成像（磁共振成像：运用磁场原理来产生体内活动的图像），甚至可以使大脑的活动可视化。  专栏3-2\n 裂脑：切断大脑两半球之间的连结以研究人与动物的一种技术。（心理学大辞典 P758）  第四节 内分泌系统  内分泌系统：机体内对行为起重要调节作用的一个系统，由全身不同部位的多种内分泌腺体和组织细胞组成。 激素：内分泌腺所分泌的物质。  第五节 遗传对行为的影响  遗传：亲子之间以及子代个体之间性状存在的相似性，表明性状可以从亲代传递给子代。 基因型：个体的整个遗传禀赋。 表现型：在特定的环境中具有一定基因型的个体遗传得以实现的程度。 选择性繁殖：对动物特性遗传的一种研究方法。 双生子研究：一种研究方法，用于探讨遗传和环境因素对个体心理和行为发展的影响或作用。（心理学大辞典 P1175）   第四章 心理的环境基础 第一节 环境的内容 一、什么是环境  环境：与有机体发生联系的外部世界。 自然环境：环绕人们周围的各种自然因素的总和。 社会环境：人类生存及活动范围内的社会物质、精神条件的总和。 物理环境：除包括自然环境诸因素外，还包括人为的物理环境因素。 心理环境：人与人，人与物相互作用时所形成的环境。 情景：指一定场合下能被个体感知到的那一部分环境。  三、心理学家关于环境的理论  地理环境：显示的环境。 行为环境：个人意想中的环境。 生态系统理论：心理学发展环境理论，认为环境是由微系统、中系统、外系统、大系统四个由近及远的子系统组成的一个有层次序列的系统。（心理学大辞典 P1112）  第二节 自然环境 一、空气质量  空气污染综合征：受到长期的空气污染导致的症状，出现头疼、疲劳、失眠、消沉等症状。  二、噪声  噪声：一种非周期性的、无组织的、不定型的听觉刺激。  三、社会密度与拥挤  社会密度：一个给定的空间里所拥有的人数。 拥挤：一种感到空间不够大的主观感受。  第三节 社会环境 一、文化传统  文化：有广义、狭义之分。  狭义的文化：观念形态的文化，仅限于意识形态。 广义的文化：人类社会的全部遗产，囊括社会生活的全部领域。   亚文化：在社会的某一群体中形成一种既包括民族的一些主文化特征，也包括某些独特的文化特征的生活方式的这种群体文化。  第四节 社会影响  社会影响：运用个人或团体的社会力量在特定的方向上改变他人的观念和行为的过程。  一、从众与服从  从众：个人的观念和行为由于群体直接或隐含的引导或压力而与多数人保持一致的倾向。 服从：个体在他人的直接命令下而做出某种行为的倾向。  专栏4-3\n 角色\u0026lt;社会角色\u0026gt;：期望与个人的、训练个人的并鼓励他在一定社会情况中去完成某种权利、义务和责任的任何行为模式。   第五章 毕生心理发展  毕生发展：人类个体从受精卵开始，逐渐发育、成熟直至死亡，整个生命全程的与年龄有关的那些变化过程。  第一节 心理发展的基本观点 一、遗传与环境的交互作用  反应的交互作用：面对环境刺激，不同遗传基因的个体会以不同的方式来对其做出反应。 唤起的交互作用：个体的行为特征会招致人们对其的不同反应。 超前的交互作用：个体主动选择和创造他们所喜欢的环境，这些环境反过来又进一步作用于个体。  二、发展的连续性与变化性  发展的连续性：个体特征不因年龄增长而发生改变。 转折点：个体在发展过程中在几种途径中做出选择，从而导致个体生活环境的根本性变化。  三、发展中的个别差异  年龄特征：人类生理心理发展在各年龄阶段中大多数个体所表现出来的共同特征。 个别差异：受遗传基因与环境的不同影响，不同个体之间在身心特征上各不相同的现象。  四、心理发展的研究设计  横断研究：在同一时间内或较短时间内对某一个年龄或某几个年龄层次的个体或个体群组的发展水平进行观测与研究，并加以比较的一种研究设计。 纵向研究：对某一特定个体或某一组特定的个体随着其年龄的增长在其发展的不同阶段系统地进行反复观测，从而取得连续性的发展资料。  第二节 孕期与婴儿期 二、婴儿期的发展  依恋：婴儿依附于养育者的一种社会情绪性联系。  第三节 幼儿期与儿童期 一、认知发展  图式：个体灌注经验的心理模具。 同化：个体用现有的图式去理解事物。 顺应：使图式适应新经历的特殊性。 感觉运动阶段：0~2岁，指婴儿只能通过“这里”与“现在”来理解这个世界，只有那些能感觉和接触到的东西才是真实的。 前运算阶段：2~7岁，这一阶段儿童依靠的更多是感觉而不是逻辑。同时还表现为，总是从自己的观点看世界，不能从别人的观点直觉事务，称为自我中心主义。 具体运算阶段：7~11岁，儿童能依据具体事例进行推理思考，不会只依据表面现象，而是更有逻辑地进行思考，有了守恒的观念。 形式运算阶段：11岁以上，儿童能运用抽象的、符合形式逻辑的推理方式去思考问题。  ","date":"2021-01-08T00:00:00Z","image":"https://blog.supersassw.com/p/univ-intro_psychol-ne/67450790_p0_hu64a059195139e470f4d36bc000798f35_624654_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/univ-intro_psychol-ne/","title":"心理学导论——名词解释……"},{"content":"指针课后习题 判断题 第一题  从内存单元中存取数据的方法有直接访问方式和间接访问方式。 \r 知识点：\n 内存单元的数据存取方式 【书 P186】  \r 答案与分析\r 正确 \r\r分析  直接访问方式：通过变量名存取变量内容。  如a = 2、cout \u0026lt;\u0026lt; a。\n  间接访问方式：通过 地址（即指针） 操作。  如*a = 5、cout \u0026lt;\u0026lt; *a。\n   \r  第二题  能够直接赋值给指针变量的整数是$0$和$1$。 \r 知识点：\n 指针赋值 【书 P187】  \r 答案与分析\r 错误 \r\r分析 整数中，只有$0$才可以赋值指针，代表空地址（NULL）。\n书上原话 “地址”，可以是变量的地址、数组名、函数名等，也可以是数值$0$（或NULL）。\n没有任何对象会被分配到地址0（或NULL），因此数值$0$（或NULL）是可以直接赋给指针变量的唯一整数。\n\r\r\r  第四题  “变量的指针”含义是指该变量的地址。 \r 个人做错了这道题！\n为一道很新颖的概念题。\n\r 答案与分析\r 正确 \r\r分析 纯概念题，记住！\n\r  第九题 在操作一个一维数组时，可能会用到两个指针变量指向该数组，\n这两个指针变量之间可以进行关系运算，其关系运算的结果表明了这两个指针变量所指向的数组元素的先后关系。\n\r 个人做错了这道题！\n为一道很新颖的概念题。\n【个人甚至都不知道这种方法……\n\r 知识点：\n 指向一维数组的指针的关系运算 【书 P190】  \r 答案与分析\r 正确 \r\r分析 当有两个指针指向同一个数组时，\n可以对这两个指针进行比较（\u0026lt;、\u0026gt;），以反应这两个指针的位置关系。\n例子\r假设：\n存在数组int a[10]，\n存在两个指针int *p1,*p2。\n这两个指针均指向数组a中某个位置（如p1=\u0026amp;a[4]，p2=\u0026amp;a[8]）\n 若p1 \u0026lt; p2，则代表p1所指向的数组元素，在p2所指向的数组元素前面。 若p1 = p2，则代表p1、p2指向数组中同一个元素。 若p1 \u0026gt; p2，则代表p1所指向的数组元素，在p2所指向的数组元素后面。  具体可以看书上，有图示来解释。\n\r\r\r  第十题 对于已经定义好的相同类型的两个指针变量，可以进行加法运算、减法运算和赋值运算。\n\r 个人做错了这道题！\n为一道很新颖的概念题。\n【个人甚至都不知道这种方法……\n\r 知识点：\n 指针间的运算 【书上没找到对应知识点】  \r 答案与分析\r 错误 \r\r分析 指针间存在三种运算。\n 假设两指针int *a,*b。\n 赋值运算（a = b）\n代表最基本的赋值。 关系运算（a \u0026lt; b）\n代表a和b位置关系。【一般用于数组中，代表谁指向前面谁指向后面】 减法运算（a - b） 代表a到b之间的距离。【一般用于数组中，如a = \u0026amp;arr[5]，b =\u0026amp; arr[7]，则a-b为$2$】   上述题错在：没有加法运算。\n\r  第十九题 使用动态储存分配时，用运算符new获取的内存空间，不必须用delete进行释放。\n\r 个人做错了这道题！\n为一道很新颖的概念题。\n\r 知识点：\n 动态存储分配 【书 P201】  \r 答案与分析\r 错误 \r\r分析 纯概念题，记住！\n书上原话 用new获取的内存空间，必须用delete运算进行释放，并且对同一个内存空间只能执行一次delete。\n\r\r【虽然个人感觉确实不用的，因为程序结束会自动帮你释放xd……\n 注意只能delete一次 \r\r\r  第二十二题 设int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12}, (*p)[5];，\n则使用p = a语句是不合法的。\n\r 个人做错了这道题！\n\r 知识点：\n 数组指针变量 【书 P196】  \r 答案与分析\r 错误 \r\r分析  个人暂时也不知道原因，正在询问老师【…… \r\r感觉是题目错了……\n\r  选择题 第三十三、三十四、三十七、三十八题 因为这几道题考点相同，故放在一起形成对照。【区别仅在++的位置】\n第三十三题\r设有如下程序段，输出的值为（）\nint x = 8, *p = \u0026amp;x; cout \u0026lt;\u0026lt; *p++ \u0026lt;\u0026lt; endl;  A. $8$\nB. $9$\nC. $8$的地址\nD. $9$的地址\n\r\r答案与分析\r A. 8 \r\r分析 这里面先是运算*p，得到值$8$，\n然后就变成了cout \u0026lt;\u0026lt; 8++ \u0026lt;\u0026lt; endl;，这个时候就是先返回结果再运算。\n也就是先输出$8$，然后再*p = *p + 1变成$9$。\n\r\r第三十四题\r设有如下程序段，输出的值为（）\nint x = 8, *p = \u0026amp;x; cout \u0026lt;\u0026lt; ++*p \u0026lt;\u0026lt; endl;  A. $8$\nB. $9$\nC. $8$的地址\nD. $9$的地址\n\r\r答案与分析\r B. 9 \r\r分析 注意这里面还是先运算*p，得到值$8$，\n然后就变成了cout \u0026lt;\u0026lt; ++8 \u0026lt;\u0026lt; endl;，这个时候就变成了先运算再返回结果。\n也就是先*p = *p + 1变成$9$，然后再输出$9$。\n总之前两道题，都是先运算*p。\n\r\r第三十七题\r设有定义语句：\nint a[10]={0,1,2,3,4,5,6,7,8,9},*p = a; 则数值不为$3$的表达式为（）。\n A. a[3]\nB. p[3]\nC. p += 2, *(p++)\nD. p += 2, *(++p)\n\r\r个人做错了这道题！\n为一道很容易错的操作题。\n\r\r答案与分析\r D. p += 2, *(++p) \r\r分析 首先A、B选项，直接能看出a[3]和p[3]均为数组第四个元素，即为$3$。\n所以讨论C、D选项。\n注意这里的指针，变成了指向数组的指针。\n所以是可以进行加法操作的，代表指向位置的移动。\n刚开始均有一个p += 2，也就是指向了第三项a[2]为$2$。\n然后这里打了括号，所以肯定先是运算括号里的东西。\n那么p++和++p的区别，也就在于是先返回值还是先加一。\n 对于++p，先运算，也就指向了a[3]，再返回值。那么还是$3$。 对于p++，先返回值，也就是a[2]，那么a[2]的值就为$2$了。  故选择C。\n\r\r练习——第三十八题\r设int x[] = {1,2,3,4,5,6}, *p = x;\n则数值为$3$的表达式是（）。\n A. p += 2, *++p\nB. p += 2, *p++\nC. p += 3, *p\nD. p += 2, ++*p\n\r\r 作为之前三道题的汇总练习题。 \r\r答案与分析\r B. p += 2, *p++ \r\r分析 没打括号的时候，*p最先运算。\nA中，*与p被++隔开了，所以只能先运算++p。\n 如果换成p += 2, *(p++)，也是正确答案。\n不过其运算过程与B完全不一样，运算后的结果更不一样！ \r\r\r\r\r 第三十九、四十、四十九、五十题 因为这几道题考点相同，故放在一起形成对照。\n第三十九题\r设有定义语句：int a[5], *p = a;，\n则下列描述错误的是（）。\n A. 表达式p = p + 1是合法的\nB. 表达式a = a + 1是合法的\nC. 表达式p - a是合法的\nD. 表达式a + 1是合法的\n\r\r答案与分析\r B. 表达式a = a + 1是合法的 \r\r分析 需要注意到：数组名其实也是一个指针，代表这个数组的起始位置，相当于\u0026amp;a[0]。\n但其是常量指针，故不可以执行赋值语句。\n也就是a + 1是对的，代表\u0026amp;a[0] + 1，\na = a + 1是错的，没法把\u0026amp;a[0] + 1赋值给\u0026amp;a[0]。\n\r\r第四十题\r有下面语句int a[10] = {10,9,8,7,6,5,4,3,2,1}, *p = a，\n则数值为$2$的表达式是（）。\n A. a[9]\nB. *p[8]\nC. *(a+8)\nD. p+8\n\r\r个人做错了这道题！\n【虽然是我没认真看题错的_(:з」∠)_……\n\r\r答案与分析\r C. *(a+8) \r\r分析  A、a[9]，代表的是数组第十个元素，也就是$1$。 B、p[8]的时候，已经代表的是第九个元素的值了，所以不能再加*。\n也就是说如果选项是p[8]就是对的，*p[8]存在语法错误。 C、*(a+8)，也就相当于a[8]，故为$2$，正确。 D、p+8，代表的是第九个元素的地址，不是里面的值。\n也就是说如果选项是*(p+8)就是对的。  \r\r第四十九题\r若有定义int a[10], *p = a;，\n对数组元素错误的使用的语句是（）。\n A. *(a+1)\nB. *(p++)\nC. p[1]\nD. *(a++)\n\r\r答案与分析\r D. *(a++) \r\r分析 跟前两道题一样，关键是多了++这个自增运算符。\n对于B，p是个指针变量，是可以执行自增（或说赋值）的语句的。 而对于D，p是个指针常量，是不能执行自增（或说赋值）的语句的。\n\r\r练习——第五十题\r若有定义int a[] = {0,1,2,3,4,5,6,7,8,9}, *p = a, i;，\n对数组元素正确的使用的语句是（）。\n A. a[p]\nB. p[a]\nC. p+12\nD. a[p-a]\n\r\r 作为之前三道题的汇总练习题。 \r\r答案与分析\r D. a[p-a] \r\r分析 注意[]里面，只能为具体的数值\n也就是说A、a[p]和B、p[a]均错误，\n因为[]里是地址，而不是数值。\n A改为a[*p]，则正确，代表a[0]，\nB改为p[*a]，则正确，代表p[0]（即a[0]）。\n 但如果数组元素换位int a[]={-1,0,1,2,3,4,5,6,7,8}，\n那么即便改为a[*p]也不正确，因为其代表a[-1]，对数组元素使用错误。\n\r\rC是很明显的数组越界。\nD中，前面的题（第十题）介绍过，指针间存在减法运算。\n那么这道题中p-a的运算结果为$0$（因为指向同一位置a[0]，之间不存在距离），\n然后a[0]是正确使用。\n\r\r\r 第四十三题 设char str[] = \u0026quot;hello\u0026quot;, *p = str;，\n则*(p+5)的值是（）。\n A. 随机值\nB. 字母o\nC. 字符串结束标志\\0\nD. 字母o内存的地址\n\r 答案与分析\r C. 字符串结束标志\\0 \r\r分析 *(p+5)，也就是从字符串开头往后数$5$位。\n会发现，最后只能往后数$4$位到o，\n别忘了在字符数组char []中，最末尾还会有一个看不见的\\0这个东西，\n所以存在*(p+5)，代表的就是\\0。\n\r  第四十六题 设有定义语句int *p[4];，\n则标识符p是（）。\n A. 一个指向整型变量的指针变量\nB. 一个指向整型的指针数组名\nC. 一个指针，它指向一个含有四个整型元素的一维数组\nD. 一个非法的定义语句\n\r 个人做错了这道题！\n【虽然是我没认真看题错的_(:з」∠)_……\n\r 答案与分析\r B. 一个指向整型的指针数组名 \r\r分析 就注意一下这种定义方式，\n其类型就是一个指向整型的指针数组名。\n\r  第五十一题 若有定义：int a[] = {1,2,3,4,5,6,7,8,9,10}, *p = a;，\n则数值为$7$的表达式为（）。\n A. *(p+7)\nB. p[*(a+6)]\nC. p+6\nD. a[*(p+5)]\n\r 个人做错了这道题！\n\r 答案与分析\r D. a[*(p+5)] \r\r分析 首先很容易判断出A，其数值为$8$，\nC，其没有加*，故代表的是a[6]的地址。只有加了*，即*(p+6)才数值为$7$。\n而B、D，关键要先把[]内部的给运算出来，\nD中，*(p+5)的值为$6$,而a[6]的值为$7$，\n所以D的最终值为$7$，符合题意。\n\r  第五十四题 若有定义：int a[3][4]，\n能正确表示数组a中元素地址的是（）。\n A. *(a[1]+4)\nB. *(*(a+3)+1)\nC. *(a[1]+2)*\nD. *(*(a+1)+1)\n\r 个人做错了这道题！\n为一道很混淆的操作题。\n\r 答案与分析\r D. *(*(a+1)+1) \r\r分析  个人暂时也不知道原因，正在询问老师【…… \r\r觉得C好像也是对的……\n\r  没写入的题  以下题均为比较新的概念题，但个人没有写入，还是推荐去看一下记一下。 \r  第六题——常量是否能赋给指针 第七题——数组名代表数组首地址 第四十五题——int *point = new int(4)，这段代码的执行顺序  ","date":"2021-01-08T00:00:00Z","image":"https://blog.supersassw.com/p/univ-cpp-prac-point/Yande-308381_hubfc4b78b5f13c939fbd8620a241a68e1_9631758_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/univ-cpp-prac-point/","title":"程序设计——指针习题……"},{"content":"文章目录  发现锚点在个人简介(About)页面不生效，待修正…… \r 在左侧侧边栏增加了显示文章目录（Table Of Content）的功能……\n测试 这是h3…… 这是另一个h3…… h4以下默认是不会显示的qwqqq…… 很短的内容……\n没了！……\n另外的h3【1】…… 另外的h3【2】…… 另外的h3【3】…… 另外的h3【4】…… 另外的h3【5】…… 这里分隔一下……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n另外的h3【6】…… 另外的h3【7】…… 另外的h3【8】…… 另外的很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长h3【⑨】…… 长内容！……\n长内容！……\n长内容！……\n长内容！……\n长内容！……\n长内容！……\n超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级长内容！……\n长内容！……\n长内容！……\n长内容！……\n长内容！……\n长内容！……\n长内容！……\n测试h2……  参考文章或主题  hugo主题——Eureka  js借鉴于这个主题，然后个人加以修改实现的……\n  js实现滚动条自动滚动（scrollTop）  主要是依此了解了scrollTop的用法……\n  如何用js自己实现Animate运动函数  有关滚动动画的实现js来源处（极其感谢wuwuwu……\n   ","date":"2021-01-07T00:00:00Z","image":"https://blog.supersassw.com/p/test-toc/66488487_p0_hu927bcdeee8a2673c7ad35386c9152871_481055_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/test-toc/","title":"Table Of Content测试……"},{"content":"扩展Shortcode  以下Shortcode均来自Hugo的Hugo Book主题…… \r 一、columns 分栏显示内容……\n使用方法 {{\u0026lt; columns \u0026gt;}} Content_1 (With Markdown) \u0026lt;---\u0026gt; Content_2 {{\u0026lt; /columns \u0026gt;}} 使用例 左侧栏 OI的发生，到底需要如何做到，不OI的发生，又会如何产生。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 塞涅卡在不经意间这样说过，真正的人生，只有在经过艰难卓绝的斗争之后才能实现。这启发了我， OI因何而发生?我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 既然如此， 了解清楚OI到底是一种怎么样的存在，是解决一切问题的关键。 既然如何， 现在，解决OI的问题，是非常非常重要的。 所以， 问题的关键究竟为何? 经过上述讨论就我个人来说，OI对我的意义，不能不说非常重大。 所谓OI，关键是OI需要如何写。 一般来讲，我们都必须务必慎重的考虑考虑。 OI的发生，到底需要如何做到，不OI的发生，又会如何产生。 既然如何， 那么， 既然如何， 我们不得不面对一个非常尴尬的事实，那就是， 歌德曾经说过，没有人事先了解自己到底有多大的力量，直到他试过以后才知道。我希望诸位也能好好地体会这句话。中间栏 俾斯麦曾经说过，对于不屈不挠的人来说，没有失败这回事。带着这句话，我们还要更加慎重的审视这个问题： 要想清楚，OI，到底是一种怎么样的存在。 每个人都不得不面对这些问题。 在面对这种问题时， 培根曾经说过，要知道对好事的称颂过于夸大，也会招来人们的反感轻蔑和嫉妒。我希望诸位也能好好地体会这句话。 生活中，若OI出现了，我们就不得不考虑它出现了的事实。 就我个人来说，OI对我的意义，不能不说非常重大。 既然如何， 塞涅卡在不经意间这样说过，生命如同寓言，其价值不在与长短，而在与内容。我希望诸位也能好好地体会这句话。右侧栏 所谓OI，关键是OI需要如何写。 所谓OI，关键是OI需要如何写。 那么， 既然如何， OI，到底应该如何实现。 带着这些问题，我们来审视一下OI。 我们不得不面对一个非常尴尬的事实，那就是， 所谓OI，关键是OI需要如何写。偷偷摸摸栏？…… 测试……  中间的文本尽量不要太长，不然会占用很大竖直空间…… \r 二、details 内容折叠栏……\n使用的为HTML的details标签……\n使用方法 {{\u0026lt; details \u0026#34;Title\u0026#34; [open] \u0026gt;}} content {{\u0026lt; /details \u0026gt;}}  open为可选项，加入open代表默认打开……  另一种方法：\n{{\u0026lt; details title=\u0026#34;Title\u0026#34; open=true \u0026gt;}} content {{\u0026lt; /details \u0026gt;}} \n\r 使用例 源码 {{\u0026lt; details \u0026#34;折叠内容……\u0026#34; \u0026gt;}} 这里面是折叠内容…… {{\u0026lt; /details \u0026gt;}} 效果 折叠内容……\r这里面是折叠内容……\r\r 嵌套测试 不要点开看！……\r不要看！…… 都说了不要点开啦qwqqq快关上！！……\n都说了不要点开啦qwqqq快关上！！……\n都说了不要点开啦qwqqq快关上！！……\n都说了不要点开啦qwqqq快关上！！……\n都说了不要点开啦qwqqq快关上！！……\n真的不要看啦【【…… 再这么看人家超害羞的(*/ω＼*)……\n 诶诶还不关上嘛！……\n真拿你没办法，那就给你看看我多年的代码实力吧！【x……\n#inculde(iosteam) using namespace qwq; int mian() { int a,b; cin\u0026lt;\u0026lt;a+b; cout\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; }  诶诶不喜欢嘛？……\n那那来看看世界第一可爱的童田明治吧！……\n\r\r\rがぶがぶ……\r11歳の、5歳です！……\r\r\r\r\r  内嵌的时候请不要使用\u0026gt; {{\u0026lt; details \u0026gt;}}（引用加上details），否则会造成错误与样式混乱，暂时还未修复…… \r  样式更改参考自借助HTML5 details,summary无JS实现各种交互效果…… \r 三、tabs 分标签显示……\n使用方法 {{\u0026lt; tabs \u0026#34;uniqueID\u0026#34; \u0026gt;}} {{\u0026lt; tabs/tab \u0026#34;1\u0026#34; \u0026gt;}} Content_1 {{\u0026lt; /tabs/tab \u0026gt;}} {{\u0026lt; tabs/tab \u0026#34;2\u0026#34; \u0026gt;}} Content_2 {{\u0026lt; /tabs/tab \u0026gt;}} {{\u0026lt; tabs/tab \u0026#34;3\u0026#34; \u0026gt;}} Content_3 {{\u0026lt; /tabs/tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} uniqueID为一个独一无二的ID……\n使用例 源码 {{\u0026lt; tabs \u0026#34;1\u0026#34; \u0026gt;}}{{\u0026lt; tabs/tab \u0026#34;第一标签页\u0026#34; \u0026gt;}}## 天才麻将少女 打麻将真开心啊…… {{\u0026lt; /tabs/tab \u0026gt;}}{{\u0026lt; tabs/tab \u0026#34;第二标签页\u0026#34; \u0026gt;}}## 兽娘动物园 是会每天没事干不务正业的Friends呢【指自己…… {{\u0026lt; /tabs/tab \u0026gt;}}{{\u0026lt; tabs/tab \u0026#34;第三标签页\u0026#34; \u0026gt;}}## 魔法少女小圆 身体好轻，怀着这么幸福的感觉战斗还是第一次，已经没什么好怕的了，因为我不再是孤单一人了！…… {{\u0026lt; /tabs/tab \u0026gt;}}{{\u0026lt; /tabs \u0026gt;}}效果 第一标签页\r天才麻将少女 打麻将真开心啊……第二标签页\r兽娘动物园 是会每天没事干不务正业的Friends呢【指自己……第三标签页\r魔法少女小圆 身体好轻，怀着这么幸福的感觉战斗还是第一次，已经没什么好怕的了，因为我不再是孤单一人了！……\r ","date":"2021-01-07T00:00:00Z","image":"https://blog.supersassw.com/p/test-shortcode-extend/Yande-312231_hub297abc0e6f09948596897695fbb9840_1998731_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/test-shortcode-extend/","title":"移植Shortcode测试……"},{"content":" LaTex显示好像有误，待修复 \r 定积分  $\\int_0^{\\frac{\\pi}{2}} f(\\sin x)\\mathrm{d}x = \\int_0^{\\frac{\\pi}{2}} f(\\cos x) \\mathrm{d}x$ $\\int_0^\\pi xf(\\sin x)\\mathrm{d}x = \\frac{\\pi}{2}\\int_0^\\pi f(\\sin x) \\mathrm{d}x$  e.g.\n$\\int_0^\\pi \\frac{x\\sin x}{1+cos^2x} \\mathrm{d}x = \\frac{\\pi}{2}\\int_0^\\pi \\frac{\\sin x}{2-sin^2x} \\mathrm{d}x$\n  Walls公式：\n$I_n=\\int_0^\\frac{\\pi}{2}\\sin^nx\\mathrm{d}x\\=\\begin{cases}\\frac{n-1}{n}\\cdot\\frac{n-3}{n-2}\\cdot\\ \\cdots\\ \\cdot \\frac{3}{4}\\cdot\\frac{1}{2}\\cdot\\frac{\\pi}{2}\\quad (\\text{n is even}) \\\\frac{n-1}{n}\\cdot\\frac{n-3}{n-2}\\cdot\\ \\cdots\\ \\cdot \\frac{4}{5}\\cdot\\frac{2}{3}\\quad (\\text{n is odd, n\u0026gt;1})\\end{cases}$  ","date":"2021-01-04T00:00:00Z","image":"https://blog.supersassw.com/p/univ-am-formula/76524292_p0_hu496f4562aacbed9d40936841282eb41a_2147862_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/univ-am-formula/","title":"高等数学——常用公式……"},{"content":"一、什么是数组 1、与数学的联系——数列 关于数组，你可以就把他当作数学上的“数列”，用来存一系列的数。\n数学上的一个数列$a_i$：\n当$i=1$时，代表的是这个数列的第一个数$a_1$，当$i=3$时，代表的是这个数列的第三个数$a_3$……\n同时，这个数列可以叫数列$a_i$，也可以叫$b_i、{nico}_i$……\n可以用$i$来表示第几项（$a_i$），也可以用$j$来表示第几项（$a_j$）……\n\r 2、与数学的不同  数学上的数列是从第一项开始的，也就是$a_1$代表的就是$a$这个数列的第一项。\n然而编程里的数组，却是从第零项开始的，也就是a[1]代表的是a这个数组里第二项，a[0]才是第一项。 数学上的数列，我们不需要提前告诉这个数列中会有多少项。\n然而编程里的数组，我们需要提前告诉他这个数组里会有多少项，也就是int a[100]的100的意思，代表可能会存100项。  3、编程中的数组 那么类比到我们编程里：\n 这个$a_i$的$a$，就是程序里的这个数组的名字，专业名称叫“变量名”。 这个$a_i$的$i$，就是程序里的这个数组的第几项，专业名称叫“下标”。  比如arr[5]代表的就是arr这个数组里的第6项。\n二、数组的声明 申明部分，也就是定义。如：\nint arr[100];  int——代表的是这个数组的类型：即这个数组存的是一系列int类型的数。\narr——代表的是这个数组的变量名，之后用这个数组就是arr[2]、arr[i]之类的形式。\n[100]——代表的是这个数组的大小，也就是可能会存多少项。\n 对于数组大小的声明，必须为常量或者常量表达式。\n正确的例子：\nint a[10];\t//字面常量（常数） int b[5 * 5];\t//字面常量的表达式  const int len = 10; int c[len];\t//符号常量 int d[len * 2];\t//符号常量的表达式 \n\r\r错误的例子：\nint len = 10; int a[len];\t//len为变量，错误 int a[len + 5];\t//len+5为变量相关的表达式，错误 \n\r\r\r 三、数组的运用 1、对一个数组某个具体元素的运用   最简单的运用，我们直接把一个常数100存到arr数组里的第三项里：\na[2] = 100;   要把一个变量val存到arr数组里的第一项里：\na[0] = val;   要输出数组arr中的第二项：\ncout \u0026lt;\u0026lt; a[1];   2、对一个数组多个元素的运用 很多时候我们不止运用其中的某一个具体的数。\n比如我们要向这个数组读入10个数，然后输出这10个数，这就涉及了多个元素的操作。\n我们再类比数列，假如我们要对数列$a_i$的第一项到第十项求和：\n用的是不是$\\sum_{i=1}^{10}a_i$这个公式，\n用个$i$来代表第几项，然后$i=1\\sim10$，把$a_i$累加起来。\n类比到编程，同样用个i来代表第几项，然后i=0~9，把arr[i]累加起来存到sum里。\n 仍要注意到第一项是从0开始，所以是0~9！ \r\n  对数组前十项求和  for (i=0; i\u0026lt;=9; i++) sum = sum + arr[i];  其中这里的涉及到从头到尾加起来的操作，\n我们把对一个数组从头到尾进行某些操作叫做“遍历”。\n以后会提到的概念注意一下。\n\r 那么类推一下，要向数组里读入$10$个数\n 读入十个数到数组前十项  for (i=0; i\u0026lt;=9; i++) cin \u0026gt;\u0026gt; arr[i];  然后再输出\n 输出数组中前十项  for (i=0; i\u0026lt;=9; i++) cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  总代码：\nint i, arr[100], sum = 0; cout \u0026lt;\u0026lt; \u0026#34;请输入十个数：\u0026#34;; for (i = 0; i \u0026lt;= 9; i++) cin \u0026gt;\u0026gt; arr[i]; for (i = 0; i \u0026lt;= 9; i++) sum = sum + arr[i]; cout \u0026lt;\u0026lt; \u0026#34;你刚才输入的十个数为：\u0026#34; \u0026lt;\u0026lt; endl; for (i = 0; i \u0026lt;= 9; i++) cout \u0026lt;\u0026lt; \u0026#34;arr[\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;] = \u0026#34; \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;总和为：\u0026#34; \u0026lt;\u0026lt; sum; 效果为： \r上述代码效果\r\n 如果为先输入一个数n，然后读入n个数，只需要改下循环条件即可。\n 读入n个数到数组  int n; cin \u0026gt;\u0026gt; n; for (i = 0; i \u0026lt;= n-1; i++)\t//注意读n个数是(i=0;i\u0026lt;=n-1)，就像之前读10个数是(i=0;i\u0026lt;=9) //也可以写成 for (int i = 0; i \u0026lt; n; i++)，不过最好选择一种格式以后就这样写，不然可能会晕 \tcin \u0026gt;\u0026gt; arr[i];  其余输出什么的同理。\n3、对多个数组的运用 很多时候我们可能要从a数组拿出一些数放到b数组里，这个时候下标可能就会很疑惑。\n比如我们可能会把arr数组里十个数放到b数组对应位置里。\n这个时候数学表示就是$b_i=arr_i(i=1\\sim10)$\n  把arr数组十个数放到b数组里  for (i=0; i\u0026lt;=9; i++) b[i] = arr[i];  但不一定每次都是刚好把arr的第i项放到b的第i项，也可能是比如：\n从arr的第五项开始，取5项（即a[4] ~ a[8]，放到b的第十项后面（即(b[9] ~ b[13])。\n要记住数组的下标不只是用i来表示，也可以用其他变量来表示。\n因此我们可以定义两个变量j和k，来分别表示两个数组arr和b的下标。\n刚开始令j = 4，k = 9\n开始取第一项放进b时，也就是b[9] = arr[4]，这个时候就是b[k] = arr[j]。\n然后取第二项放进b时，也就是b[10] = arr[5]，\n因此我们就可以在放完一项后，让k = k + 1和j = j + 1，\n这个时候的b[k] = arr[j]，是不是就代表b[10] = arr[5]了。\n 从arr的第五项开始，取5项，放到b的第十项后面。  j = 4, k = 9;\t//分别代表arr数组和b数组的下标 for (i=1; i\u0026lt;=5; i++)\t//做5次循环，代表取5项 { b[k] = arr[j]; k++; j++; }  这里是比较难但很重要的点，如果分析也看不懂，可以手动模拟一下：\n自己按照程序一行一行执行，在本子上画两行表格，一行代表arr数组，一行代表b数组；j=4时就用个箭头指向arr[4]，j++则移动箭头指向arr[5]……\n如果理解了，那数组差不多也都理解了。\n四、例题讲解 选择“实验8”的第1题。\n1、题目要求 \r实验8第一题\r\n2、数组的定义分析 因为要输入的是实数（小数），所以要用double或float类型。\n然后有15个数，但注意到要把计算后的平均值存到a数组最后的a[15]里，即实际上为16个数，长度为16。\n 故定义数组：\ndouble a[16];  3、数组刚开始的原样读入、原样输出和求平均值 如果认真看了之前的“数组的运用”，这里应该问题不大。\n多的点就是要每行五个输出，并且域宽为10。\n 代码：\ndouble sum = 0;\t//求和变量注意清零  //读入部分 for (i = 0; i \u0026lt;= 14; i++)\t//i=0~14，读入十五个数 { cin \u0026gt;\u0026gt; a[i];\t//读入a[i] \tsum = sum + a[i];\t//顺便对a[i]的所有项求和，方便后面求平均值 } //求平均值部分 a[15] = sum / 15;\t//求的总和除以个数，也就算的是平均值，放到题上要求的a[15]里  //输出部分 for (i = 0; i \u0026lt;= 14; i++) { if ((i+1) % 5 == 0) cout \u0026lt;\u0026lt; endl; //这里用如果(i+1)%5==0则换行，也就是i=5,10,15,...的时候换行，达成了每五个换行的效果 \t//这个可以记下来，如果是每7个换行，就写 if (i%7 == 0) cout\u0026lt;\u0026lt;endl; \tcout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; a[i];\t//输出a[i]，setw为设置域宽 }  4、调整a数组，以满足题目条件形式输出 因为我们要调整a数组里的数，最终输出a数组。\n所以可以先把a数组里的所有数存到b数组里，然后再“遍历”b数组，判断某一个数b[i]跟平均值的关系，如果大于则放到a数组前面，小于则放到后面。\n首先先来写怎么把a数组里的所有数存到b数组里，前面已经写过了这里直接写代码。\n 代码：\nfor (i = 0; i \u0026lt;= 14; i++)\t//把a数组放到b数组里 { b[i] = a[i]; }  接下来就是难点了，判断出关系后，怎么样才能把b[i]放到a数组前面或者后面。\n之前说过的，下标不一定只能用i，也可以定义新变量来表示下标。\n 于是我们可以定义两个变量begin和end，分别代表a数组前面和后面的下标。\n刚开始begin = 0, end = 14，分别代表最开始的前面的下标和后面的下标。\n\rway_1\r\n【注意a[15]为平均值】\n  然后遍历b数组，假如第一个数b[i]（$i=1$）为$3$，小于平均值a[15]则该放到后面，也就是a[end]。\n先让a[end]=b[i]，\n\rway_2\r\n  然后再让end = end - 1，\n\rway_3\r\n  这样，当再次找到下个小于平均值的数时，则会放到当前的最后面处；\n找到下个大于平均值的数时，则会放到当前的最前面处。\n如图： \rway_4\r\n   代码：  cout \u0026lt;\u0026lt; \u0026#34;调整后的数据为:\u0026#34; \u0026lt;\u0026lt; endl; for (i = 0; i \u0026lt;= 14; i++)\t//把a数组放到b数组里 \t{ b[i] = a[i]; } int begin = 0, end = 14; for (i = 0; i \u0026lt;= 14; i++)\t//遍历b数组，跟平均数比较，放回a数组 \t{ if (b[i] \u0026lt; a[15])\t//跟平均数比较 \t{ a[end] = b[i]; end--; } else { a[begin] = b[i]; begin++; } } for (i = 0; i \u0026lt;= 14; i++)\t//输出a数组  { if (i % 5 == 0) cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; a[i]; }  5、总代码 #include \u0026lt;iomanip\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; int main() { int i; double a[16], b[16]; double sum = 0.0; cout \u0026lt;\u0026lt; \u0026#34;请输入15个实型数：\u0026#34; \u0026lt;\u0026lt; endl; for (i = 0; i \u0026lt; 15; i++) //读入 \t{ cin \u0026gt;\u0026gt; a[i]; sum = sum + a[i]; } a[15] = sum / 15;\t//求平均值 \tfor (i = 0; i \u0026lt; 15; i++) //原样输出 \t{ if (i % 5 == 0 \u0026amp;\u0026amp; i != 0) //【这里加了个i!=0的条件，防止最开始就换行 \t{ cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; a[i]; } cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;调整后的数据为:\u0026#34; \u0026lt;\u0026lt; endl; for (i = 0; i \u0026lt; 15; i++) //把a数组放到b数组里 \t{ b[i] = a[i]; } int begin = 0, end = 14; for (i = 0; i \u0026lt; 15; i++) //遍历b数组，跟平均数比较，放回a数组 \t{ if (b[i] \u0026lt; a[15]) { a[end] = b[i]; end--; } else { a[begin] = b[i]; begin++; } } for (i = 0; i \u0026lt; 16; i++) //输出a数组【注意这里是遍历输出整个a数组，即a[15]这个存的平均值也要输出，所以变成了(i = 0; i \u0026lt;16; i++) \t{ if (i % 5 == 0 \u0026amp;\u0026amp; i != 0) cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; a[i]; } }  这里只讲的老师的第一种方法，更好理解一些。对于第二种方法可以自行尝试，跟这个大致相同，不懂也可以自己在草稿纸上模拟一下。  五、其他提示   数组的范围可以开大，但不能开小。\n意思就是尽管最多可能只有10个整数，你可以定义为int a[100]，但不可以int a[9]。\n推荐是比最多个数开稍微大一点，这样又可以偷懒想要开几个，又可以防止越界错误【本来只定义了15个，你访问了a[20]】。\n  因为编程里数组第一项是从a[0]开始的，比较反人类x……\n所以如果想按照数学习惯，完全可以从a[1]开始存数。\n 比如读入15个数，原来可能写成\nfor (i = 0; i \u0026lt;= 14; i++) cin \u0026gt;\u0026gt; a[i]; 这样就是存在a[0]~a[14]里。\n你也可以写成符合我们习惯的\nfor (i = 1; i \u0026lt;= 15; i++) cin \u0026gt;\u0026gt; a[i]; 这样就是存在a[1]~a[15]里。\n 不过选择好一种自己喜欢的就这么写，不要一会从$0\\sim14$一会又$1\\sim15$，不然会很混乱。\n  没了。\n  有关排序的算法可能是常考点，各位可以自己去背一下。\n  以上。\n","date":"2020-12-26T00:00:00Z","image":"https://blog.supersassw.com/p/univ-cpp-note-array/72693520_p0_hu5438825b9b6d1014226d20d231e650c2_940838_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/univ-cpp-note-array/","title":"程序设计——数组……"},{"content":" 以下大部分总结于半期考试之前…… \r 一、注意的点 1、用作为“累加、累乘”的变量的注意事项 例子——累加、累乘的变量\r sum1 = sum1 + a;——作为累加求和。 sum2 = sum2 * a;——作为累乘求和。  \r   是否定义时赋初值？\n int sum1 = 0;——累加变量赋初值为0。 int sum2 = 1;——累乘变量赋初值为1。    在循环里反复使用，要注意可能要将累加变量清零，累乘变量赋一。\n例题\r题目：\n统计3组数据的和，其中每组数据会有n个数。\n\r\r部分代码：\nint sum = 0;\t//赋初值为0  for (int i = 1; i \u0026lt;= 3; i++)\t//循环3组数据 { cout \u0026lt;\u0026lt; \u0026#34;请输入第\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;组数据有多少个数：\u0026#34;; cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; \u0026#34;请输入n个数：\u0026#34;; for (int j = 1; j \u0026lt;= n; j++)\t//读入并统计这组数据里n个数的和  { cin \u0026gt;\u0026gt; a; sum = sum + a; } cout \u0026lt;\u0026lt; \u0026#34;这组数据和为：\u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; sum = 0;\t//关键语句：这里即要注意每读完一组数据要清零！否则会带着上次计算的结果算下一组 } 输出：\n 加了sum = 0;这句清零语句：\n 未加sum = 0;这句清零语句：\n  \r   2、有关函数的讲解和注意事项 函数的三个要点：\n 我要给他什么东西？（给几个东西、这些东西是什么类型） 我想要这个函数干嘛、完成什么事？ 他要给我返回个什么东西？（只能返回一个值，否则不叫函数）  \r 一般要求写函数，都是基于这三点分析：\n 根据1和3两点来确定怎么声明函数。 根据2这点来确定怎么实现函数。  例题一\r题目：要求写一个函数，用来返回两个整数的最大值。\n\r\r分析与实现\r分析如下：\n 我应该给这个函数两个int类型的数据。 这个函数应该找到这两个数谁最大。 这个函数应该返回给我这两个数的最大值，也是int类型的数据。   故声明部分为：\nint max(int, int); 实现部分为：\nint max(int num1, int num2) { if (num1 \u0026gt; num2) return num1; else return num2; } 使用部分为：\nint main() { int max(int, int); cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; \u0026#34;两个数的最大值为：\u0026#34; \u0026lt;\u0026lt; max(a,b); } \r\r例题二\r题目：要求写一个函数，用来确认某个数是否在某个数组a[10]里（为double类型数组）。\n\r\r分析与实现\r分析如下：\n 我应该给这个函数一个我要找的数，这个数为double类型；还要给我要找的数组，这个为数组的double*指针类型。 这个函数判断这个数是否存在于a这个数组。 这个函数应该返回给我这个数是否存在于a数组，是个bool类型的数据。   故声明部分为：\nbool if_inside(double, double*); 实现部分为：\nbool if_inside(double num, double* arr) { for (int i = 0; i \u0026lt;= 9; i++) { if (arr[i] == num)\t//如果与数组中某个数相等，代表找到，返回true  return true; } return false;\t//遍历完数组都没找到，代表真的没有，返回false } 使用部分为：\nint main() { bool if_inside(double, double*); cin \u0026gt;\u0026gt; n; if ( if_inside(n) )\t//判断n是否在a数组内  cout \u0026lt;\u0026lt; \u0026#34;n这个数在a数组内\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;n这个数不在a数组内\u0026#34;; } \r\r\r函数的注意事项   如果把函数实现写在int main()之前，便不用在main里声明函数了。【见书P86 第二个黑色方框】\n  函数一旦return后，便不会再执行之后的语句。\n  不同函数（包括main这个“主函数”）里面的变量不能互相调用。\n 即假如main()里有个int a，则不能在子函数fx()中用a = 1这样。\n如果main()里有个int a，子函数fx()里也有个int a：则main里只能用main里的a，fx里只能用fx里的a。\n 这个其实就是局部变量的原因，函数里的变量为局部变量，只能在这个函数里用。\n  \r 二、需要记住的模板 1、生成随机数   必须写上的代码（提供随机种子）\n直接写在int main()后面的第一句话就好。\nint main() { srand(time(NULL)); ... }   使用方法\n 要取得$(a,b)$的随机整数，使用( rand() % (b-a+1) ) + a + 1; 要取得$[a,b)$的随机整数，使用( rand() % (b-a) ) + a; 要取得$[a,b]$的随机整数，使用( rand() % (b-a+1) ) + a; 要取得$(a,b]$的随机整数，使用( rand() % (b-a) ) + a + 1;  例子——随机生成1到100内的整数（含1和100）\r代码：\nint num = rand() % (100 - 1 + 1) + 1; 或者直接写成：\nint num = rand() % 100 + 1; \r   记忆方法：\n想象$rand()$是能返回完全任意的数。\n当你对这个任意的数$\\mod 100$（对100取余数）后，那么余数范围只能是$0\\sim99$。\n再加个$1$，范围变成了$1 \\sim 100$。\n\r 2、最大公约数（GCD）和最小公倍数（LCM）的计算  这个比较重要，也很难背。 \r 直接背代码。\n老师给的版本 最大公约数（GCD）\rint GCD(int a, int b) //求a和b的最大公约数 { int c, r; if (a \u0026gt; b) //保证a是两数中较小的数  { c = a; a = b; b = c; } r = b % a; while (r != 0)\t//这个过程背住orz……  { b = a; a = r; r = b % a; } return a;\t//最后的a值为求得的结果 } 最小公倍数（LCM）\rint LCM(int a, int b)\t//求a和b的最小公倍数 { return (a * b) / GCD(a, b); } \r这里用函数的形式来写，以后求解可可以直接用这个函数。如：\ncin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;和\u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt;\u0026#34;的最大公约数为：\u0026#34; \u0026lt;\u0026lt; GCD(n,m) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;和\u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt;\u0026#34;的最小公约数为：\u0026#34; \u0026lt;\u0026lt; LCM(n,m); 不用函数的话，就把那里面的东西直接写到main()里就行。\n更好记的版本  利用递归思想求最大公约数，可以极大简化代码。 \r 可以尝试理解下这个代码，能很好的锻炼递归思想。\nint GCD(int a, int b) { return b ? GCD(b, a % b) : a;\t//意思是如果b不为0，则a=b,b=a%b辗转相除；否则就返回a }  或者采用这个递推的思想，极其好记！\nint GCD(int a, int b) { while (b ^= a ^= b ^= a %= b); return a; } 【但原理就不要求掌握了，其中的^=是位运算……\n3、判断某数是否为质数 直接背代码。\n 代码里有几个要注意的点。 \r bool if_Prime(int num) { if (num == 1) return false; //！特别注意！：当num=1的时候很可能之后会判断失误，故需要“打补丁”：当num=1的时候直接返回false  bool flag = true;\t//刚开始假设是素数  for (int i = 2; i \u0026lt;= num-1; i++)\t//！注意！：这里是(2~num-1)，而不是(2~num)，很容易在这里写错  if (num % i == 0) //找到能被(2~num-1)之中的数除尽，证明不是素数，设置flag并退出循环  { flag = false; break; } return flag;\t//如果循环完都没有被除尽，证明是素数，会返回true；否则会返回flase } 这里用函数的形式来写，以后判断就可以直接用这个函数。如：\ncin \u0026gt;\u0026gt; n; if ( if_Prime(n) ) cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;是素数\u0026#34;; else cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;不是素数\u0026#34;; 4、对数组的排序 就两种排序方法：\n 冒泡排序 选择排序  两种方法仅存在写法上的区别，建议自己选择一种自己背得到的记住。\n而且写法的差别并不大，仅是for循环范围的区别。\n 很可能会考到写法【个人感觉【…… \r 【模板见老师的PPT，如果没记的话可以问我……\n5、二分查找（折半查找） 有可能要考，考的话会专门指出“请用二分查找来找出\u0026hellip;”。\n不然的话就可以用“从头到尾遍历数组”来找。\n【模板见老师的PPT，如果没记的话可以问我……\n 使用二分查找，需要先让数组有序，如果是无序的数组先要排序。 \r 三、常用头文件及函数  #include \u0026lt;...\u0026gt;   #include\u0026lt;iostream\u0026gt;\n最基本的库。\ncin、cout等基本指令都需要这个库，写程序直接写上即可。\n记忆方法\r io ————\u0026gt; input\u0026amp;output 输入输出 stream ————\u0026gt; stream n.流  即“输入输出流”。\r\n  #include\u0026lt;ctime\u0026gt;\n使用随机生成时要用到的库。\n即生成种子时用的time()需要这个库。 记忆方法\r c ————\u0026gt; 值c++ time ————\u0026gt; time n.时间  即用来管时间的库。（随机函数需要用时间来作为种子，这样才能保证随机生成不重复）\r\n  #include\u0026lt;iomanip\u0026gt;\n控制输出格式要用到的库。\nsetw(...)、fixed()、precision(...)（基本为这三个）需要用到这个库。 记忆方法\r io ————\u0026gt; input\u0026amp;output manip ————\u0026gt; manipulator n.操控器 的前五个字母  即“输入输出控制器”。\r\n  #include\u0026lt;string\u0026gt;\n使用c++的字符串要用到的库。\n对字符串大致使用不了解的看书P132-134。（会点很基础的输入输出就行，不用太了解）\n  【库这些东西多写了没坏处，可以写之前就把这些库都写上，之后复制粘贴就行xd……\n四、常见非编译问题和错误弹窗解释 1、未赋初值类 弹窗显示如图：\n\r错误类型1\r\n 中文意思：“val”（橙色圈出）这个变量没被初始化（赋初值）就在使用。 出现原因：一般出现在累加变量未赋初值为0，就在用sum=sum+a。 解决方法：找到变量名为引号里的变量，在使用其前赋相应初值。  错例\r红色划线为对val的使用处，橙色划线为val的定义处。\n很明显看到val在使用前未被赋初值。\n故在使用前赋个初值（这里为累加变量，所以赋初值为0），即：val = 0。\n\r 2、数组越界类 弹窗显示如图：\n\r错误类型2\r\n 中文意思：变量“a”周围的栈被破坏。【理解不到没关系看下面_(:з」∠)_…… 出现原因：出现在对数组元素的访问中，访问的下标超过数组最大个数。 解决方法：找到变量名为引号里的数组的声明部分，将其空间开大点。  错例\r橙色划线定义个数组空间为$10$，即只能用a[0]~a[9]。\n但在红色划线里，却用了a[10]，明显超出了最大范围，即越界了，所以会出现此错。\n故在定义部分int a[10]，把它空间开大点变成int a[11]即可。\n\r  这也是数组中很常见的误区和错误需要注意！ \r 3、死循环类 这类错误不会报错，但会感觉程序怪怪的……\n比如：\n 一直黑屏，没有任何反应。\n（如果不确定是不是电脑卡了的原因，可在int main()最开始加一句cout\u0026lt;\u0026lt;\u0026quot;test\u0026quot;来判断：如果输出了test，则证明不是程序卡了。） 明明只想读入几个数，却发现一直在读入。 明明只想输出几个数，却发现一直在输出。  这几类便是说明你的程序陷入了“死循环”。\n 如下程序：\n\r错误3-例\r\n本意是只读入五个数，输出这五个数的和。\n运行时：\n\r错误3-运行界面\r 发现一直在读入。\n  出现原因：  循环变量没有改变。  如忘了i++、i--、i=i+2等。\n  循环条件不可能中止。  如for (i = 1; i \u0026gt;= 0; i++)，$i\\geq 0$会一直成立。\n  循环里不小心改变了循环变量。  如：\nfor (i = 1; i \u0026lt;=10; i++) { ... i = 0; } 每次循环i又会变为0，则会一直循环造成死循环。\n     还可能有其他各种原因，反正问题都出在循环里，仔细检查下自己写的循环部分。\n五、其他杂类   有关i++和++i的区别，不懂看书P45。\n  有关条件运算符... ? ... : ...的用法（不一定会用，但是要看得懂），不懂看书P45。\n  强制类型转换(int)4.8、(double)1是否还记得？不记得看书P50。\n  对const（符号常量）这个东西是否还记得？\n 如const double PI = 3.1415926\n 不记得看书P31。\n  确定是否掌握setw、precision等控制输出格式的用法，不会看书P34-P35。\n  对字符数组char a[100]，了解这是什么即可（c里面的字符串），不必掌握。\n  字符串最后会有个看不见的\\000这个空字符：\n 如字符串\u0026quot;MinatoAqua\u0026quot;\n 长度为$10$。 存储时存放$11$个字符串。     一定注意{}的匹配！ 特别牢记你的这个if或for要管哪几句话，就把哪几句话打上{}\n  强烈建议把程序写的规范一点\n 一句话（用;结尾的）就是一行 {和}单独占一行 {之后的语句空两格（或者按“Tab”这个键） }之后（包含这一行）的语句往前删两个空格（用的“Tab”的删一次就可以） 具体样式就是以上我写的那种样子。  \r 这样不只是好看，更能让你的整体思路保持清晰，不然很容易犯{}不匹配的问题！\n  要知道你每写一句话是在干嘛，这句话我写出来是什么目的。【有点抽象，不过确实很需要知道自己的目的，怎么实现这个目的，等熟练后这个自然也就会很清楚了orz……\n   以上，\n祝武运昌隆！……\n","date":"2020-12-26T00:00:00Z","image":"https://blog.supersassw.com/p/univ-cpp-summary/58541644_p0_hu0c218c74dadec57d38928125b7e7f710_1153603_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/univ-cpp-summary/","title":"程序设计——考点总结……"},{"content":"Timeline…… 时间线标签的移植测试……\n测试 总历程……\n2020-12-24 19:00提出构想……\n\r这个时间线好好看啊，我也要实现！……\n 这里面还能套娃哦x…… \r\r\r\r2020-12-25这里想要测试下所以这里的标题要非常非常非常的长这样才能测试是否全平台适配……\n\r到了明天【？……\n 感觉实现了……  这里面用Markdown写！……\n然后这里也要非常非常非常非常非常非非常非常非常非常非常非常常非常非常非常非常非常非常的长……\n\r\r2020-12-25 233:33:33\n\rtime其实内容随意（没有检测直接原样输出），填个不是时间的也可以……\n最后一个测试了！……\n 来个公式：  $$[{2{x^T}(t)x(t - \\tau ) = {x^T}(t){Q^{ - \\frac{1}{2}}}x(t - \\tau ) \\le \\frac{1}{\\alpha }{x^T}(t)Px(t) + \\alpha {x^T}(t - \\tau )x(t - \\tau )}]$$ 我也不知道这是啥_(:з」∠)_……\n  来个代码：  freopen(\u0026#34;ans.out\u0026#34;,\u0026#34;r\u0026#34;,stdin); printf(\u0026#34;qwq\u0026#34;);    \r\r2020-12-24 20:28正式实现并适配……\n\r实现了！……\n也不知道会不会出问题，反正能跑就行.jpg……\n改后的样式配上这个主题感觉还是很好看的√……\n不过markdown里看着好乱啊也没办法的'_\u0026gt;'……\n好累orz……\n\r\r 实现方法 又又又又又是Shortcode！……\n换行输入模式……\n{ {\u0026lt; timeline theme=\u0026#34;...\u0026#34; \u0026gt;} } { {\u0026lt; timeline/node time=\u0026#34;...\u0026#34; title=\u0026#34;...\u0026#34;\u0026gt;} } 内容...... { {\u0026lt; /timeline/node \u0026gt;} } { {\u0026lt; timeline/node time=\u0026#34;...\u0026#34; title=\u0026#34;...\u0026#34; url=\u0026#34;...\u0026#34;\u0026gt;} } 内容...... { {\u0026lt; /timeline/node \u0026gt;} } { {\u0026lt; /timeline \u0026gt;} }  外层：\nname（可选项）：为这条时间线的标题……\n 内层：\ntime（必填项）：节点时间……\ntitle（可选项）：节点名称……\nurl（可选项）：节点链接（外部链接要加https://）……\nnew（可选项）：如果填了url，将new设为1可以在新窗口打开标签……\n   想法还是来自于：\n小康博客 —— Hexo博客之butterfly主题优雅魔改系列（持续更新）\n\r 个人在其基础上修改了CSS以适配此主题……\n并以Shortcode的形式完成对Hugo的移植……\n","date":"2020-12-24T00:00:00Z","image":"https://blog.supersassw.com/p/test-timeline/pixiv61107110_huba53cd19c95d0fe8cd12b027cea0c3df_3255125_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/test-timeline/","title":"Timeline测试……"},{"content":" 发现note嵌套中还是会出现格式混乱的问题，待修复…… \r 错误例子\r{{\u0026lt; note info \u0026gt;}} 1. 测试 {{\u0026lt; snote error \u0026#34;这里有问题……\u0026#34; \u0026gt;}} {{\u0026lt; /note \u0026gt;}} \r  Note测试…… 对Hexo中Volantis主题的note移植测试……\n NoteBlock 是 Blockquote 的增强版，在左边显示图标，并且可以自定颜色。\n 长Note 适用于需要换行输入的note……\n 很长很长的note！……\n还可以换行！……\n因为内容是Markdown格式……\n里面干什么都可以_(:з」∠)_……\n这句话是一句很长的话我用来测试他能否在不同移动端上也能正常显示我希望他真的能正常显示不然我又要去改scss了呜呜呜x但是现在这个长度还不够我还要再加长点嗯现在应该够了让我们看看效果吧！……\n为了能使长note内嵌，暂时将goldmark里的unsafe调为了true（能内嵌HTML），日后再改进……\n\r\r\r 使用方法：\n\u0026lt; note guide(theme) blue(color) \u0026gt; (content) \u0026lt; /note \u0026gt;  注意：\n如果要在引用内容（\u0026gt;）中使用，\n则只能在开头写一个\u0026gt;，其内容和结束部分都不要打\u0026gt;……\n\r  短Note 适用于很短的一句话的note……\n  不带颜色的……\n  成功（success）…… \r 使用方法：\n\u0026lt; snote success \u0026#34;...\u0026#34; \u0026gt;    带颜色的……\n  背景是SuperSASS蓝（blue）的链接图示（link）…… \r 使用方法：\n\u0026lt; snote link \u0026#34;...\u0026#34; blue \u0026gt;     图标问题已修复…… \r  测试：  Test——up…… \r  Test——paperclip in yellow…… \r\n 参数 图标  带颜色的：quote, info, warning, done/success, error/danger 不带颜色的：radiation, bug, idea, link, paperclip, todo, message, guide, download, up, undo  颜色  clear, light, gray, red, yellow, green, cyan, blue   想法来自于：\n小康博客 —— Hexo博客之butterfly主题优雅魔改系列（持续更新）\n\r 使用了其CSS后，用基于Hugo的Shortcode实现，并更改部分CSS使得匹配该主题……\n更多note也可以参见该页面……\n同时滚动条样式也参考了这位dalao然后自己改的【感恩……\n","date":"2020-12-23T00:00:00Z","image":"https://blog.supersassw.com/p/test-note/Yande-713907_hu78325a06b1473fc65240ca2cf12d1105_794019_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/test-note/","title":"NoteBlock测试……"},{"content":" 该笔记还未完成整理，待日后继续整理…… \r  该笔记目前直接复制的之前的笔记，还未调整格式。页面格式、内容、链接等可能存在混乱错误…… \r\n其实并不是笔记，\n只是在例题中自我总结了一点相关知识_(:з」∠)_……\n日后可能专门总结成笔记……\n源码 /* 并查集算法 用father数组记录每个节点的父节点，数据结构类似于树 关键操作：合并、查询 详细介绍: https://zhuanlan.zhihu.com/p/93647900 */ //P3958 奶酪: https://www.luogu.com.cn/problem/P3958 #include \u0026lt;bits/stdc++.h\u0026gt;#define N 1005 using namespace std; inline int quickRead() { int f = 1, num = 0; char t = getchar(); while (t \u0026lt; \u0026#39;0\u0026#39; || t \u0026gt; \u0026#39;9\u0026#39;) f = t == \u0026#39;-\u0026#39; ? -1 : 1, t = getchar(); while (t \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; t \u0026lt;= \u0026#39;9\u0026#39;) num = num * 10 + t - \u0026#39;0\u0026#39;, t = getchar(); return f * num; } struct typeUnionFind { int num, father[N], rank[N]; //这里rank作用是记录节点深度（真实为深度-1），采用了按秩合并的优化  /* 按秩合并指将深度小的合并到深度大的树上，这样可以减少查询次数。 这里按秩合并与路径压缩一起使用时，rank可能会因路径压缩操作而变得不准确。 因此这里rank只是相对的判断标准，并不一定绝对会将深度小的合并到深度大的 */ void init(int n) { num = n; for (int i = 1; i \u0026lt;= num; i++) father[i] = i; } inline int find(int node) { return father[node] == node ? node : (father[node] = find(father[node])); //这里使用了路径压缩优化  } inline void merge(int node1, int node2) { int father1 = find(node1), father2 = find(node2); if (rank[father1] \u0026lt; rank[father2]) father[father1] = father2; else if (rank[father1] \u0026gt; rank[father2]) father[father2] = father1; else if (father1 != father2) father[father1] = father2, rank[father2]++; //如果深度一样且父节点不一样（不为一棵树），合并后新树深度会加一  } } UnionFind; struct typeHole { long long x, y, z; } hole[N]; bool ifIntersect(typeHole hole1, typeHole hole2, long long r) { return (hole1.x - hole2.x) * (hole1.x - hole2.x) + (hole1.y - hole2.y) * (hole1.y - hole2.y) + (hole1.z - hole2.z) * (hole1.z - hole2.z) \u0026lt;= 4 * r * r; } int main() { long long T, n, h, r; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;T); while (T--) { scanf(\u0026#34;%d%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;h, \u0026amp;r); UnionFind.init(n); UnionFind.father[1001] = 1001, UnionFind.father[1002] = 1002; //这里用特殊的两个节点，1001代表底，1002代表顶。如果father[1001]==father[1002]则证明连通。  for (int i = 1; i \u0026lt;= UnionFind.num; i++) { scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;hole[i].x, \u0026amp;hole[i].y, \u0026amp;hole[i].z); if (hole[i].z \u0026lt;= r) UnionFind.merge(1001, i); if (hole[i].z \u0026gt;= h - r) UnionFind.merge(1002, i); } for (int i = 1; i \u0026lt;= UnionFind.num; i++) for (int j = 1; j \u0026lt;= UnionFind.num \u0026amp;\u0026amp; i != j; j++) if (ifIntersect(hole[i], hole[j], r)) UnionFind.merge(i, j); if (UnionFind.find(1001) == UnionFind.find(1002)) printf(\u0026#34;Yes\\n\u0026#34;); else printf(\u0026#34;No\\n\u0026#34;); } } /* WA 1st: 没考虑到只有一个洞以及贯穿的情况…… 修改: 1. merge(i,1001) ---\u0026gt; mergr(1001,i) 实际上完全没必要，因为无论前并后还是后并前，最终都是父节点合并…… 2. if (hole.z\u0026lt;=r) ... else if (hole.z\u0026gt;=h-r) ...; ---\u0026gt; if ...; if ...; 当时想着要么是底部相交要么是顶部相交，导致用了个else if，没考虑到直接贯穿的情况…… WA 2nd: long long！！！！…… */ ","date":"2020-12-20T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-union_find/60855211_p0_hu2f29f1f8fc777ac15405156777510011_1339015_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/acm-note-union_find/","title":"ACM学习笔记：并查集……"},{"content":" 该笔记还处于基础部分，待日后继续深入整理…… \r  该笔记目前直接复制的之前的笔记，还未调整格式。页面格式、内容、链接等可能存在混乱错误…… \r\n简介 是一种用来维护 区间信息 的数据结构。\n可以实现的操作：\n 单点、区间修改 区间查询（区间求和、最大值、最小值） 等等  描述 线段树会将一个非点区间（即长度大于$1$）利用递归的思想，二分为两个子区间来进行操作。\n这样就会将一个线段划分转化成一个树形结构。\n其中：紫色的a[]是原数组，红色的d[]是线段树：存储的区间的和，黄色范围代表管辖区间。\n每个节点会存储并维护其所管辖的区间的当前信息。（如上图存的就是区间的和）\n可根据题目要求，确定自己所需存储维护的信息。\n实现方法 提前的宏定义 #define NOW_Node node[index]\t//代表当前节点 #define NOW_LSon node[index].sonL\t//代表当前节点左儿子下标 #define NOW_RSon node[index].sonR\t//代表当前节点右儿子下标 0x00 建树 基本认识 根据上图可发现几个要点：\n 每一个节点i的左儿子下标是2i，右儿子下标是2i+1。 记：i管辖的区间为$[s,t]$。\n令：$mid=\\frac{s+t}{2}$。\n则左儿子2i管辖区间为$[s,mid]$，右儿子2i+1管辖区间为$[mid+1,t]$。  实现方法 之前已经介绍了递归的思想，那么只需要确定递归边界。\n由上图很容易看出，递归边界就是当长度为$1$的点。\n记：当前点为node[index]，代表区间为$[l,r]$。原数组为arr[]\n当$l=r$的时候，说明到达递归边界，这个时候的值直接为对应区间的值。\n也就是node[index] = arr[r]\n因为二分的操作使得递归的深度不会大于$log(n)$，故完全可以采用递归的方式简化代码，不用担心递归的栈溢出等缺点。\n储存方法 方法1、 struct typeNode { int val, L, R, mid, len;\t//val代表储存的值，L、R分别代表区间左、右端点，mid代表区间中点，len代表区间长度 }node[4*N]; 直接用左儿子下标为2i，右儿子下标为2i+1转递。\n函数为build(int index, int l, int r)，建左儿子用则为build(2*i, l, r)。\n 空间范围：反正直接把长度设置为$4n$。\n因为该线段树深度为$\\lceil log(n) \\rceil$，又因为为完全二叉树，总节点个数为$2^{\\lceil log(n) \\rceil +1}-1$。但建树的时候最后一层不一定从左往右建，也可能很右边会有一个，所以要预留出所有的最后一层的节点位置，即开$4N$。\n具体分析见关于线段树的数组到底是开2N还是4N。  方法2、 struct typeNode { int val, L, R, mid, len, sonL, sonR;\t//多了个sonL和sonR，代表左儿子的index和右儿子的index }node[2*N]; build()的时候需要多一个计数器变量cnt，记录总过有多少节点。\n函数为build(int \u0026amp;index, int l, int r)。其中传引用会在伪代码中解释。\n这里多存了个左儿子和右儿子的下标，使得可以保证从按顺序建，不会出现空间浪费，于是可以开$2N$。\n相较于方法2空间消耗会少一点。\n以下采用“方法2”的方式来储存。\n伪代码 struct typeSegment{ int cnt = 0;\t//记录node节点的数量，便可实现按顺序建树  struct typeNode{ int val, L, R, len, mid, sonL = 0, sonR = 0; } node[N * 2]; void build(int \u0026amp;index, int L, int R) //对区间[L,R]建立节点，下标为index \t{ index = ++cnt; /*引用index的原因： 这里因为引用index，在递归时会直接把seg[index].son_赋值为某儿子的index。 */ NOW_Node.L = L, NOW_Node.R = R, NOW_Node.mid = (L + R) \u0026gt;\u0026gt; 1, NOW_Node.len = R - L + 1;//节点基本信息  if (L == R) NOW_Node.val = arr[R]; //为递归边界，直接为对应区间的值 \telse { build(NOW_LSon, L, NOW_Node.mid); //划分建立左区间，注意这里传的index是sed[index].lson \tbuild(NOW_RSon, NOW_Node.mid + 1, R); //划分建立右区间 \tNOW_Node.val = node[NOW_LSon].val + node[NOW_RSon].val; //计算该区间信息 \t} } }Segment;\t//直接用个总结构体，便于模板化。//其实就是个个人癖好orz…… 0x01 区间查询 对区间进行值的条件查询，如对区间$[L,R]$求总和，求区间最值等操作。\n实现方法 将要查询的区间，拆成几个在其范围里的节点的区间进行求解计算。（类似于分块思想）\n 如果当前区间完全在查询区间的范围里，则直接返回这个区间的值。 如果不是，则分别查询左右区间计算最终值。  如果查询区间的左端点小于等于当前区间中点，则查询范围会存在于左儿子区间里，要查询左儿子。 如果查询区间的右端点大于当前区间中点，则查询范围会存在于右儿子区间里，要查询右儿子。  注意：这里为大于！因为中点是算在左区间里的！…… \r    【直接给代码吧ヾ(•ω•`)o……\n伪代码 int query(int index, const int \u0026amp;q_L, const int \u0026amp;q_R) { if (q_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; q_R\u0026lt;= NOW_Node.R) return NOW_Node.val; //当前区间直接在查询区间里，直接返回值 \t//【我查了，一句返回了，有什么好说的…… \t//↓ 不完全包含于查询区间里，就要查询两子区间的值计算 \tint tmpAns = 0; if (q_L \u0026lt;= NOW_Node.mid) tmpAns += query(NOW_LSon, q_L, q_R); //如果要查询区间左端点，比当前区间的中点还大，证明左儿子区间完全不在 \tif (q_R \u0026gt; NOW_Node.mid) tmpAns += query(NOW_RSon, q_L, q_R);\t//为\u0026gt;，不是\u0026gt;= \treturn tmpAns; } 0x02 区间修改 对区间进行值的修改，如区间$[L,R]$加上或乘上一个数。\n(最初)实现方法 跟查询的方法一样，找到对应区间后直接修改值。\n但注意，如果不是长度为1的区间，值的修改要乘上对应修改区间的长度。\n 比如对$[1,2]$这个区间加上$2$。\n$[1,1]$和$[2,2]$这两个子区间会加$2$。\n但$[1,2]$则个大的区间应该加的就是$4$。\n同理，$[1,4]$这个大区间就该加$8$了。\n 缺点分析 【诶我说停停，先别着急写啊，不要啪的一下就写起来了很快啊……\n如果碰上这样的情况：\n  对区间$[1,10000]$加上$10000$次$233$。 查询区间$[23333,23333]$的值。   怎么样，有没有觉得自己被耍了！\n所以如果当老实人，他让我们修改区间，我们就老老实实修改区间，可是要吃大亏的。【指TLE……\n改进方法 所以他耍我们，我们也耍一下他xd。\n不是让我们对区间修改吗，我们就先偷下懒：不老老实实地全部修改完，只做个记号在那。\n等到他让我们真正查询这个区间的时候，我们也才真正的去修改，并返回查询值。【并且注意lazy清零！……\n这便是lazy懒标记的由来。\n但我们该怎么偷懒呢？\n 如果当前区间完全在修改区间的范围里，我们便可以按分析的那样，先把修改的值加到lazy里。等之后有需要再去真正地修改，即“下放lazy”。 如果不是，这里就需要注意，我们再直接加到lazy标记的话，有些明明不该修改的区间就会被修改。所以这里的懒就偷不得，就要真正的修改当前节点的值，并尝试修改子节点。（但如果儿子可以偷懒，就让儿子去偷懒）  如果修改区间的左端点大于当前区间中点，则不会修改左儿子区间。 如果修改区间的右端点小于等于当前区间中点，则不会修改右儿子区间。    伪代码  区间修改：  struct typeNode{ int ..., lazy;\t//这里多定义个lazy，用来存偷懒没修改的值 } void modify(int index, const int \u0026amp;m_L, const int \u0026amp;m_R, const int \u0026amp;m_val) { if (m_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; NOW_Node.R \u0026lt;= m_R) NOW_Node.lazy += m_val;\t//当前区间完全在范围里，直接偷懒 \telse { NOW_Node.val += (min(m_R, NOW_Node.R) - max(m_L, NOW_Node.L) + 1) * m_val;\t/* 这里是修改所包含区间的值 如要修改[4,9]，当前节点区间是(1,6)\t//这里为了区分用的小括号，实际上包含端点 则只会修改[4,6)，也就是val += (6 - 4 + 1) * 2 */ if (m_L \u0026lt;= NOW_Node.mid) modify(NOW_LSon, m_L, m_R, m_val); if (m_R \u0026gt; NOW_Node.mid) modify(NOW_RSon, m_L, m_R, m_val); } }  有lazy的区间查询：  struct typeNode{ ... void pushdown(typeSegment *Segment)\t//下放也不用太彻底，能摸一层是一层xd…… \t{ val += len * lazy;\tif (sonL) Segment.modify(sonL, L, mid, lazy); //存在子节点才下放【不然我这种结构就会无限下放_(:з」∠)_…… \tif (sonR) Segment.modify(sonR, mid + 1, R, lazy); lazy = 0;\t//！lazy注意清零！ \t} } int query(int index, const int \u0026amp;q_L, const int \u0026amp;q_R) { if (NOW_Node.lazy) NOW_Node.pushdown(*this);\t//注意查询的时候，只要有懒标记就必下放【别人都来查岗了你还摸鱼.jpg……  if (q_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; NOW_Node.R \u0026lt;= q_R)\t//以下跟普通的查询操作一样 \treturn NOW_Node.val; int tmpAns = 0; if (q_L \u0026lt;= NOW_Node.mid) tmpAns += query(NOW_LSon, q_L, q_R); if (q_R \u0026gt; NOW_Node.mid) tmpAns += query(NOW_RSon, q_L, q_R); return tmpAns; } Tip: 我这里的偷懒是直接连本身都先不修改，而在下放的时候才修改；其他人有些可能会先修改自身。算是个小优化，注意区分一下……\n最终代码 洛谷P3372 【模板】线段树 1\n#include \u0026lt;bits/stdc++.h\u0026gt; #define N 100000  #define NOW_Node node[index]\t//代表当前节点 #define NOW_LSon node[index].sonL //代表当前节点左儿子下标 #define NOW_RSon node[index].sonR //代表当前节点右儿子下标 using namespace std; long long arr[N + 5]; struct typeSegment { int cnt = 0; //记录node节点的数量，便可实现按顺序建树  struct typeNode { long long val; int L, R, len, mid, sonL = 0, sonR = 0, lazy = 0; void pushdown(typeSegment \u0026amp;Segment) //下放也不用太彻底，左右儿子仍加到lazy里。【能摸一层是一层xd…… \t{ val += len * lazy; if (sonL) Segment.modify(sonL, L, mid, lazy); //存在子节点才下放【不然我这种结构就会无限下放 \tif (sonR) Segment.modify(sonR, mid + 1, R, lazy); lazy = 0; //lazy注意清零。 \t} } node[N * 2]; void build(int \u0026amp;index, int L, int R) //对区间[l,r]建立节点，下标为index \t{ index = ++cnt; //引用原因： \t//这里因为引用index的原因，在递归时会直接把seg[index].lson赋值为左儿子的index。 \tNOW_Node.L = L, NOW_Node.R = R, NOW_Node.mid = (L + R) \u0026gt;\u0026gt; 1, NOW_Node.len = R - L + 1; //节点基本信息 \tif (L == R) NOW_Node.val = arr[R]; //为递归边界，直接为对应区间的值 \telse { build(NOW_LSon, L, NOW_Node.mid); //划分建立左区间，注意这里传的index是sed[index].lson \tbuild(NOW_RSon, NOW_Node.mid + 1, R); //划分建立右区间 \tNOW_Node.val = node[NOW_LSon].val + node[NOW_RSon].val; //计算该区间信息 \t} } void modify(int index, const int \u0026amp;m_L, const int \u0026amp;m_R, const int \u0026amp;m_val) { if (m_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; NOW_Node.R \u0026lt;= m_R) NOW_Node.lazy += m_val; //当前区间完全在范围里，直接偷懒。 \telse { NOW_Node.val += (min(m_R, NOW_Node.R) - max(m_L, NOW_Node.L) + 1) * m_val; /* 这里是修改所包含区间的值 如要修改[4,9]，当前节点区间是(1,6)\t//这里为了区分用的小括号，实际上包含端点 则只会修改[4,6)，也就是val += (6 - 4 + 1) * 2 */ if (m_L \u0026lt;= NOW_Node.mid) modify(NOW_LSon, m_L, m_R, m_val); if (m_R \u0026gt; NOW_Node.mid) modify(NOW_RSon, m_L, m_R, m_val); } } long long query(int index, const int \u0026amp;q_L, const int \u0026amp;q_R) { if (NOW_Node.lazy) //注意查询的时候，只要有懒标记就必下放【别人都来查岗了你还摸鱼.jpg…… \tNOW_Node.pushdown(*this); if (q_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; NOW_Node.R \u0026lt;= q_R) return NOW_Node.val; //当前区间直接在查询区间里，直接返回值//【我查了，一句返回了，有什么好说的……  //↓ 不完全包含于查询区间里，就要查询两子区间的值计算 \tlong long tmpAns = 0; if (q_L \u0026lt;= NOW_Node.mid) tmpAns += query(NOW_LSon, q_L, q_R); //如果要查询区间左端点，比当前区间的中点还大，证明左儿子区间完全不在 \tif (q_R \u0026gt; NOW_Node.mid) tmpAns += query(NOW_RSon, q_L, q_R); return tmpAns; } } Segment; //直接用个大的结构体，便于模板化。 int main() { int n, m, tmp, w, l, r, i; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;arr[i]); Segment.build(tmp, 1, n); //Segment.test(1); \twhile (m--) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;w); if (w == 1) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;i); Segment.modify(1, l, r, i); } else { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); printf(\u0026#34;%lld\\n\u0026#34;, Segment.query(1, l, r)); } } } ","date":"2020-12-20T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-segment_tree/67957130_p0_hu2c7318d0e2072da042ef7a1c5115b73e_4170699_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-note-segment_tree/","title":"ACM学习笔记：线段树……"},{"content":"音乐播放器 采用的APlayer的外链播放器……\n默认会显示在文章顶部……\n如需用吸底模式，请在第一个参数输入-fixed: 1……\n当然要放我最喜欢的怪力熊的歌啦！……\n【虽然网易云上没有原曲qwq……不过这两首也超好听的！……\n","date":"2020-12-19T00:00:00Z","image":"https://blog.supersassw.com/p/test-player/84038692_p0_hu3b9cb195d3b981b9da74048e9a17f8de_395719_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/test-player/","title":"音乐播放器测试……"},{"content":"Shortcode Hugo的Shortcode的测试……\n新增了Bilibili的链接……\n 不知道是什么的原文x：\n Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\n 详解 使用方法类似于Hexo当中的标签插件（Tag Plugins）\n有两种Shortcode的使用方法……\n  内嵌Shortcode\n{{\u0026lt; type content \u0026gt;}}   Shortcode块\n{{\u0026lt; type \u0026gt;}} content {{\u0026lt; \\type \u0026gt;}}    对于内容的解析也有两种方法：\n  内容解析为HTML\n{{\u0026lt; ... \u0026gt;}}   内容解析为Markdown\n{{% ... %}} 一般这个不常用，个人自写的所有Shotrcode都是基于\u0026lt;\u0026gt;来处理的……\n   功能测试 YouTube Privacy Enhanced Shortcode \r\r需要科学上网才能查看……\n Bilibili Simple Shortcode \r   使用方法：\n{{\u0026lt; bilibili BV1754y1R7Nd \u0026gt;}}   默认为BV号。\n 可选参数：  av = \u0026quot;...\u0026quot;：使用av号。\n使用例：{{\u0026lt; bilibli av=\u0026quot;10492\u0026quot; \u0026gt;}} hq = *：画质。0为低画质，1为高画质。（默认值为1） p = *：视频选集。（默认值为1）  如果使用参数，则使用方式只能为{{\u0026lt; bilibili bv=... p=1 hq=1 \u0026gt;}} \r    ","date":"2020-12-18T00:00:00Z","image":"https://blog.supersassw.com/p/test-shortcode/78356827_p0_huc21610886fa327c8e802235e20e8c4e7_690415_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/test-shortcode/","title":"Shortcode测试……"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用  思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n 图片 \rPhoto by Florian Klauer on Unsplash\r \rPhoto by Luca Bravo on Unsplash\r\n\rPhoto by Helena Hertz on Unsplash\r \rPhoto by Hudai Gayiran on Unsplash\r\n![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-12-18T00:00:00Z","image":"https://blog.supersassw.com/p/test-chinese/Yande-331204_hu78842091091c5acfc10d1d28fbf3f867_2198432_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/test-chinese/","title":"页面测试……"},{"content":" 该笔记目前直接复制的之前的笔记，还未调整格式。页面格式、内容、链接等可能存在混乱错误…… \r 邻项比较排序介绍 定义 本来的排序型贪心，我们需要任意两个项都满足决策条件。\n但我们发现，如果数列每对相邻两项都满足决策条件，根据不等式的传递性，那么也就可以推出任意两项满足决策条件。\n于是我们分析决策条件时，就不用分析任意两项，可以就分析邻项然后推出决策条件。\n【主要用于如果决策条件复合了其他数据（比如：结果计算为$\\sum_{i=1}^na_i$，复合之前的数列），这样分析可以减少分析难度】\n  典型例题：\nP1080 国王游戏\n 可以见到这题便有一个「排在该大臣前面的所有人的左手上的数的乘积」这句话，\n如果我们分析任意两项的话，还要考虑两者中间的数据。\n所以我们可以指通过分析相邻两项，然后通过传递性，推及任意两项都满足。\n 【其实用任意两项分析也完全可以，而且分析也不难_(:з」∠)_……\n  那么实现的关键就是找到最终的决策方案（序列满足的条件），然后根据这个决策sort就行了_(:з」∠)_……\n【但是会有注意点后面会讲到……\n题目解决方法 引例  以下以此例题为例具体讲解：\nSWJTU OJ——10.31 A 排队\n 题目与国王游戏类似，用邻项交换排序的思想来找决策条件。\n1、找出每种状态的ans，选邻项代入  题目描述：\n也就是说，请重新给班尼特排队，要求是最大化$\\min_{i=1}^n{-h_i+\\sum_{j=1}^i v_j}$。\n 那么每种状态的ans$=\\min_{i=1}^nw_i$。\n既然要求$\\min_{i=1}^n{w_i}$，所以我们就比较邻项的$w_i,w_j$，比较其两项的$\\min(w_i,w_j)$，选择最大ans的状态。\n 为什么我们这样排序，能使ans$=\\min_{i=1}^nw_i$取得最小？  就相当于把比较时候的最小值看成短板，每次比较一次选最高的那个，就会把短板提上去一点，这样最后得到的就是最高的短板，也就是最大的$\\min$……\n   2、假设相邻位置，写出两种状态的ans 我们首先要把每个位置的收益表达式写出来：\n 题目描述：治疗第$i$个班尼特的收益$w_i$等于前面治疗的所有班尼特的$v$之和减去$h_i$。 $$ w_i=\\sum_{j=1}^iv_j-h_i $$\n 那么我们假设两个相邻位置$i,j$。其中$i$在$j$前，即$i=j-1$。【必须先假设一个在另一个前后，否则不可能$i$在$j$前满足，$j$在$i$前也满足】\n记：两者之前的$\\sum v$为$sum$。【将一些求$w$要用到的比如$\\sum$记为其他符号表示，可以简化式子】\n然后分别讨论$i$在$j$前和$j$在$i$前的情况：\n  原本状态：$i$在$j$前\n $$ \\begin{matrix} h \u0026amp; v \\\n\\vdots \u0026amp; \\vdots(sum) \\\nh_i \u0026amp; v_i \\\nh_j \u0026amp; v_j \\\n\\vdots \u0026amp; \\vdots \\\n\\end{matrix} $$\n 对$i$的收益：$w_{i1}=sum+v_i-h_i$\n对$j$的收益：$w_{j1}=sum+v_i+v_j-h_j$\n此状态的ans=$\\min(w_{i1},w_{j1})$\n  如果交换：$j$在$i$前\n $ \\begin{matrix} h \u0026amp; v \\\n\\vdots \u0026amp; \\vdots(sum) \\\nh_j \u0026amp; v_j \\\nh_i \u0026amp; v_i \\\n\\vdots \u0026amp; \\vdots \\\n\\end{matrix} $\n 对$i$的收益：$w_{i2}=sum+v_j+v_i-h_i$，\n对$j$的收益：$w_{j2}=sum+v_j-h_j$\n此状态的ans=$\\min(w_{i2},w_{j2})$\n  3、根据题意写出排序条件并化简，得到最终决策方案  题目描述：芭芭拉想让治疗每个班尼特收益的最小值最大。\n 题意要求使最小收益最大化，\n则最初排序条件为：$\\min(w_{i1},w_{j1})\\ge\\min(w_{j2},w_{i2})$\n【或者说**交换条件**为：$\\text{if} \\quad (\\min(w_{i1},w_{j1})\u0026lt;\\min(w_{j2},w_{i2})) \\quad \\text{swap}(i,j)$】\n *其他例子：国王游戏中，是使最大收益最小化。则排序条件为：$\\max(w_{i1},w_{j1})\\le\\max(w_{i2},w_{j2})$*\n 然后对这个决策条件化简，使得能直接表达出来。\n【所谓不能直接表达的，便是条件中含有如$\\sum$之类的运算。而我们不可能用循环专门去求，只能通过化简把他消掉】\n 化简方法：\n下列所提到的化简方法参考含max、min的不等式。\n  利用“完全展开法则”，观察是否含有恒成立或恒不成立。\n【或者直接观察题目中$w_{i1},w_{j1},w_{j2},w_{i2}$间的关系，找出恒成立或恒不成立，然后利用“**消元法则**”】\n  利用排序规则下特殊的“相同无关原则”，结合“取反性、结合性”等性质，化简并得到最终的最简决策\n   则本题中：\n展开为$\\text{if} \\quad ((w_{i1}\u0026lt;w_{i2} \u0026amp; w_{i1}\u0026lt;w_{j2}) | (w_{j1}\u0026lt;w_{i2} \u0026amp; w_{j1}\u0026lt;w_{j2})) \\quad \\text{swap}$。\n 发现$w_{i1}\u0026lt;w_{i2}$恒成立：  $\\sout{sum+v_i-h_i} \\quad?\\quad \\sout{sum}+v_j\\sout{+v_i-h_i}$\n$\\implies 0\u0026lt;v_j$\n  发现$w_{j1}\u0026lt;w_{j2}$恒不成立：  $\\sout{sum}+v_i\\sout{+v_j-h_j} \\quad?\\quad \\sout{sum+v_j-h_j}$\n$\\implies v_i\u0026gt;0$\n   故原式可简化为：\n$\\text{if} \\quad (w_{i1}\u0026lt;w_{j2}) \\quad \\text{swap}$\n$\\implies \\text{if} \\quad (v_i-h_i \u0026lt; v_j-h_j) \\quad \\text{swap}$\n这便是化简后的**决策条件**。\n 注意的点：\n不一定要化到最简，只要能在代码里直接表达就行。\n 本题中原始条件经过部分化简：\n运行结果：\n而完全化简后为：\n运行结果：\n可见差异并不大，所以说只要能化简到能表达的地步就可以。\n当然如果能化到最简更好，肯定还是比带min的条件快的。\n \r 4、自定义结构体，重载\u0026lt;运算符，使用sort，遍历寻答案 这一步就不多说了，重载的时候按自己分析到的最终最简决策重载就行。\n但重点是：\n这样排序出来后只是最优状态，\n至于最终答案ans要从头到尾遍历寻找，即不一定是第一个为最终答案。\n可能后面计算结果不是递增或递减，则最终答案不是第一个。【具体题目具体分析】\n\r  标程代码 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N = 100010; struct Data { int h, v; bool operator\u0026lt;(const Data \u0026amp;t) { return v - h \u0026gt; t.v - t.h; } //以推出的最终最简决策重载\u0026lt;运算符 } d[N]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;d[i].h, \u0026amp;d[i].v); sort(d + 1, d + n + 1); //就一个sort  int tmp = 0, res = 1e9; for (int i = 1; i \u0026lt;= n; ++i) { tmp += d[i].v; res = min(res, tmp - d[i].h); //从头到尾遍历，res记录最终答案 \t} printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } 使用注意事项 注意之前我们定义中存在一个推论：\n 如果数列每对相邻两项都满足决策条件，根据不等式的传递性，那么也就可以推出任意两项满足决策条件。\n 所以假如我们所推的某个决策条件，不满足不等式的传递性，那么用这个方法就会造成错误。\n而这种必须要满足不等性的传递性，有个专门术语叫做“严格弱序”。\n先前知识——严格弱序   $X \\not\u0026lt; X$（比较条件非自反性）\n意思是：$X$与$X$本身，不满足比较条件。  反例：比较条件是$a_i \\ge a_j$。\n那么$X(a_i) \\ge X(a_i)$满足比较条件，为$X \u0026lt; X$，故不是严格弱序。   若$X \u0026lt; Y$，则$Y \\not\u0026lt; X$（比较条件非对称性）\n意思是：$X$和$Y$比较若满足比较条件，则$Y$和$X$比较不会满足条件。  反例：比较条件是$a_i \\ge a_j$。\n那么若$a_i=a_j$，$X(a_i) \\ge Y(a_j)$满足条件，\n但$Y(a_j) \\ge X(a_i)$也满足条件，故不是严格弱序。   若$X \u0026lt; Y,Y \u0026lt; Z$，则$X \u0026lt; Z$（比较条件不等传递性）\n意思是：$X$和$Y$满足比较条件，$Y$和$Z$满足比较条件，则$X$和$Y$满足比较条件。   反例：比较条件是$\\min(a_i,b_j) \\le \\min(a_j,b_i)$。\n那么对于下组数据：\n    $a$ $b$     $i$ $2$ $1$   $j$ $1$ $1$   $k$ $1$ $2$    $X(\\min(a_i,b_j)=1)\u0026lt;Y(\\min(a_j,b_i)=1)$\n$Y(\\min(a_j,b_k)=1)\u0026lt;Z(\\min(a_k,b_j)=1)$\n但$X(\\min(a_i,b_k)=2) \\not\u0026lt; Z(\\min(a_k,b_i)=1)$，故不是严格弱序。 【再次提示这里的$\u0026lt;$并不代表小于，而是代表符合比较条件的意思。】\n   若$X=Y,Y=Z$，则$X=Z$（比较条件相等传递性）\n意思同上。\n在“ouuan”dalao的讲解种写的是$x\\not\u0026lt;y,y\\not\u0026lt;x,y\\not\u0026lt;z,z\\not\u0026lt;y$（不可比性的传递性）。我改成这样更好理解。\n不过注意判断相等的方法是$x\\not\u0026lt;y,y\\not\u0026lt;x$这么判断的。  反例见下引例的「错误分析」      这里的$X$、$Y$、$Z$代表的是取某下标$i$、$j$后的决策条件的一侧元素。并不一定是某一具体数据。 这里的$\u0026lt;$并不代表小于的意思，而是代表满足比较条件，那么$\\not\u0026lt;$则代表不满足比较条件。  引例  P2123 皇后游戏\n 按照之前的方法尝试解决   找出每种状态的ans，选邻项代入\n 题目描述：\n她想请你来重新安排一下队伍的顺序，使得获得奖金最多的大臣，所获奖金数目尽可能的少。\n 可知每种状态的ans$=\\max_{i=1}^nw_i$。\n那么比较邻项$i,j$，就是$max(w_i,w_j)$。\n  假设相邻位置，写出两种状态的ans\n首先先写收益表达式：\n$$ w_i=\\max(w_{i-1},\\sum_{j=1}^ia_j)+b_i $$ 【第一位的收益可以合并到这个表达式里，令$w_0=0$就可以了。】\n假设相邻位置$i,j$。其中$i$在$j$前，即$i=j-1$。\n记：之前的$\\sum a$为$sum$，前一项的$c_{i-1}$为$pre_w$。\n会发现，由于$a,b\u0026gt;0$，整个收益表达式中又没出现会使收益变少的运算，故收益单增。\n即在后面的大臣的收益一定大于在前面的。\n$i$在$j$前时，则$w_j$一定大于$w_i$，所以$\\max(w_i,w_j)=w_j$，可以拆开一层$\\max$。\n  原本状态：$i$在$j$前\n $ \\begin{matrix} a \u0026amp; b \u0026amp; c \\\n\\vdots(sum) \u0026amp; \\vdots \u0026amp; \\vdots(pre_w) \\\na_i \u0026amp; b_i \u0026amp; w_{i1} \\\na_j \u0026amp; b_j \u0026amp; w_{j1} \\\n\\vdots \u0026amp; \\vdots \u0026amp; \\vdots \\\n\\end{matrix} $\n $w_{i1}=\\max(pre_w,sum+a_i)+b_i$\n$w_{j1}=\\max(w_{i1},sum+a_i+a_j)+b_j$\n此状态的ans=$\\max(w_{i1},w_{j1})=w_{j1}$\n  如果交换：$j$在$i$前\n $ \\begin{matrix} a \u0026amp; b \u0026amp; c \\\n\\vdots(sum) \u0026amp; \\vdots \u0026amp; \\vdots(pre_w) \\\na_j \u0026amp; b_j \u0026amp; w_{j2} \\\na_i \u0026amp; b_i \u0026amp; w_{i2} \\\n\\vdots \u0026amp; \\vdots \u0026amp; \\vdots \\\n\\end{matrix} $\n $w_{i2}=\\max(w_{j2},sum+a_j+a_i)+b_i$\n$w_{j2}=\\max(pre_w,sum+a_j)+b_j$\n此状态的ans=$\\max(w_{i2},w_{j2})=w_{i2}$\n    根据题意写出排序条件并化简，得到最终决策方案\n题意要求使最大收益最小化，\n则排序条件：$\\max(w_{i1},w_{j1}) \\le \\max(w_{i2},w_{j2})$\n开始化简：\n$\\max(w_{i1},w_{j1}) \\le \\max(w_{i2},w_{j2})$\n$\\implies w_{j1} \\le w_{j2}$\n$\\implies \\max(\\sout{pre_w+b_i+b_j},\\underline{sum+a_i}+b_i+\\underline{b_j},\\underline{sum+a_i}+a_j+\\underline{b_j}) \\le \\max(\\sout{pre_w+b_j+b_i},\\underline{sum+a_j}+b_j+\\underline{b_i},\\underline{sum+a_j}+a_i+\\underline{b_i})$\n【删除线的部分代表根据相同无关原则可以消去；下划线的部分代表根据结合性可以提出来】\n$\\implies \\max(b_i,a_j)+sum+a_i+b_j \\le \\max(b_j,a+i)+sum+a_j+b_i$\n$\\implies \\max(b_i,a_j)-a_j-b_i \\le \\max(b_j,a_i)-a_i-b_j$\n$\\implies \\max(-a_j,-b_i) \\le \\max(-a_i,-b_j)$\n$\\implies -\\min(a_j,b_i) \\le -\\min(a_i,b_j)$\n$\\implies \\min(a_j,b_i) \u0026gt; \\min(a_i,b_j)$\n最终的决策条件：$\\min(a_j,b_i) \u0026gt; \\min(a_i,b_j)$\n  那就开写呗……\n  然后交上去会WA，80分。\n证明我们这种方法有思路缺陷。\n错误分析 这里便不满足严格弱序的相等传递性这个性质。\n 当取$i,j$时，若$\\min(a_i,b_j)=\\min(a_j,b_i)$，\n当取$j,k$时，若$\\min(a_j,b_k)=\\min(a_k,b_j)$，\n则需要满足：取$i,k$时，$\\min(a_i,b_k)=\\min(a_k,b_i)$\n 反例：\n    $a$ $b$     $i$ $3$ $5$   $j$ $1$ $1$   $k$ $7$ $2$    虽然$\\min(a_i,b_j)=\\min(a_j,b_i)$和$\\min(a_j,b_k)=\\min(a_k,b_j)$都满足，\n但却不满足$\\min(a_i,b_k)=\\min(a_k,b_i)$。\n【只需要让$a_j,b_j$相等，就可以构建众多反例。】\n错误根本原因（新内容！）  为什么不满足严格弱序中传递性就会造成错误：  因为sort实现时，采用了分治的思想。\n会将数据分为两个部分，对两个部分进行排序，然后使数列直接有序。\n但问题就刚好出在这个“直接有序”上。\n之所以在左右都有序后，会认为整个数列直接有序，\n就是因为利用了严格弱序中的传递性：\n认为$X \u0026lt; Y,Y \u0026lt; Z$，则$X \u0026lt; Z$，\n以及$X = Y,Y = Z$，则$X = Z$。\n但假如不满足的第一条的话，分治处理过后：\n左侧的数是小于中间的，中间的数也是小于右边的，但左侧的是却不一定小于右边的了。\n会造成很严重的合并后错误。\n但假如不满足的第二条的话，分治处理过后：\n如果都是小于条件，根据第一条可推合并后也有序，没有问题。  这也就是为什么我们这个方法还能得部分分的原因——决策判断时没判断出相等。 \r\n但一旦出现等于条件的情况，则不能推得左边的也等于右边的，\n同时$X=Y, Y\u0026lt;Z \\implies X\u0026lt;Z$、$X\u0026lt;Y, Y=Z \\implies X\u0026lt;Z$也无法推得。\n 举例：判断条件为$\\min(a_i,b_j) \u0026lt; \\min(a_j,b_i)$【就本题我们推的条件…… 对以下两组数据：\n    $a$ $b$     $i$ $1$ $1$   $j$ $1$ $2$   $k$ $2$ $2$    其中$X(i,j)=Y(j,i),Y(j,k)\u0026lt;Z(k,j)$，但$X(i,k) \\not\u0026lt; Z(k,i)$，为$X=Z$。\n    $a$ $b$     $i$ $1$ $2$   $j$ $2$ $1$   $k$ $1$ $1$    其中$X(i,j)\u0026lt;Y(j,i),Y(j,k)=Z(k,j)$，但$X(i,k) \\not\u0026lt; Z(k,i)$，为$X=Z$。\n 那么不满足传递性，就会导致虽然序列大部分满足决策条件，但并不是任意两项都满足条件的。\n而回到我们贪心的基本要求：需要任意两个元素都满足决策条件。\n故会造成错误。\n   改进方法 其实上述主要问题都归结于我们对相等状况的定义模棱两可。\n 对于满足严格弱序中的传递性的数据来说：\n出现相等状况，交换或者不交换都无所谓，因为可以通过传递性证得交换后对数列无影响。\n所以可以保持这种模棱两可的定义。  也就是说这种数据，我们即使将判断中的不取等判断改为取等的判断，也依旧不会有影响。只不过会多交换几次，让状态变得不同，但最终结果一致。\n  对于不满足严格弱序中的传递性的数据来说：\n我们就必须对相等状况作出严格的操作规定了，否则两种不同的状态会导致数据最终结果的不一致。\n也就是说我们要对相等状况进行特判。  那么我们就来考虑在$\\max(w_{i1},w_{j1}) = \\max(w_{i2},w_{j2})$的相等条件下，又该加什么判断。\n也就是说，除了这个很显然的条件在影响ans外，还有没有什么可能影响ans。\n根据个人看法不同，会有很多种可能的条件，以下列举两种正确的：\n  会发现：$a$的前缀和会影响$\\max(c_{i-1},\\sum_{j=1}^ia_j)$这个的选择，从而影响$w_i$，从而影响ans。\n因为要找最小的ans，所以我们**把$a$更小的放在前面**，这样就能让更加保证所得状态是最优的了。\n  会发现：两种状态的前后两项$w$，后者是一样的【我们比较条件就是用的两状态的后者】，因此我们要让前者尽量小，从而确保ans更小。\n所以我们把$b$更小的放在前面。\n   那么假如这两个条件判断出来也是相等的，需不需要再特判呢？  假如$\\min(a_j,b_i) = \\min(a_i,b_j)$和$a_i = a_j$（或者$b_i = b_j$）同时满足，\n则可以推出$a_i=a_j,b_i=b_j$，也就是这两项的数据完全一致，并不是比较用数据一致，因此我们这里也可以即交换又不交换，保持模棱两可定义。\n   很特殊的hack数据 在这里，我们会惊讶地发现，如果用选择排序的话，虽然是会TLE，但其结果是正确的。\n【相关原因请查看后面的「有关排序的深层理解」部分】\n个人发现了选择排序答案是正确的后，对各种排序的实现展开了思考和实验。\n认为像快速排序或归并排序等，是因为采用典型的分治思想才导致需要满足严格弱序的。\n那么对于其他排序方法比如“希尔排序”、“堆排序”、“锦标赛排序”等是否不需要满足严格弱序呢？\n【这里没考虑“计数排序”、“基数排序”和“桶排序”这三种非比较式排序算法。因为这里没有关键字，无法使用这三种排序方法。\n所以在实验的时候就弄出了一些其他的hack数据，\n然后其中发现了一组很特殊的hack数据！(:з」∠)……\n 数据：\n 1\n5\n9 7\n1 1\n4 5\n1 2\n6 5\n *以下表格中的option表示$\\max(c_{i-1},\\sum_{j=1}^ia_j)$选择的哪个*。\n  标准答案：27\n  利用选择排序后的结果\n    $a$ $b$ $c$ option     1 $1$ $2$ $3$    2 $1$ $1$ $4$ $c$   3 $4$ $5$ $11$ $\\sum a$   4 $9$ $7$ $22$ $\\sum a$   5 $6$ $5$ $27$ $c$      特殊性\n我们如果排序成：\n    $a$ $b$ $c$ option     1 $4$ $5$ $9$    2 $1$ $2$ $11$ $c$   3 $9$ $7$ $21$ $\\sum a$   4 $1$ $1$ $22$ $c$   5 $6$ $5$ $27$ $c$    会发现$1$和$2$（$i=1,j=2$）这两组数据，\n其实是不满足$\\min(a_i,b_j) \u0026lt; \\min(a_j,b_i)$这个条件的！\n故这也告诉了我们：最优解也可能存在有两项不满足决策条件的状态。\n【更准确叙述请查看后面的「有关贪心决策的满足度影响」部分】\n  有关自己使用其他排序方法验证的代码，以及其他两组hack数据可见Pastebin。\n决策条件是否正确的判断方法 1、条件检查器 基于以上分析，我们发现：\n如果按上述“基本决策寻找方法”得到的决策条件$P$是正确的，必须要满足基本的排序型贪心的条件：\n 数列任意两项满足决策条件。\n 如果决策条件$P$满足以下条件，则可证得排序后一定满足该基本条件：\n 满足严格弱序中的两个传递性。  根据以上一点，我们可以编写一个条件检查器。\n【这个条件检查器的方法是参考自“ouuan”的博客后了解的，个人在其基础之上有所修改并加入了注释……\n#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstdio\u0026gt;using namespace std; bool cmp(int i, int j); int a[10], b[10]; int main() { for (a[0] = 1; a[0] \u0026lt;= 6; ++a[0]) for (b[0] = 1; b[0] \u0026lt;= 6; ++b[0]) //构造第一组a,b数组数据：用来判断自反性  { if (cmp(0, 0)) //不满足自反性。  //分析知这条对于贪心思路并不是很重要，所以注释了。但如果用sort就很重要。  //printf(\u0026#34;No irreflexivity: %d %d\\n\u0026#34;, a[0], b[0]);  for (a[1] = 1; a[1] \u0026lt;= 6; ++a[1]) for (b[1] = 1; b[1] \u0026lt;= 6; ++b[1]) //构造第二组a,b数组数据：用来判断非对称性  { if (cmp(0, 1) \u0026amp;\u0026amp; cmp(1, 0)) //非对称性的判断  printf(\u0026#34;No asymmetric: %d %d %d %d\u0026#34;, a[0], b[0], a[1], b[1]); /* 这部分原本是判断 我们新的决策条件 与 最开始分析的决策条件 是否判断一致，但其实可以不用判断。 //同理，在ouuan所写的判断器中：有一个关于「排序完成后任意交换相邻元素均不会使答案更优」这个的判断，但实际上如果满足了严格弱序一定也会满足这个条件，也不用判断。 bool our_judge = cmp(0, 1), real_judge = min(a[0], b[1]) \u0026lt; min(a[1], b[0]), if_equal = min(a[0], b[1]) == min(a[1], b[0]); //注意这里真实判断（以决策条件判断），如果为0：有可能真的不满足，但也有可能是相等情况；如果为1：那就一定是满足 //所以我们要加个if_equal，如果是相同状况则不判断是否与真是判断相同 if (!if_equal \u0026amp;\u0026amp; our_judge != real_judge) //与真正决策条件判断不同 printf(\u0026#34;Not correct(%s): %d %d %d %d\\n\u0026#34;, (our_judge == 1 ? \u0026#34;We judge it\u0026#39;s right, but truth is wrong.\u0026#34; : \u0026#34;We judge it\u0026#39;s wrong, but truth is right\u0026#34;), a[0], b[0], a[1], b[1]); */ for (a[2] = 1; a[2] \u0026lt;= 6; ++a[2]) //构造第三组a,b数据：用来判断传递性  for (b[2] = 1; b[2] \u0026lt;= 6; ++b[2]) { bool flag_inequ = 1, flag_equ = 1; bool cmp_01 = cmp(0, 1), cmp_12 = cmp(1, 2), cmp_02 = cmp(0, 2); //注意我们判断两状态是否是用的!cmp(i,j) \u0026amp;\u0026amp; !cmp(j,i)（非对称性的利用）  bool euqal_01 = !cmp(0, 1) \u0026amp;\u0026amp; !cmp(1, 0), euqal_12 = !cmp(1, 2) \u0026amp;\u0026amp; !cmp(2, 1), euqal_02 = !cmp(0, 2) \u0026amp;\u0026amp; !cmp(2, 0); if ((cmp_01 == cmp_12 \u0026amp;\u0026amp; (cmp_01 == 1 || (cmp_01 == 0 \u0026amp;\u0026amp; !euqal_01 \u0026amp;\u0026amp; !euqal_12))) \u0026amp;\u0026amp; cmp_01 != cmp_02) //不符合不等传递性  { /* 怎么才算符合不等传递性： 1 1 -\u0026gt; 1 1 0 -\u0026gt; ? (2 \u0026lt; 7, 7 \\not\u0026lt; 5 ---\u0026gt; 2 \u0026lt; 5)(2 \u0026lt; 7, 7 \\not\u0026lt; 1 ---\u0026gt; 2 \\not\u0026lt; 1) 0 1 -\u0026gt; ? (Same way) 0 0 -\u0026gt; 0 //但要注意这里cmp为0：有可能是不满足，也有可能是因为等于的情况。所以要加!euqal来排除等于情况 */ flag_inequ = 0; printf(\u0026#34;No transitivity of inequivalence: %d %d %d %d %d %d\\n\u0026#34;, a[0], b[0], a[1], b[1], a[2], b[2]); } if (!(euqal_01 == 0 \u0026amp;\u0026amp; euqal_12 == 0) \u0026amp;\u0026amp; (euqal_01 \u0026amp;\u0026amp; euqal_12) != euqal_02) //相等传递性  { /* 怎么才算符合相等传递性： 1 1 -\u0026gt; 1 1 0 -\u0026gt; 0 0 1 -\u0026gt; 0 0 0 -\u0026gt; ? (2 ≠ 3, 3 ≠ 2 ---\u0026gt; 2 = 2)//这个很好知道吧【…… */ flag_equ = 0; printf(\u0026#34;No transitivity of equivalence: %d %d %d %d %d %d\\n\u0026#34;, a[0], b[0], a[1], b[1], a[2], b[2]); } if (flag_inequ == 1 \u0026amp;\u0026amp; flag_equ == 0) //私货：求证如果满足不等传递性，但不满足相等传递性，是否X=Y,Y\u0026lt;Z---\u0026gt;X\u0026lt;Z；X\u0026lt;Y,Y=Z---\u0026gt;X\u0026lt;Z？  { printf(\u0026#34;===In Case===\\n\u0026#34;); bool euqal_cmp01 = !cmp(0, 1) \u0026amp;\u0026amp; !cmp(1, 0), ineuq_cmp01 = cmp(0, 1), euqal_cmp12 = !cmp(1, 2) \u0026amp;\u0026amp; !cmp(2, 1), ineuq_cmp12 = cmp(1, 2), euqal_cmp02 = !cmp(0, 2) \u0026amp;\u0026amp; !cmp(2, 0), ineuq_cmp02 = cmp(0, 2); if (euqal_cmp01 \u0026amp;\u0026amp; ineuq_cmp12) { if (!ineuq_cmp02 \u0026amp;\u0026amp; !euqal_cmp02) printf(\u0026#34;---X=Y,Y\u0026lt;Z---\u0026gt;X not\u0026lt; Z: %d %d %d %d %d %d\\n\u0026#34;, a[0], b[0], a[1], b[1], a[2], b[2]); else if (!ineuq_cmp02) printf(\u0026#34;---X=Y,Y\u0026lt;Z---\u0026gt;X = Z: %d %d %d %d %d %d\\n\u0026#34;, a[0], b[0], a[1], b[1], a[2], b[2]); } if (ineuq_cmp01 \u0026amp;\u0026amp; euqal_cmp12) { if (!ineuq_cmp02 \u0026amp;\u0026amp; !euqal_cmp02) printf(\u0026#34;---X\u0026lt;Y,Y=Z---\u0026gt;X not\u0026lt; Z: %d %d %d %d %d %d\\n\u0026#34;, a[0], b[0], a[1], b[1], a[2], b[2]); else if (!ineuq_cmp02) printf(\u0026#34;---X\u0026lt;Y,Y=Z---\u0026gt;X = Z: %d %d %d %d %d %d\\n\u0026#34;, a[0], b[0], a[1], b[1], a[2], b[2]); } } } } } return 0; } bool cmp(int i, int j) { /* 展开式：【用来debug方便watch的…… int min_ij = min(a[i], b[j]), min_ji = min(a[j], b[i]); bool ans = 0; if (min_ij == min_ji) ans = a[i] \u0026lt; a[j]; else ans = min_ij \u0026lt; min_ji; return ans; */ return min(a[i], b[j]) \u0026lt; min(a[j], b[i]); //Case.1  //return min(a[i], b[j]) \u0026lt;= min(a[j], b[i]); //Case.2  //return min(a[i], b[j]) == min(a[j], b[i]) ? a[i] \u0026gt; a[j] : min(a[i], b[j]) \u0026lt; min(a[j], b[i]); //Case.3  //return min(a[i], b[j]) == min(a[j], b[i]) ? a[i] \u0026lt; a[j] : min(a[i], b[j]) \u0026lt; min(a[j], b[i]); //Case.4 } 上述提到了：如果满足了严格弱序一定也会满足「排序完成后任意交换相邻元素均不会使答案更优」这个条件。\n所以我并没有写上“ouuan”博客中的那个条件。\n而且对于严格弱序，我也认为只用判断传递性即可。\n【如果这种修改有误，请务必告诉我！……\n因为决策条件$P$满足严格弱序后，我们按照$P$排序后，一定会使任意两项均满足$P$，则满足我们的贪心的思想，使得肯定这个状态是最优解状态。\n【但这种口头解释没有严格证明可能没有说服力，可以自己在判断器里删掉注释然后验证一下_(:з」∠)_……\n2、与选择排序对拍 当然，我们发现了：用选择排序的话结果是正确的。\n所以我们也可以很快地写个选择排序，然后跟我们新的方法进行对拍。\n其他补充点 有关排序的深层理解 我们发现选择排序用之前的条件，虽然会TLE，但是是正确的。\n 洛谷上测试状态【其余未放出的均AC】：\n将其两组数据放到本地测评：\n 主要就是因为排序这种绝对的$O(n^2)$的算法，是严格让所有数据都两两比较。\n正式因为其两两比较，使得不需要利用满足数据严格弱序的传递性。\n不会像快排或归并等其他非$O(n^2)$的算法一样，利用严格弱序中的传递性，来对某些情况减少判断，达成了降低复杂度的办法。\n也就是说，他们为了提高速度，省略了一些比较。代价就是数据必须要满足一定的条件，即严格弱序。\n同样，就连冒泡排序这种本来也是$O(n^2)$的排序算法【但实际上并不是绝对的$O(n^2)$，其最坏是$\\frac{(n-1)n}{2}$次操作】，\n因为只是比较相邻的数据，并未严格任意两两比较。也是利用了传递性。\n有关贪心决策的满足度影响 之前发现：\n让任意两项都满足决策条件，是一定是最优解的。\n但之前发现：如果存在两项不满足，也有可能是最优解。\n也就是任意两项都满足决策条件的这种状态，是最优解状态的一种，为$∈$关系。\n但我们只能去找任意两项均满足的这种状态。因为对于存在两项不满足的，也有可能不是最优解，就成了概率问题。\n【而这道题概率出来就是80分……\n有关排序对严格弱序的不同要求   $X \\not\u0026lt; X$（比较条件非自反性） 若$X \u0026lt; Y$，则$Y \\not\u0026lt; X$（比较条件非对称性） 若$X \u0026lt; Y,Y \u0026lt; Z$，则$X \u0026lt; Z$（比较条件不等传递性） 若$X=Y,Y=Z$，则$X=Z$（比较条件相等传递性）   前面已经说了，对于1、2点，其实对于贪心的题目要求并不严格。\n不满足的话只是会多交换几次，导致状态不同，但最终的ans是一样的。\n但某些算法要求必须要遵守1、2点。\n  对于用STL库的sort()：\n其必须还要考虑1、2点非自反性和非对称性。\n因为内部的算法实现，对下标的判断需要用到这两个性质，否则会越界导致RE。\n【不过我没有具体去看函数内部的代码实现，只是根据网上搜的以及自己实验得出来的，不一定准确。但确实不考虑这两个的话会出现RE……\n  对于其他非$O(n^2)$排序方法：\n如：归并排序merge：\n则不用考虑1、2点。\n【当然还是要根据自己的排序写法来判断是否需要满足1、2点……\n  有关传递性的简单判断 我们排序比较时，只会比较两个元素，也就是两个下标，一般用$i,j$代表。\n而排序（决策）条件，也一定是与$a_i$和$a_j$的衍生关系。\n那么排序条件的下标会有两种情况：\n  一侧只有一个下标\n形如：$cmp(x,y)=A_x?A_y$\n当比较条件一侧只有一个下标的时候很好理解，就是普通的数列排序。\n单侧下标时，两个下标的选择不会影响其对应的比较用数据的值，\n故一般能符合比较条件不等传递性和比较条件相等传递性。\n 举例：    条件为$a_i\u0026gt;a_j$\n取$i,j$：$a_i=a_j$\n取$j,k$：$a_j=a_k$\n取$i,k$：$a_i=a_k$ 条件为$a_i+a_{i+1}\u0026gt;a_j+a_{j+1}$\n取$i,j$：$a_i+a_{i+1}=a_j+a_{j+1}$\n取$j,k$：$a_j+a_{j+1}=a_k+a_{k+1}$\n【则可直接推得$a_i+a_{i+1}=a_j+a_{j+1}=a_j+a_{j+1}=a_k+a_{k+1}$】\n取$i,k$：$a_i+a_{i+1}=a_k+a_{k+1}$     一侧两个下标都有\n形如：$cmp(x,y)=A_{x,y}?A_{y,x}$\n当一侧两种下标都有时，则不同下标的选择会影响其对应的比较用数据的值。\n故需要具体判断是否比较条件传递性和比较条件相等传递性。\n 举例：    条件为$a_i+a_{j+1}\u0026gt;a_j+a_{i+1}$\n取$i,j$：$a_i+a_{j+1}=a_j+a_{i+1}$\n取$j,k$：$a_j+a_{k+1}=a_k+a_{j+1}$\n【不可直接推得$a_i+a_{j+1}=a_j+a_{i+1}=a_j+a_{k+1}=a_k+a_{j+1}$】\n但可证得：取$i,k$：$a_i+a_{k+1}=a_k+a_{i+1}$     总结 有关排序型贪心，最基本的条件：\n 数列任意两项满足决策条件。\n 而我们可以利用传递性，只用分析相邻两项，来得到决策条件。\n但在找到决策条件之后，要判定其是否满足严格弱序中的“相等传递性”和“不等传递性”\n因此题目解决大致思路方法：\n  找出每种状态的ans，选邻项代入 假设相邻位置，写出两种状态的ans 根据题意写出排序条件并化简，得到最终决策方案（不一定划到最简） 判断是否满足传递性 如满足：自定义结构体，重载\u0026lt;运算符，使用sort，遍历寻答案    以上部分参考自“ouuon”的「浅谈邻项交换排序的应用以及需要注意的问题」，以及“Joker\u0026amp;Liar”的「浅谈邻项交换排序」\n写在最后：\n 真的没想到写了这么多orz……弄了整整四天来写这一个东西qwqqq……\n写这么长而且也很混乱，估计以后自己或者其他人也根本看不下去吧x【……\n不过其实这里面还是有很多新发现的。比如快速排序算法的快速原因，以及最珍贵的就是那个不符合任意两项满足条件但是也对的hack数据什么的……\n也算是很深入地去理解贪心中这排序型贪心的本质……并且有一些也是在“ouuan”dalao博客里所没有的新发现，也算是比较安慰了【？……\n就这样吧，最近刚好也发生了很多事……\n按照自己的步调前行吧……\n ","date":"2020-12-15T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-neighbor_sort/71111285_p0_hud2648e021785c2a9f9434e425c67999f_2056049_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-note-neighbor_sort/","title":"ACM学习笔记：邻项比较排序……"},{"content":" 该笔记目前直接复制的之前的笔记，还未调整格式。可能格式、内容、链接等混乱错误…… \r 贪心介绍 定义 贪心，指的是决策时都采取当前最优解的算法。\n可以通过局部最优解拓展得到全局最优解。\n用处 寻找最优解（如：找最大(小)值）\n贪心类别 一、排序型贪心 这种类型就是通过给数据排序，不同的排序方法演绎下去就会有不同的答案ans。\n然后要比较所有排序方法，选让这些ans的最值。\n  为什么会想到排序？\n 虽然我们只看重眼前利益选择当前的最优解，随时准备开冲去比较两者选获利最大的【指直接从头开始遍历然后选择】。\n但这个时候我们暂且压一下枪理智一下：我们怎么知道我们现在选的是不是最优解呢？\n也就是说，可能现在这两个中，我选了一个当前最优解，但实际上跟后面比起来，这两个都不是最优解。\n也就是著名的苏格拉底的“拣麦穗的故事”。\n所以我们以全局眼光来看这些数据，飞到这片麦田之上，就会发现：“哦~原来利益最大的在那个地方、第二大的又在另个地方……”\n然后我们知道这些获利最大的点在哪里，就用原力把他们放到我们面前来，然后直接取走就行了。\n或者说：我们先辛苦一下对这些数据排下序，然后直接取最优结果就可以了。\n   所以我们就能得到有关排序型贪心的定义：\n 通过对数据，按照某种决策条件排序，使得任意两项均满足该决策条件，而找到最优解。\n 实现方法  根据题意，分析每种状态的ans如何计算，以及题目要求取ans的什么最值。 采用邻项交换排序思想，选取相邻两项$i,i+1$，比较两种状态的ans，选择最优的ans。由此可以推出一种基于数据比较的决策方案。 按照该决策方案排序，算出排序后状态的ans值，即为结果。  邻项交换排序 这一部分请查看邻项交换排序笔记。\n二、反悔型贪心 依然是上面的引例：\n【我管不了那么多了我现在就要开冲.jpg……\n但一路冲下去，如果发现有比之前选择的更好的数据，\n我们是不是就会觉得后悔，觉得如果之前不选那个而选这个该多好。\n因此我们就可以从之前所选择的当中，取一个最差的，然后跟这个最好的换一下。\n这就是反悔贪心法的基本思路：\n 无论当前的选项是否最优都先接受，然后继续往后进行比较。\n如果发现有比之前选择更优的，则反悔，舍弃之前最差的换成这个选项；否则继续往后比较。直到序列遍历完。\n  要记录之前所选择的，则一般采用优先队列。  ","date":"2020-12-14T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-greedy/80942286_p0_hu1614f1e19d3d1ca6099df8f8b769c088_1500547_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-note-greedy/","title":"ACM学习笔记：贪心……"},{"content":" 该笔记目前直接复制的之前的笔记，还未调整格式。页面格式、内容、链接等可能存在混乱错误…… \r GCD 引例：最大公约数 没什么好说的，就最大公约数。\n主要是他的求解方法：欧几里得算法(Euclidean algorithm)（即：辗转相除法）。\n欧几里得算法 也不多讲，证明也懒得_(:з」∠)_……\n主要是他的扩展：**扩展欧几里得定理**(Extended Euclidean algorithm, EXGCD)【没有在套娃xddd……\n主要依靠式子：$\\gcd(a,b)=\\gcd(b,a\\mod b)$\n当 $b=0$ 时，此时算出来的 $a$ 即为最终 $\\gcd(a,b)$ 的结果。\n时间复杂度为$O(\\log n)$。\n实现代码  递归实现：  long long gcd(long long a, long long b) { //if (a \u0026lt; b) \t//\treturn gcd(b, a); \t/* 删除原因： 虽然用辗转相除法需要满足a \u0026gt; b。 但如果a \u0026lt; b，则b % a = a， gcd(b, b % a)实际上就相当于交换了a,b。故不用单独判断。 */ if (b == 0) return a; return gcd(b, b % a); /* 一行代码： return b ? gcd(b,b%a) */ }  迭代实现：  long long gcd_iteration(long long a, long long b) { while (b ^= a ^= b ^= a %= b);\t//b^=a^=b^=a为交换两变量操作，最后以b的值为循环条件。  return a; } 多个数的最大公约数 求 $a_1,a_2,\\cdots,a_n$ 个数的最大公约数，\n直接为 $\\gcd(a_1,a_2,\\cdots,a_n)$。\n先算$\\gcd(a_1,a_2)$，所得结果$d_1$，再$\\gcd(d,a_3)$，反复进行。\n此处以上为基础部分。\n 裴蜀定理（贝祖定理） 在学EXGCD之前，要先来认识一下这个定理。\n 裴蜀定理，又称贝祖定理(Bézout\u0026rsquo;s lemma)。是一个关于最大公约数的定理。\n引自：OI-Wiki\n 定义  若 $a,b$ 是不全为零的整数，记：$\\gcd(a,b)=d$，\n则对于任意的整数 $x,y$ ， $ax+by$ 都一定是 $d$ 的整数倍。\n 特别的：一定存在整数 $x,y$ ，使 $ax+by=d$ 成立。     为充要条件，即：\n若 $ax+by=c$ 有解，\n则 $\\gcd(a,b)\\mid c$ 。（其中 $\\mid$ 为整除符号，代表$c$能被$\\gcd(a,b)$整除）\n（或者说 $c$ 是 $\\gcd(a,b)$的整数倍）\n 特别的：如果 $ax+by=1$ ，则 $a,b$ 互质（$\\gcd(a,b)=1$）。  这个即为二元一次不定方程存在解的条件。\n  简洁一点则为：\n 若 $a,b$ 是不全为零的整数，\n则存在整数 $x,y$ , 使得 $ax+by=\\gcd(a,b)$ 。\n 这个定理只是个概念，让你知道有这样的解存在，但并没有实际告诉你该怎么解。\n推论  有关互质：  $a,b$ 互质（$\\gcd(a,b)=1$）的充要条件为：\n存在整数 $x,y$ ，使得$ab+by=1$\n  推广到$n$个数的情况：  设存在$n$个整数 $a_1,a_2,\\cdots,a_n$ ， $d= \\gcd(a_1,a_2,\\cdots,a_n)$ ，\n则存在整数 $x_1,x_2,\\cdots,x_n$ ， $x_1a_1+x_2a_2+\\cdots+x_na_n=d$ 有解。\n 特别的：\n如果 $a_1,a_2,\\cdots,a_n$ 互质，（不是两两互质，而是存在两个数互质，即：$\\gcd(a_1,a_2,\\cdots,a_n)=1$）\n则存在整数 $x_1,x_2,\\cdots,x_n$ ，使得 $x_1a_1+x_2a_2+\\cdots+x_na_n=1$ 。     参考自：“静听风吟。”的「数学：裴蜀定理」。\n基本应用（例题）  例题：Codeforces Round #290 (Div. 2) D. Fox And Jumping\n给出$n$张卡片，分别有$l_i$和$c_i$。在一条无限长的纸带上，你可以选择花$c_i$的钱来购买卡片$i$，从此以后可以向左或向右跳$l_i$个单位。 问你至少花多少元钱才能够跳到纸带上全部位置。若不行，输出$-1$。\n 分析该问题：\n如果每个格子都想要被跳到，则必须选出一些数，使得数次加减后绝对值为$1$。【我们定加减后值就为$1$。因为如果为$-1$，可以通过反向跳跃（取相反数）使得值为$1$。】\n这样通过每次移动$1$格，便能满足跳到每个格子上，否则一定不能满足。\n由上述裴蜀定理的“推论2”可知：\n如果要满足 $x_1a_1+x_2a_2+\\cdots+x_n*a_n=1$ ，\n则必须满足 $\\gcd(a_1,a_2,\\cdots,a_n)=1$ 。\n但又由于有代价的存在，【分析了这么多，那么代价呢x……\n所以可以用$dp$思想：\n 用个dp表存跳某步的代价最小值。\n那么每读入一个，则对所存的状态进行遍历，\n求取其与某状态的$\\gcd$，算出来是多少，则这两个数可以通过数次加减后走多少格。\n不断更新，最后如果dp[1]存在，则输出，否则输出-1。\n 又因为数据范围太大，故用map来代替基本的数组来存。\n【OI-Wiki上说可以用unordered_map。但由于这里要遍历，故我觉得还是要用map。unordered_map由于其内部是用哈希表实现的，遍历时可能访问不全。\n部分代码 map\u0026lt;int, int\u0026gt; dp; for (int i = 1; i \u0026lt;= n; i++) { dp[l[i]] = dp[l[i]] ? min(dp[l[i]], c[i]) : c[i];\t//如果存在要去最小  for (auto j : dp)\t//遍历当前dp表  { int to = __gcd(l[i], j.first);\t//计算能去的点（gcd）  int cost = dp[l[i]] + j.second;\t//计算代价  dp[to] = dp[to] ? min(dp[to], cost) : cost; } } 参考自：“Kanoon”的Codeforces Round #290 (Div. 2) D. Fox And Jumping（数论，裴蜀定理，gcd）\n扩展欧几里得定理  扩展欧几里得定理（Extended Euclidean algorithm, EXGCD），常用于求 $ax+by= \\gcd(a,b)$ 的一组可行解。\n引自——OI-Wiki\n 方法详解 求 $ax+by= \\gcd(a,b)$ 的一组可行解：\n设:$a\u0026gt;b$，则有以下两种情况\n  当$b=0$时，$\\gcd(a,b) = a$，所以存在一组解$\\left{\\begin{array}{ll}x = 1\\y =0\\end{array}\\right.$\n  当$a=0$时，$\\gcd(a,b)=\\gcd(b,0)$，一样的结果。\n  当$ab\\neq0$时：\n 设：\n$\\left{\\begin{array}{ll} ax_1+by_1=\\gcd(a,b) \\ bx_2+(a \\mod b)y_2=\\gcd(b,a \\mod b) \\end{array}\\right.$\n由欧几里得算法可知： $\\gcd(a,b) = \\gcd(b,a \\mod b)$\n故： $ax_1+by_1 = bx_2+(a \\mod b)y_2$\n又因为： $a \\mod b = a-(\\lfloor \\frac{a}{b} \\rfloor \\times b)$\n所以：\n$ax_1+by_1$\n$= bx_2+[a-(\\lfloor \\frac{a}{b} \\rfloor \\times b)]y_2$\n$= ay_2+bx_2 - \\lfloor \\frac{a}{b} \\rfloor \\times by_2$\n$= ay_2+b(x_2 - \\lfloor \\frac{a}{b} \\rfloor \\times y_2)$\n因为上下两式中： $a=a,b=b$\n所以：$\\left{\\begin{array}{ll} x_1=y_2 \\ y_1=x_2-\\lfloor \\frac{a}{b} \\rfloor \\times y_2 \\end{array}\\right.$\n 便可得到递归式：$\\textup{exgcd}(x,y)=\\textup{exgcd}(y,x-\\lfloor \\frac{a}{b} \\rfloor \\times y)$（此时的$a,b$是属于$\\textup{exgcd}(x,y)$状态的$a,b$）\n终止条件： $b=0$时，$\\left{\\begin{array}{ll}x = 1\\y =0\\end{array}\\right.$\n 虽然$\\gcd(a,b)$和$\\textup{exgcd}(a,b)$都有递归式，\n但$\\textup{exgcd}$不同于求$\\gcd$：\n 求解$\\gcd$是知道最开始的初状态，一直递归求得末状态。 求解$\\textup{exgcd}$只是知道末状态，要根据末状态再倒推回去求解初状态（一组解）。\n则需要不断递归到末状态，再由末状态反推到初状态。故可配合$\\gcd$求得$\\textup{ecgcd}$     实现代码  递归实现：  //函数返回值为gcd，过程中计算x,y。 int Exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y) { if (b == 0) //代表通过gcd求得末状态，  { x = 1, y = 0; //由上分析知：终状态为x = 1, y = 0。  return a; } int gcd = Exgcd(b, a % b, x, y); //直接递归gcd求  int t = x; //这里之后开始反推回去  x = y; y = t - (a / b) * y; return gcd; }   迭代实现：\n有关$\\textup{exgcd}$的迭代方式，可以采用矩阵乘法的思路理解。\n 这是我们找到的递归式：\n$$\\textup{exgcd}(x,y)=\\textup{exgcd}(y,x-\\lfloor \\frac{a}{b} \\rfloor \\times y)$$\n或写为：$\\left{\\begin{array}{ll} x=y' \\ y=x'- \\lfloor \\frac{a}{b} \\rfloor \\times y' \\end{array}\\right.$（此时的$a,b$是属于$\\textup{exgcd}(x,y)$状态下的$a,b$）\n变成矩阵形式： $$\\begin{pmatrix} x \\ y \\end{pmatrix}=\\begin{pmatrix} 0\u0026amp;1 \\ 1\u0026amp;-d_1 \\end{pmatrix}\\begin{pmatrix} x' \\ y' \\end{pmatrix}$$ 其中$d_1$表示第一次迭代（初状态）的$\\lfloor\\frac{a}{b}\\rfloor$。\n然后就可以一直乘下去展开，直到最终状态： $$\\begin{pmatrix} x \\ y \\end{pmatrix} = \\begin{pmatrix} 0\u0026amp;1 \\ 1\u0026amp;-d_1 \\end{pmatrix} \\begin{pmatrix} 0\u0026amp;1 \\ 1\u0026amp;-d_2 \\end{pmatrix} \\cdots \\begin{pmatrix} 0\u0026amp;1 \\ 1\u0026amp;-d_n \\end{pmatrix} \\begin{pmatrix} 1 \\ 0 \\end{pmatrix}$$ 因此就可以顺着迭代：计算出中间$n$个二阶矩阵$\\begin{pmatrix} 0\u0026amp;1 \\ 1\u0026amp;-d_i \\end{pmatrix}$的乘积。最后到最终状态乘$\\begin{pmatrix} 1 \\ 0 \\end{pmatrix}$，也就是直接取最终算出的二阶矩阵$\\begin{pmatrix} x_1\u0026amp;x_2 \\ y_1\u0026amp;y_2 \\end{pmatrix}$的$x_1,x_2$\n 我们还可以调整一下，设定一个初矩阵，然后直接乘每次的$\\begin{pmatrix} 0\u0026amp;1 \\ 1\u0026amp;-d_i \\end{pmatrix}$，就不用额外处理初状态，直接顺着迭代着走就可以了。\n否则需要额外处理初状态，要令初矩阵为$\\begin{pmatrix} 0\u0026amp;1 \\ 1\u0026amp;-d_1 \\end{pmatrix}$，然后还要迭代次$\\gcd(a,b)$才能进入循环。\n易知这个初状态就是单位矩阵$\\begin{pmatrix} 1\u0026amp;0 \\ 0\u0026amp;1 \\end{pmatrix}$。\n   int Exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y) { x = 1, y = 0; //初矩阵：1 0  int x1 = 0, y1 = 1; // 0 1  /* 不定义这个初矩阵的话就要写为： x = 0, y = 1; //初矩阵：0 1 int x1 = 1, y1 = -a/b; // 1 -d1 tie(a, b) = make_tuple(b, a - (a/b) * b); //然后还要迭代一下 */ while (b) { int d = a / b; tie(x, x1) = make_tuple(x1, x - d * x1); //矩阵乘法  tie(y, y1) = make_tuple(y1, y - d * y1); tie(a, b) = make_tuple(b, a - d * b); //迭代gcd()  } return a; } ","date":"2020-12-12T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-gcd_exgcd/73415224_p0_hu09ddeb20de934db6dbd54dd691a098a4_1500993_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-note-gcd_exgcd/","title":"ACM学习笔记：GCD、裴蜀定理、EXGCD……"},{"content":" 该笔记还未完成整理，待日后继续整理…… \r  该笔记目前直接复制的之前的笔记，还未调整格式。页面格式、内容、链接等可能存在混乱错误…… \r\n0x00 前提知识 同余 $\\equiv$：是数论中表示同余的符号。\n用法：$a \\equiv b \\pmod n$\n定义  最基本的定义：两个数$a,b$对另一个数$n$的取余都相同。 衍生定义：$(a-b) \\bmod n = 0$  记作：$a \\equiv b \\pmod n$，表示$a,b$对$n$同余。\n 如：\n$7 \\bmod 3 = 1$\n$10 \\bmod 3 = 1$\n则：$7 \\equiv 10 \\pmod 3$\n 性质 以下部分为个人总结，名称不一定准确。\n 自反性：$a \\equiv a \\pmod m$。 对称性：若$a \\equiv b \\pmod m$，则$b \\equiv a \\pmod m$。 传递性：若$a \\equiv b \\pmod m$，$b \\equiv c \\pmod m$，则$a \\equiv c \\pmod m$。 替换性：对于$M \\equiv ab \\cdot x \\pmod m$，若$ab \\equiv c \\pmod m$，则$M \\equiv c \\cdot x\\pmod m$。 加减可移项性：若$a \\pm b \\equiv c \\pmod m$，则$a \\equiv c \\mp b \\pmod m$ 线性运算：如果$a \\equiv b \\pmod m$，$c \\equiv d \\pmod m$，那么有：  $a \\pm c \\equiv b \\pm d \\pmod m$。 $ac \\equiv bd \\pmod m$。\n推论：若$a \\equiv b \\pmod m$，则有$an \\equiv bn \\pmod m (n\\in Z, n \\ne 0)$。   模数的除法：若$ac \\equiv bc \\pmod m$，$\\gcd(m,c)=d$，则$a \\equiv b \\pmod{m/d}$；\n特别地，当$\\gcd(m,c)=1$时，有$a \\equiv b \\pmod m$。 模数的乘法：若$a \\equiv b \\pmod m$，则有$ak \\equiv bk \\pmod{mk}$，其中$k$为大于零的整数；\n推论：若$a \\equiv b \\pmod m$，$d$为$a,b$及$m$三者的任一正公约数，则$a/d \\equiv b/d \\pmod{m/d}$。 传递性2：若$a \\equiv b \\pmod m$，且$d \\mid m$，则$a \\equiv b \\pmod d$。  参考自“wcwcwch”的「同余的性质」。\n其他点 需要注意的是：\n负数也可以进行取模，因此也存在同余。\n 如：\n$-36 \\bmod 15$，\n用除法表示为$-36 \\div 15 = -3 \\cdots 9$（验算：$15*-3+9=-36$），\n即$-36 \\bmod 15 = 9$，\n所以$-36 \\equiv 24 \\pmod{15}$。\n  由于这个符号很新颖和陌生，导致在学习的时候理解上产生了很大的障碍，\n因此需要尽快适应这个符号的使用方法。\n首先需要知道的是：同余代表的是一种关系，而非运算。\n因此才会采用类似于等号的符号来表示。\n但这种等于，并不是像$2=2$这样直接就可以判断，\n而是要经过稍微的运算，两边同时取模后等于，才叫同余。\n然后对于这个符号，有很多种不同的理解方式，\n建议自己确定一个自己习惯的理解方式并一直用下去。\n个人所采用的是：$a \\equiv b \\pmod m$，代表$a \\bmod m = b \\bmod m$。\n 需要牢记一个转换式： $$a \\equiv b \\pmod m \\implies a = mk + b (k∈Z)$$\n整除 $\\mid$：是数论中的表示整除符号。\n用法：$a \\mid d$\n注意：\n这里的整除就是整除，不是被整除。\n如上例：是$a$整除$b$，或说$b$被$a$整除。\n 如：\n$2\\mid14$\n则是$2$整除$14$，$14$被$2$整除。\n 整除也代表两者大除小余数为$0$，故同余还可以写为：\n$m \\mid (a-b)$\n$\\implies (a-b) \\bmod n = 0$\n$\\implies a \\equiv b \\pmod n$\n学习顺序  裴蜀定理 扩展欧几里得 初步认识线性同余方程 认识乘法逆元并求解 求解线性同余方程  其中：\n 1、2为$\\gcd$内容， 3、4、5为本章（线性同余方程）内容。  0x01 初步认识 定义 形如$f(x) \\equiv 0 \\pmod m$的方程称为同余方程，\n其中$f(x)=a_nx^n+a_{n-1}x^{n_1}+\\cdots+a_1x+a_0$。\n记：$f(x)$最高次数为$n$，则称为$n$次同余方程。\n特别的：当$n=1$时，称为一次同余方程，又称线性同余方程。\n即：\n形如$ax \\equiv b \\pmod m$的方程，\n被称为线性同余方程(Congruence Equation)。\n 如：\n$12x \\equiv 9 \\pmod {15}$\n解得：$x=\\cdots,-3,2,7,12,17,\\cdots,5n+2(n∈Z)$\n当$x=-3$时，$12*-3=36$，$-36 \\bmod 15 = 9$，满足方程。\n当$x=2$时，$12*2=24$，$24 \\bmod 15 = 9$，满足方程。\n当$x=7$时，$12*7=84$，$84 \\bmod 15 = 9$，满足方程。\n  同样，对于这个方程，\n我们也需要对其快速建立自己的理解方法。\n个人理解方法是：\n当$x$取某一值时，则$ax$对$m$取模的结果就是$b$。\n  与普通的一元线性方程不同的是：\n普通的一元线性方程肯定存在唯一解（如$2x+3=5$）；\n而线性同余方程若有解，需要存在一定条件。\n有解条件 对于线性同余方程$ax \\equiv b \\pmod m$，其存在解的条件是：\n$b$能够被$a$与$m$的最大公约数整除。\n表示为： $$\\gcd(a,m) \\mid b$$\n 如上例中：\n$12x \\equiv 9 \\pmod {15}$\n因为$\\gcd(12,15)=3$，而$3$能整除$9$，\n即$\\gcd(12,15) \\mid 9$，\n所以有解。\n  如：\n$3x \\equiv 5 \\pmod 6$，\n因为$\\gcd(3,6)=3$，而$3$不能整除$5$，\n故该同余方程无解，\n也就是说无论你$x$取何值，都不能满足$3x$对$6$取模后值为$5$。\n  注意到，若$x_0$是线性同余方程$ax \\equiv b \\pmod m$的一个解，\n那么对于$x_n \\equiv x_0 \\pmod m$，$x_n$也是该线性同余方程的解。\n或者说$mk+x_0(k∈Z)$均为解。\n 如上例中：\n$12x \\equiv 9 \\pmod {15}$\n$x_0=2$时为一解，\n因此$15k+2(k∈Z)$均为解，即$2,17,32,\\cdots$均为解。\n$x_0=7$时为一解，\n因此$15k+7(k∈Z)$均为解，即$7,22,37,\\cdots$均为解。\n$x_0=12$时为一解，\n因此$15k+12(k∈Z)$均为解，即$12,27,42,\\cdots$均为解。\n 因此对于线性同余方程的解的个数，我们定义为：\n在$0 \\sim (m-1)$中解的个数。\n 如上例中：\n$12x \\equiv 9 \\pmod {15}$\n解的个数就为$3$个，分别为$2,7,12$。\n 解的性质 对于线性同余方程$ax \\equiv b \\pmod m$，记$\\gcd(a,m)=d$\n若存在解，则会满足以下性质：\n 对于$x_0$为该线性同余方程的任意一解，记，\n则通解可以表示为$\\frac{m}{d}k + x_0 (k∈Z)$。  如上例中：\n$12x \\equiv 9 \\pmod {15}$\n$d=\\gcd(12,15)=3$\n得到一解$x_0=2$，\n则通解可以表示为$5k+2(k∈Z)$。\n  解的个数恰为$d$个。  如上例中：\n$12x \\equiv 9 \\pmod {15}$\n则在$0 \\sim 14$范围中，解为$2,7,12$。\n个数为$d=\\gcd(12,15)=3$，即$3$个。\n  唯一解定理：\n当$d=1$时，该同余方程有且仅有唯一解。  0x02 乘法逆元 定义 如果一个线性同余方程$ax \\equiv 1 \\pmod m$，存在解$x$，\n则$x$称为$a \\bmod m$的逆元，记作$a^{-1}$。\n 如：\n$5x \\equiv 1 \\pmod{14}$，\n当$x=3$时，$15 \\bmod 14 = 1$，满足方程。\n所以$3$为$5$关于$14$的逆元。\n 性质 对于一个线性同余方程$ax \\equiv 1 \\pmod m$，\n记$a$关于$m$的逆元$x$为$a^{-1}$。\n 存在充要条件：$a,m$互素，$\\gcd(a,m)=1$。 唯一性：$a^{-1}$在$[0,m-1]$范围内唯一。  证明：\n我们先假设$a$有两个不相等逆元：$a'$ 和$a''$，\n那么一定有：$aa' \\equiv aa'' \\equiv 1 \\pmod m$\n不妨设$a'∈[0,m-1]$，$a'\u0026lt;a''$且$a''-a'=k$，\n那么由于$a\\ne0$，所以$k$一定是$k \\equiv 0 \\pmod m$ ，即$k=cm(c∈Z,c\\ne0)$（见最上的转换式）\n所以$a''=a' + cm(c∈Z,c\\ne0)$，\n所以$a'\u0026lsquo;∈[cm,(c+1)m-1] (c∈Z,c\\ne0)$，一定不在$[0,m-1]$范围内，\n所以$a$在$[0,m-1]$范围内只能有一个逆元。\n  完全积性：$a^{-1} \\cdot b^{-1} = (a \\cdot b)^{-1}$ $\\gcd(a^{-1},m)=1$。 ${(a^{-1})}^{-1} \\equiv a \\pmod m$  作用 1. 对除法取模 首先对于取模运算，存在以下性质：\n$(a + b) \\bmod p = ((a\\bmod p) + (b\\bmod p)) \\bmod p$ （对）\n$(a - b) \\bmod p = ((a\\bmod p) - (b\\bmod p)) \\bmod p$ （对）\n$(a \\times b) \\bmod p = ((a\\bmod p) \\times (b\\bmod p)) \\bmod p$ （对）\n$(a \\div b) \\bmod p = ((a\\bmod p) \\div (b\\bmod p)) \\bmod p$ （错）\n 如：\n$(100/50)\\bmod20 = 2$\n$\\nRightarrow((100\\bmod20)/(50\\bmod20))\\bmod20=0$\n 因此如果对于一些题目，如果运算要求求余，但该运算为除法，\n我们就不能直接像加减乘运算一样拆开求余。\n但如果被除数，除数也超范围，那是不是只能用高精度了？\n并不是这样，我们可以利用乘法逆元来拆开求余。\n 乘法逆元又称为数论倒数。\n既然这么称呼，那么乘法逆元就跟倒数有相似之处。\n对于普通的数学运算$a \\div b$，\n其也可以写成$a \\times \\frac{1}{b}$。\n因此对于求余运算$(a/b) \\bmod m$，\n其也可以写成$(a \\cdot b^{-1}) \\bmod m$，\n这时便可以拆开求余为$((a\\bmod m) \\cdot (b^{-1}\\bmod m))\\bmod m$。\n 即存在性质： $$a/b \\bmod m = a \\cdot b^{-1} \\bmod m$$\n*参考自“Aloof__”的「乘法逆元的作用（逆元的作用是什么）」。*\n证明 根据逆元的定义，存在： $$b \\cdot b^{-1} \\equiv 1 \\pmod m$$\n同余式两边同乘$a$，得到： $$ab \\cdot b^{-1} \\equiv a \\pmod m$$\n同余式两边同除$b$，得到： $$a \\cdot b^{-1} \\equiv a/b \\pmod m$$\n得证。\n2. 线性同余方程的反函数 对于线性同余方程$ax \\equiv b \\pmod m$，\n表示为函数的形式即为$f(x) = ax \\bmod m$。\n如果知道函数值$f(x)$，\n那么反求解$x$的方法为：$x = f(x) \\cdot a^{-1}$。\n需要满足$x\u0026lt;m$，\n否则为$x \\equiv f(x) \\cdot a^{-1} \\pmod m$。\n 如：\n$2x \\equiv f(x) \\pmod{11}$。 当$x = 13$时，$f(x) = 4。\n$2$对$11$的逆元是$6$，\n$4 \\times 6 = 24$。\n$24 \\equiv x(13) \\pmod{11}$，\n而不是$24 = x(13)$。\n  主要应用于CTF中仿射加密的解密。\n证明 很简单的证明。\n$$ax \\equiv f(x) \\pmod m$$ $$ax \\cdot a^{-1} \\equiv f(x) \\cdot a^{-1} \\pmod m$$ $$x \\equiv f(x) \\cdot a^{-1} \\pmod m$$ 得证。\n求解方法 待补充！……\n","date":"2020-12-12T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-linear_equation/83179646_p0_hua9bd3bd10387d89cf6f6be61b75d18f9_1401560_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/acm-note-linear_equation/","title":"ACM学习笔记：线性同余方程……"},{"content":" 该笔记还未完成整理，待日后继续整理…… \r  该笔记目前直接复制的之前的笔记，还未调整格式。页面格式、内容、链接等可能存在混乱错误…… \r\nSTL 详解 set——集合 set\u0026lt;int\u0026gt; STL_set\nset为关联容器。为一种体现集合性质的容器。\n其中不允许有重复元素。\n并且set中的元素是排好序的（升序）。\n用法 set\u0026lt;int\u0026gt; STL_set; //---对整体的操作--- STL_set.clear();\t//清空 STL_set.empty();\t//返回是否为空 STL_set.size();\t//返回元素个数 //---对元素的操作--- STL_set.insert(...);\t//在集合中插入元素 STL_set.erase(...);\t//删除集合中的元素 STL_set.count(...);\t//返回元素的个数【由于set不能存在重复元素，故只能返回0或1 //---迭代器--- STL_set.begin(); STL_set.end(); STL_set.find(...);\t//返回一个指向被查找到元素的迭代器，未找到返回set::end() STL_set.lower_bound(...)\t//返回大于等于某值的第一个元素的迭代器 STL_set.upper_bound(...)\t//返回大于某个值元素的迭代器 自定义性 set可支持自定义类型，但需要重载\u0026lt;运算符。\n struct type //用来存棋盘状态 { ...; bool operator\u0026lt;(type x) const { return ...; } }  实现 内部以红黑树的形式实现。\n应用场景 set就是关键字的简单集合。当只是想知道一个值是否存在时，set是最有用的。\n同时可以实现数据去重。\n衍生STL  multiset: 关键字可重复出现的set。 unordered_set: 未排序的set（用hash函数组织）。 unordered_multiset: 未排序的可重复出现的set。  map——映射 map\u0026lt;int, int\u0026gt; STL_map\nmap为关联容器。为一种体现映射关系的容器，每个关键字对应一个值。\n数据会根据键值大小关系排序（升序）。\n数据元素都是成对出现(pair)。\n每一对中的第一个值称之为关键字(key)（也称键值），每个关键字只能在map中出现一次。\n第二个称之为该关键字的对应值(value)（也称实值）。\n用法 map\u0026lt;int, string\u0026gt; STL_map; //---初始构造--- STL_map = {{1,\u0026#34;a\u0026#34;},{2,\u0026#34;b\u0026#34;}};\t//为c++11标准 //---数组操作--- STL_map[25252] = \u0026#34;niconiconi\u0026#34;;\t//如果没有对应key则插入，如果已经存在则会修改value //---对整体的操作--- STL_map.clear(); STL_map.empty(); STL_map.size(); //---对元素的操作--- \t//insert过于麻烦不予讲解。 STL_map.erase(...);\t//删除对应key的元素，成功删除返回1，否则返回0 STL_map.count(...);\t//返回对应key元素的个数【由于map不能存在重复key，故只能返回0或1 //---迭代器--- STL_map.begin(); STL_map.end(); STL_map.find(...);\t//返回查找元素的迭代器，未找到返回map::end() STL_map.lower_bound(...)\t//返回key大于等于某值的第一个元素的迭代器 STL_map.upper_bound(...)\t//返回key大于某个值元素的迭代器 自定义性 set可支持自定义类型，但需要重载\u0026lt;运算符。\n struct type //用来存棋盘状态 { ...; bool operator\u0026lt;(type x) const { return ...; } }  实现 内部以红黑树的形式实现。\n应用场景 hash\n","date":"2020-12-03T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-stl/79059953_p0_hudcdceb022a1e552a3fbecef4125cea72_897862_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-note-stl/","title":"ACM学习笔记：STL……"},{"content":" 该笔记目前直接复制的之前的笔记，还未调整格式。页面格式、内容、链接等可能存在混乱错误…… \r 排序 不考虑算法  选择排序、冒泡排序、插入排序 $O(n^2)$ 计数排序、基数排序、桶排序 $O(n+w)$ 计数排序\n\r 希尔排序、锦标赛排序  快速排序 应用  寻找第k大的数  归并排序 应用  寻找逆序对\n可见之前笔记。\n（有关逆序对的问题还可以用树状数组或线段树来解决。）  对于逆序对问题的抽象：  询问最少经过几次（可能为相邻元素交换）交换，可使数列有序。   如果限制了为相邻元素交换，最开始很容易想到采用冒泡排序来做，但这样$O(n^2)$很容易TLE……\n发现即便是相邻交换，也是因为存在了逆序对才交换的……\n而每次交换后，能且仅能消除一个逆序对……\n要使序列达到最终有序，则肯定需要消除全部逆序对……\n故此类题目仍为求逆序对，且答案就为逆序对个数……\n 如果没有限制相邻元素交换，那么处理一位数，就能消除这位数的所有逆序对个数（与相邻交换的区别）\n所以就变成了找存在逆序对的位（简称：逆位）的个数。\n  模板题：\nP1908 逆序对  本地代码+题目分析+归并排序讲解+WA记录\n     总应用  贪心中的邻项交换排序  例题  P1774 最接近神的人  考点：归并排序、逆序对\n本地代码+题目分析+WA记录\n  SWJTU OJ-12.13 F XCPC  考点：归并排序、逆序对（没有相邻元素交换）\n题目分析\n   ","date":"2020-11-12T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-sort/86036732_p0_hud48aef1ba1119480544a4ab4b9f32654_3422651_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-note-sort/","title":"ACM学习笔记：排序……"},{"content":"离线和在线 指的是对于若干个询问操作的不同处理方式。\n在线 得到一次询问，便回答一次。\n离线 得到所有询问后，再统一回答。\n强制在线 离线算法一般都会对询问用id标记，然后进行排序操作，\n因此会打乱原本的询问顺序。\n e.g.\n对于五个询问$1,2,3,4,5$，\n离线算法可能按$3,1,4,5,2$的顺序进行计算，最后再统一回答询问。\n 因此如果要求：某次询问与之前的询问有复合操作（比如xor上次的询问），\n便使得不能读完所有操作，计算完后再统一回答，\n而只能读一个，计算一个，回答一个。\n这便是强制在线。\n","date":"0001-01-01T00:00:00Z","permalink":"https://blog.supersassw.com/p/","title":""}]