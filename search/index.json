[{"content":"测试 啥都没有……\n源码 /* 并查集算法 用father数组记录每个节点的父节点，数据结构类似于树 关键操作：合并、查询 详细介绍: https://zhuanlan.zhihu.com/p/93647900 */ //P3958 奶酪: https://www.luogu.com.cn/problem/P3958 #include \u0026lt;bits/stdc++.h\u0026gt;#define N 1005 using namespace std; inline int quickRead() { int f = 1, num = 0; char t = getchar(); while (t \u0026lt; \u0026#39;0\u0026#39; || t \u0026gt; \u0026#39;9\u0026#39;) f = t == \u0026#39;-\u0026#39; ? -1 : 1, t = getchar(); while (t \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; t \u0026lt;= \u0026#39;9\u0026#39;) num = num * 10 + t - \u0026#39;0\u0026#39;, t = getchar(); return f * num; } struct typeUnionFind { int num, father[N], rank[N]; //这里rank作用是记录节点深度（真实为深度-1），采用了按秩合并的优化  /* 按秩合并指将深度小的合并到深度大的树上，这样可以减少查询次数。 这里按秩合并与路径压缩一起使用时，rank可能会因路径压缩操作而变得不准确。 因此这里rank只是相对的判断标准，并不一定绝对会将深度小的合并到深度大的 */ void init(int n) { num = n; for (int i = 1; i \u0026lt;= num; i++) father[i] = i; } inline int find(int node) { return father[node] == node ? node : (father[node] = find(father[node])); //这里使用了路径压缩优化  } inline void merge(int node1, int node2) { int father1 = find(node1), father2 = find(node2); if (rank[father1] \u0026lt; rank[father2]) father[father1] = father2; else if (rank[father1] \u0026gt; rank[father2]) father[father2] = father1; else if (father1 != father2) father[father1] = father2, rank[father2]++; //如果深度一样且父节点不一样（不为一棵树），合并后新树深度会加一  } } UnionFind; struct typeHole { long long x, y, z; } hole[N]; bool ifIntersect(typeHole hole1, typeHole hole2, long long r) { return (hole1.x - hole2.x) * (hole1.x - hole2.x) + (hole1.y - hole2.y) * (hole1.y - hole2.y) + (hole1.z - hole2.z) * (hole1.z - hole2.z) \u0026lt;= 4 * r * r; } int main() { long long T, n, h, r; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;T); while (T--) { scanf(\u0026#34;%d%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;h, \u0026amp;r); UnionFind.init(n); UnionFind.father[1001] = 1001, UnionFind.father[1002] = 1002; //这里用特殊的两个节点，1001代表底，1002代表顶。如果father[1001]==father[1002]则证明连通。  for (int i = 1; i \u0026lt;= UnionFind.num; i++) { scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;hole[i].x, \u0026amp;hole[i].y, \u0026amp;hole[i].z); if (hole[i].z \u0026lt;= r) UnionFind.merge(1001, i); if (hole[i].z \u0026gt;= h - r) UnionFind.merge(1002, i); } for (int i = 1; i \u0026lt;= UnionFind.num; i++) for (int j = 1; j \u0026lt;= UnionFind.num \u0026amp;\u0026amp; i != j; j++) if (ifIntersect(hole[i], hole[j], r)) UnionFind.merge(i, j); if (UnionFind.find(1001) == UnionFind.find(1002)) printf(\u0026#34;Yes\\n\u0026#34;); else printf(\u0026#34;No\\n\u0026#34;); } } /* WA 1st: 没考虑到只有一个洞以及贯穿的情况…… 修改: 1. merge(i,1001) ---\u0026gt; mergr(1001,i) 实际上完全没必要，因为无论前并后还是后并前，最终都是父节点合并…… 2. if (hole.z\u0026lt;=r) ... else if (hole.z\u0026gt;=h-r) ...; ---\u0026gt; if ...; if ...; 当时想着要么是底部相交要么是顶部相交，导致用了个else if，没考虑到直接贯穿的情况…… WA 2nd: long long！！！！…… */ ","date":"2020-12-20T00:00:00Z","image":"https://supersass.github.io/p/union-find/60855211_p0_hu2f29f1f8fc777ac15405156777510011_1339015_120x120_fill_q75_box_smart1.jpg","permalink":"https://supersass.github.io/p/union-find/","title":"并查集……"},{"content":"简介 是一种用来维护 区间信息 的数据结构。\n可以实现的操作：\n 单点、区间修改 区间查询（区间求和、最大值、最小值） 等等  描述 线段树会将一个非点区间（即长度大于$1$）利用递归的思想，二分为两个子区间来进行操作。\n这样就会将一个线段划分转化成一个树形结构。\n其中：紫色的a[]是原数组，红色的d[]是线段树：存储的区间的和，黄色范围代表管辖区间。\n每个节点会存储并维护其所管辖的区间的当前信息。（如上图存的就是区间的和）\n可根据题目要求，确定自己所需存储维护的信息。\n实现方法 提前的宏定义 #define NOW_Node node[index]\t//代表当前节点 #define NOW_LSon node[index].sonL\t//代表当前节点左儿子下标 #define NOW_RSon node[index].sonR\t//代表当前节点右儿子下标 0x00 建树 基本认识 根据上图可发现几个要点：\n 每一个节点i的左儿子下标是2i，右儿子下标是2i+1。 记：i管辖的区间为$[s,t]$。\n令：$mid=\\frac{s+t}{2}$。\n则左儿子2i管辖区间为$[s,mid]$，右儿子2i+1管辖区间为$[mid+1,t]$。  实现方法 之前已经介绍了递归的思想，那么只需要确定递归边界。\n由上图很容易看出，递归边界就是当长度为$1$的点。\n记：当前点为node[index]，代表区间为$[l,r]$。原数组为arr[]\n当$l=r$的时候，说明到达递归边界，这个时候的值直接为对应区间的值。\n也就是node[index] = arr[r]\n因为二分的操作使得递归的深度不会大于$log(n)$，故完全可以采用递归的方式简化代码，不用担心递归的栈溢出等缺点。\n储存方法 方法1、 struct typeNode { int val, L, R, mid, len;\t//val代表储存的值，L、R分别代表区间左、右端点，mid代表区间中点，len代表区间长度 }node[4*N]; 直接用左儿子下标为2i，右儿子下标为2i+1转递。\n函数为build(int index, int l, int r)，建左儿子用则为build(2*i, l, r)。\n 空间范围：反正直接把长度设置为$4n$。\n因为该线段树深度为$\\lceil log(n) \\rceil$，又因为为完全二叉树，总节点个数为$2^{\\lceil log(n) \\rceil +1}-1$。但建树的时候最后一层不一定从左往右建，也可能很右边会有一个，所以要预留出所有的最后一层的节点位置，即开$4N$。\n具体分析见关于线段树的数组到底是开2N还是4N。  方法2、 struct typeNode { int val, L, R, mid, len, sonL, sonR;\t//多了个sonL和sonR，代表左儿子的index和右儿子的index }node[2*N]; build()的时候需要多一个计数器变量cnt，记录总过有多少节点。\n函数为build(int \u0026amp;index, int l, int r)。其中传引用会在伪代码中解释。\n这里多存了个左儿子和右儿子的下标，使得可以保证从按顺序建，不会出现空间浪费，于是可以开$2N$。\n相较于方法2空间消耗会少一点。\n以下采用“方法2”的方式来储存。\n伪代码 struct typeSegment{ int cnt = 0;\t//记录node节点的数量，便可实现按顺序建树  struct typeNode{ int val, L, R, len, mid, sonL = 0, sonR = 0; } node[N * 2]; void build(int \u0026amp;index, int L, int R) //对区间[L,R]建立节点，下标为index \t{ index = ++cnt; /*引用index的原因： 这里因为引用index，在递归时会直接把seg[index].son_赋值为某儿子的index。 */ NOW_Node.L = L, NOW_Node.R = R, NOW_Node.mid = (L + R) \u0026gt;\u0026gt; 1, NOW_Node.len = R - L + 1;//节点基本信息  if (L == R) NOW_Node.val = arr[R]; //为递归边界，直接为对应区间的值 \telse { build(NOW_LSon, L, NOW_Node.mid); //划分建立左区间，注意这里传的index是sed[index].lson \tbuild(NOW_RSon, NOW_Node.mid + 1, R); //划分建立右区间 \tNOW_Node.val = node[NOW_LSon].val + node[NOW_RSon].val; //计算该区间信息 \t} } }Segment;\t//直接用个总结构体，便于模板化。//其实就是个个人癖好orz…… 0x01 区间查询 对区间进行值的条件查询，如对区间$[L,R]$求总和，求区间最值等操作。\n实现方法 将要查询的区间，拆成几个在其范围里的节点的区间进行求解计算。（类似于分块思想）\n 如果当前区间完全在查询区间的范围里，则直接返回这个区间的值。 如果不是，则分别查询左右区间计算最终值。  如果查询区间的左端点小于等于当前区间中点，则查询范围会存在于左儿子区间里，要查询左儿子。 如果查询区间的右端点大于当前区间中点，则查询范围会存在于右儿子区间里，要查询右儿子。  ⚠注意：这里为大于！因为中点是算在左区间里的！……\n     【直接给代码吧ヾ(•ω•`)o……\n伪代码 int query(int index, const int \u0026amp;q_L, const int \u0026amp;q_R) { if (q_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; q_R\u0026lt;= NOW_Node.R) return NOW_Node.val; //当前区间直接在查询区间里，直接返回值 \t//【我查了，一句返回了，有什么好说的…… \t//↓ 不完全包含于查询区间里，就要查询两子区间的值计算 \tint tmpAns = 0; if (q_L \u0026lt;= NOW_Node.mid) tmpAns += query(NOW_LSon, q_L, q_R); //如果要查询区间左端点，比当前区间的中点还大，证明左儿子区间完全不在 \tif (q_R \u0026gt; NOW_Node.mid) tmpAns += query(NOW_RSon, q_L, q_R);\t//为\u0026gt;，不是\u0026gt;= \treturn tmpAns; } 0x02 区间修改 对区间进行值的修改，如区间$[L,R]$加上或乘上一个数。\n(最初)实现方法 跟查询的方法一样，找到对应区间后直接修改值。\n但注意，如果不是长度为1的区间，值的修改要乘上对应修改区间的长度。\n 比如对$[1,2]$这个区间加上$2$。\n$[1,1]$和$[2,2]$这两个子区间会加$2$。\n但$[1,2]$则个大的区间应该加的就是$4$。\n同理，$[1,4]$这个大区间就该加$8$了。\n 缺点分析 【诶我说停停，先别着急写啊，不要啪的一下就写起来了很快啊……\n如果碰上这样的情况：\n  对区间$[1,10000]$加上$10000$次$233$。 查询区间$[23333,23333]$的值。   怎么样，有没有觉得自己被耍了！\n所以如果当老实人，他让我们修改区间，我们就老老实实修改区间，可是要吃大亏的。【指TLE……\n改进方法 所以他耍我们，我们也耍一下他xd。\n不是让我们对区间修改吗，我们就先偷下懒：不老老实实地全部修改完，只做个记号在那。\n等到他让我们真正查询这个区间的时候，我们也才真正的去修改，并返回查询值。【并且注意lazy清零！……\n这便是lazy懒标记的由来。\n但我们该怎么偷懒呢？\n 如果当前区间完全在修改区间的范围里，我们便可以按分析的那样，先把修改的值加到lazy里。等之后有需要再去真正地修改，即“下放lazy”。 如果不是，这里就需要注意，我们再直接加到lazy标记的话，有些明明不该修改的区间就会被修改。所以这里的懒就偷不得，就要真正的修改当前节点的值，并尝试修改子节点。（但如果儿子可以偷懒，就让儿子去偷懒）  如果修改区间的左端点大于当前区间中点，则不会修改左儿子区间。 如果修改区间的右端点小于等于当前区间中点，则不会修改右儿子区间。    伪代码  区间修改：  struct typeNode{ int ..., lazy;\t//这里多定义个lazy，用来存偷懒没修改的值 } void modify(int index, const int \u0026amp;m_L, const int \u0026amp;m_R, const int \u0026amp;m_val) { if (m_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; NOW_Node.R \u0026lt;= m_R) NOW_Node.lazy += m_val;\t//当前区间完全在范围里，直接偷懒 \telse { NOW_Node.val += (min(m_R, NOW_Node.R) - max(m_L, NOW_Node.L) + 1) * m_val;\t/* 这里是修改所包含区间的值 如要修改[4,9]，当前节点区间是(1,6)\t//这里为了区分用的小括号，实际上包含端点 则只会修改[4,6)，也就是val += (6 - 4 + 1) * 2 */ if (m_L \u0026lt;= NOW_Node.mid) modify(NOW_LSon, m_L, m_R, m_val); if (m_R \u0026gt; NOW_Node.mid) modify(NOW_RSon, m_L, m_R, m_val); } }  有lazy的区间查询：  struct typeNode{ ... void pushdown(typeSegment *Segment)\t//下放也不用太彻底，能摸一层是一层xd…… \t{ val += len * lazy;\tif (sonL) Segment.modify(sonL, L, mid, lazy); //存在子节点才下放【不然我这种结构就会无限下放_(:з」∠)_…… \tif (sonR) Segment.modify(sonR, mid + 1, R, lazy); lazy = 0;\t//！lazy注意清零！ \t} } int query(int index, const int \u0026amp;q_L, const int \u0026amp;q_R) { if (NOW_Node.lazy) NOW_Node.pushdown(*this);\t//注意查询的时候，只要有懒标记就必下放【别人都来查岗了你还摸鱼.jpg……  if (q_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; NOW_Node.R \u0026lt;= q_R)\t//以下跟普通的查询操作一样 \treturn NOW_Node.val; int tmpAns = 0; if (q_L \u0026lt;= NOW_Node.mid) tmpAns += query(NOW_LSon, q_L, q_R); if (q_R \u0026gt; NOW_Node.mid) tmpAns += query(NOW_RSon, q_L, q_R); return tmpAns; } Tip: 我这里的偷懒是直接连本身都先不修改，而在下放的时候才修改；其他人有些可能会先修改自身。算是个小优化，注意区分一下……\n最终代码 洛谷P3372 【模板】线段树 1\n#include \u0026lt;bits/stdc++.h\u0026gt; #define N 100000  #define NOW_Node node[index]\t//代表当前节点 #define NOW_LSon node[index].sonL //代表当前节点左儿子下标 #define NOW_RSon node[index].sonR //代表当前节点右儿子下标 using namespace std; long long arr[N + 5]; struct typeSegment { int cnt = 0; //记录node节点的数量，便可实现按顺序建树  struct typeNode { long long val; int L, R, len, mid, sonL = 0, sonR = 0, lazy = 0; void pushdown(typeSegment \u0026amp;Segment) //下放也不用太彻底，左右儿子仍加到lazy里。【能摸一层是一层xd…… \t{ val += len * lazy; if (sonL) Segment.modify(sonL, L, mid, lazy); //存在子节点才下放【不然我这种结构就会无限下放 \tif (sonR) Segment.modify(sonR, mid + 1, R, lazy); lazy = 0; //lazy注意清零。 \t} } node[N * 2]; void build(int \u0026amp;index, int L, int R) //对区间[l,r]建立节点，下标为index \t{ index = ++cnt; //引用原因： \t//这里因为引用index的原因，在递归时会直接把seg[index].lson赋值为左儿子的index。 \tNOW_Node.L = L, NOW_Node.R = R, NOW_Node.mid = (L + R) \u0026gt;\u0026gt; 1, NOW_Node.len = R - L + 1; //节点基本信息 \tif (L == R) NOW_Node.val = arr[R]; //为递归边界，直接为对应区间的值 \telse { build(NOW_LSon, L, NOW_Node.mid); //划分建立左区间，注意这里传的index是sed[index].lson \tbuild(NOW_RSon, NOW_Node.mid + 1, R); //划分建立右区间 \tNOW_Node.val = node[NOW_LSon].val + node[NOW_RSon].val; //计算该区间信息 \t} } void modify(int index, const int \u0026amp;m_L, const int \u0026amp;m_R, const int \u0026amp;m_val) { if (m_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; NOW_Node.R \u0026lt;= m_R) NOW_Node.lazy += m_val; //当前区间完全在范围里，直接偷懒。 \telse { NOW_Node.val += (min(m_R, NOW_Node.R) - max(m_L, NOW_Node.L) + 1) * m_val; /* 这里是修改所包含区间的值 如要修改[4,9]，当前节点区间是(1,6)\t//这里为了区分用的小括号，实际上包含端点 则只会修改[4,6)，也就是val += (6 - 4 + 1) * 2 */ if (m_L \u0026lt;= NOW_Node.mid) modify(NOW_LSon, m_L, m_R, m_val); if (m_R \u0026gt; NOW_Node.mid) modify(NOW_RSon, m_L, m_R, m_val); } } long long query(int index, const int \u0026amp;q_L, const int \u0026amp;q_R) { if (NOW_Node.lazy) //注意查询的时候，只要有懒标记就必下放【别人都来查岗了你还摸鱼.jpg…… \tNOW_Node.pushdown(*this); if (q_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; NOW_Node.R \u0026lt;= q_R) return NOW_Node.val; //当前区间直接在查询区间里，直接返回值//【我查了，一句返回了，有什么好说的……  //↓ 不完全包含于查询区间里，就要查询两子区间的值计算 \tlong long tmpAns = 0; if (q_L \u0026lt;= NOW_Node.mid) tmpAns += query(NOW_LSon, q_L, q_R); //如果要查询区间左端点，比当前区间的中点还大，证明左儿子区间完全不在 \tif (q_R \u0026gt; NOW_Node.mid) tmpAns += query(NOW_RSon, q_L, q_R); return tmpAns; } } Segment; //直接用个大的结构体，便于模板化。 int main() { int n, m, tmp, w, l, r, i; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;arr[i]); Segment.build(tmp, 1, n); //Segment.test(1); \twhile (m--) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;w); if (w == 1) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;i); Segment.modify(1, l, r, i); } else { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); printf(\u0026#34;%lld\\n\u0026#34;, Segment.query(1, l, r)); } } } ","date":"2020-12-20T00:00:00Z","image":"https://supersass.github.io/p/segment-tree/67957130_p0_hu2c7318d0e2072da042ef7a1c5115b73e_4170699_120x120_fill_box_smart1_2.png","permalink":"https://supersass.github.io/p/segment-tree/","title":"线段树……"},{"content":"音乐播放器 采用的APlayer的外链播放器……\n默认会显示在文章顶部……\n如需用吸底模式，请在第一个参数输入-fixed: 1……\n","date":"2020-12-19T00:00:00Z","image":"https://supersass.github.io/p/test-player/84038692_p0_hu3b9cb195d3b981b9da74048e9a17f8de_395719_120x120_fill_q75_box_smart1.jpg","permalink":"https://supersass.github.io/p/test-player/","title":"音乐播放器……"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用  思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n 图片 \r\rPhoto by Florian Klauer on Unsplash\r \r\rPhoto by Luca Bravo on Unsplash\r\n\r\rPhoto by Helena Hertz on Unsplash\r \r\rPhoto by Hudai Gayiran on Unsplash\r\n![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://supersass.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://supersass.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"Shortcode Hugo的Shortcode的测试……\n新增了Bilibili的链接……\n 不知道是什么的原文x：\n Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\n  YouTube Privacy Enhanced Shortcode \r\r Bilibili Simple Shortcode \r   使用方法：\n\u0026lt; bilibili BV1754y1R7Nd \u0026gt; 外部加上两对大括号{}。\n  默认为BV号。\n 可选参数：  av = \u0026quot;...\u0026quot;：使用av号。\n使用例：\u0026lt; bilibli av=\u0026quot;10492\u0026quot;\u0026gt; hq = *：画质。0为低画质，1为高画质。（默认值为1） p = *：视频选集。（默认值为1）    ","date":"2020-09-09T00:00:00Z","image":"https://supersass.github.io/p/test-shortcode/78356827_p0_huc21610886fa327c8e802235e20e8c4e7_690415_120x120_fill_q75_box_smart1.jpg","permalink":"https://supersass.github.io/p/test-shortcode/","title":"Shortcode Test"}]